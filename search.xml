<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSS 基础]]></title>
    <url>%2F2019%2F08%2F28%2FCSS-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[CSS基础知识CSS 指层叠样式表 (Cascading Style Sheets)，是一种用来表现 HTML 文档样式的语言，样式定义如何显示 HTML 元素，是能够真正做到网页表现与结构分离的一种样式设计语言。 外部样式表可以极大提高工作效率 外部样式表通常存储在CSS文件中 多个样式定义可层叠为一 层叠次序 浏览器缺省设置 外部样式表 内部样式表(位于&lt;head&gt;标签内部) 内联样式表(在HTML元素内部) 选择器优先级 内联样式的权重为1000 ID选择器的权重为100 类选择器的权重为10 元素选择器的权重为1 权重计算永不进位 CSS语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器的分组，用都好将需要分组的选择器分开 集成及其问题，子元素从父元素继承属性有些浏览器不支持其继承，可以用组选择器 !important定义和用法提升指定样式规则的应用优先权。 div{color:#f00!important;color:#000;} comment定义和用法/* 这里是注释内容 */ @import定义和用法指定导入的外部样式表及目标媒体。 &lt;url&gt;：使用绝对或相对地址指定导入的外部样式表文件。可以是url(url)或者直接是一个url &lt;media_query_list&gt;：指定媒体类型和查询条件。 123@import url(example.css) screen and (min-width:800px);@import url(example.css) screen and (width:800px),(color);@import url(example.css) screen and (min-device-width:500px) and (max-device-width:1024px); @charset定义和用法在外部样式表文件内使用。指定该样式表使用的字符编码。 &lt;charset&gt;：字符编码。如：@charset “utf-8”; @media定义和用法指定样式表规则用于指定的媒体类型和查询条件 媒体类型 描述 all 所有浏览器-用于所有媒体设备类型 aural Opera-用于语音和音乐合成器 braille Opera-用于触觉反馈设备 handheld Chrome,Safari,Opera-用于小型或手持设备 print 所有浏览器-用于打印机 projection Opera-用于投影图像，如幻灯片 screen 所有浏览器-用于计算机显示器 tty Opera-用于使用固定间距字符格的设备。如电传打字机和终端 tv Opera-用于电视类设备 embossed Opera-用于凸点字符（盲文）印刷设备 123456789@media all and (width:1024px)&#123; body&#123;color:#f00;&#125;&#125;@media all and (device-height:800px)&#123; … &#125;@media all and (orientation:landscape)&#123; … &#125;@media all and (device-aspect-ratio:16/10)&#123; … &#125;@media all and (min-color:1)&#123; … &#125;@media all and (monochrome:0)&#123; … &#125;@media all and (grid:0)&#123; … &#125; @font-face定义和用法设置嵌入HTML文档的字体。 &lt;identifier&gt;：字体名称 &lt;url&gt;：此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径 &lt;string&gt;：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype, opentype，embedded-opentype, svg等 &lt;font&gt;：定义字体相关样式 12345678@font-face &#123; font-family: &apos;diyfont&apos;; src: url(&apos;diyfont.eot&apos;); /* IE9+ */ src: url(&apos;diyfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;diyfont.woff&apos;) format(&apos;woff&apos;), /* chrome、firefox */ url(&apos;diyfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url(&apos;diyfont.svg#fontname&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125; @page定义和用法设置页面容器的版式，方向，边空等。 &lt;label&gt;：页面标识符 &lt;pseudo-class&gt;：打印伪类:first, :left, :right @page:first{margin:300px;} @keyframes定义和用法指定动画名称和动画效果。@keyframes定义的动画名称用来被animation-name所使用。定义动画时，简单的动画可以直接使用关键字from和to，即从一种状态过渡到另一种状态： 12345678@keyframes testanimations&#123; 0%&#123;transform:translate(0,0);&#125; 20%&#123;transform:translate(20,20);&#125; 40%&#123;transform:translate(40,0);&#125; 60%&#123;transform:translate(60,20);&#125; 80%&#123;transform:translate(80,0);&#125; 100%&#123;transform:translate(100,20);&#125;&#125; CSS 函数 名称 描述 counter() 插入计数器，counter()只能被使用在content属性上。li:before{counter-increment:item;content:counter(item)&quot;.&quot;;color:#f00;} attr() 插入元素的属性值。div{width:attr(width, px, auto);} calc() 用于动态计算长度值。任何长度值都可以使用calc()函数进行计算。calc()函数支持+, -, *, /, mod运算，以后还可能加入对min()/max()等运算。.test{width:-moz-calc(100% - 50px);width:calc(100% - 50px);background:#eee;} min()浏览器不支持 用于比较数值的大小并取出最小的那个。div{width:min(10% + 20px, 300px);} max()浏览器不支持 用于比较数值的大小并取出最大的那个。div{width:max(10% + 20px, 300px);} cycle()浏览器不支持 允许子孙元素使用取值序列中的值循环替换继承而来的值。li &gt; ul{list-style-type:toggle(disk,circle,square,box);} Image 属性 描述 linear-gradient() 用线性渐变创建图像。 radial-gradient() 用径向渐变创建图像。 repeating-linear-gradient() 用重复的线性渐变创建图像。 repeating-radial-gradient() 用重复的径向渐变创建图像。 CSS单位CSS 的单位对于 CSS 的值有是一个直接影响的。因为 CSS 的单位直接对 CSS 的值的计算是有直接影响的，在 CSS 中单位的之间有一个关系如下所示： 单位 描述 角度单位&lt;angle&gt; deg：度grad：梯度rad：弧度turn：圈 字体单位&lt;length&gt; em：相对于父元素rem：相对于根元素ch：数字“0”的宽度ex：相对长度单位。相对于字符“x”的高度。通常为字体高度的一半。 频率单位&lt;frequency&gt; Hz：赫兹KHz：千赫兹 整数单位&lt;length&gt; px：相对长度单位，像素 长度单位&lt;length&gt; cm：厘米（Centimeters）。绝对长度单位。mm：毫米（Millimeters）。绝对长度单位。in：英寸（Inches）。绝对长度单位。pt：点（Points）。绝对长度单位。pc：派卡（Picas）。绝对长度单位。相当于我国新四号铅字的尺寸。px：相对长度单位。像素（Pixels）。 百分比单位 %：百分比 分辨率单位&lt;resolution&gt; dpi：每英寸包含点的数量（dots per inch）普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx），打印时一般会需要更大的dpi；dpcm：每厘米包含点的数量（dots per centimeter）dppx：每像素包含点的数量（dots per pixel） 时间单位&lt;time&gt; s:秒ms:毫秒 视窗单位&lt;length&gt; vw：相对于视口的宽度。视口被均分为100单位的vwvh：相对于视口的高度。视口被均分为100单位的vhvmax：相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmaxvmin：相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin 单位 描述 相对单位 字体相对单位：em、rem、ch、ex视窗相对单位：vw、vh、vmax、vmin 绝对单位 px、pt、pc、cm、mm、in 角度单位 deg、grad、rad、turn 时间单位 s、ms 分辨率单位 dpi、dpcm、dppx 频率单位 Hz、KHz 绝对单位不受任何屏幕大小或字体的影响。这些单位的显示可能会根据不同的屏幕分辨率而有所不同，因为它们取决于屏幕的DPI（每英寸上的点数）。绝对单位常用于一些物理测量上。在环境输出已知的情形下非常有用。 分辨率术语 术语 描述 720P 1280*720-称为：HD，中文译为“高清” 1080P 1920*1080-称为：FULL HD，中文称为“全高清” 1440P 2560*1440-称为：QHD或Quad HD,即4倍的HD 2160P 3840*2160-称为：4K 4320P 7680*4320-称为：8K 参考地址：https://www.w3cplus.com/css/css-values-and-units.html 颜色值 属性 描述 HEX 颜色值十六进制(HEX)表示,语法如：#rrggbb或#rgb RGB RGB表示方式，语法如：rgb(128,128,128) RGBA 颜色值RGBA表示方式，语法如：rgba(128,128,128,0.5) HSL 颜色值HSL表示方式，HSL(Hue-色调,Saturation-饱和度,Lightness-亮度) HSLA 颜色值HSLA表示方式，HSL(Hue-色调,Saturation-饱和度,Lightness-亮度,Alpha-透明度)语法如：hsla(360,50%,50%,0.5) Transparent 颜色值透明(Transparent)表示方式(RGBA) 元素选择符 选择符 描述 通配选择符* 选定所有对象。 类型选择符E 以文档语言对象类型作为选择符。 ID选择符E#ID 以唯一标识符id属性等于myid的E对象作为选择符。 类选择符E.Class 以class属性包含myclass的E对象作为选择符。 关系选择符 选择符 描述 包含选择符E F 选择所有被E元素包含的F元素。 子选择符E&gt;F 选择所有作为E元素的子元素F。 相邻选择符E+F 选择紧贴在E元素之后F元素。 兄弟选择符E~F 选择E元素后面的所有兄弟元素F。 属性选择符 选择符 描述 E[att] 选择具有att属性的E元素。 E[att=&quot;val&quot;] 选择具有att属性且属性值等于val的E元素。 E[att~=&quot;val&quot;] 选择具有att属性且属性值为一用空格分隔的字词列表，其中一个等于val的E元素。 E[att^=&quot;val&quot;] 选择具有att属性且属性值为以val开头的字符串的E元素。 E[att$=&quot;val&quot;] 选择具有att属性且属性值为以val结尾的字符串的E元素。 E[att*=&quot;val&quot;] 选择具有att属性且属性值为包含val的字符串的E元素。 `E[att =”val”]` 伪类选择符 选择符 描述 link 设置超链接a在未被访问前的样式。 visited 设置超链接a在其链接地址已被访问过时的样式。 hover 设置元素在其鼠标悬停时的样式。 active 设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 focus 设置元素在成为输入焦点（该元素的onfocus事件发生）时的样式。 lang(fr) 匹配使用特殊语言的E元素。 not(s) 匹配不含有s选择符的元素E。 root 匹配E元素在文档的根元素。 first-child 匹配父元素的第一个子元素E。 last-child 匹配父元素的最后一个子元素E。 only-child 匹配父元素仅有的一个子元素E。 nth-child(n) 匹配父元素的第n个子元素E。 nth-last-child(n) 匹配父元素的倒数第n个子元素E。 first-of-type 匹配同类型中的第一个同级兄弟元素E。 last-of-type 匹配同类型中的最后一个同级兄弟元素E。 only-of-type 匹配同类型中的唯一的一个同级兄弟元素E。 nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E。 nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E。 empty 匹配没有任何子元素（包括text节点）的元素E。 checked 匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时) enabled 匹配用户界面上处于可用状态的元素E。 disabled 匹配用户界面上处于禁用状态的元素E。 target 匹配相关URL指向的E元素。 @page:first 设置页面容器第一页使用的样式。仅用于@page规则 @page:left 设置页面容器位于装订线左边的所有页面使用的样式。仅用于@page规则 @page:right 设置页面容器位于装订线右边的所有页面使用的样式。仅用于@page规则 伪对象选择符 选择符 描述 first-letter/:first-letter 设置对象内的第一个字符的样式。 first-line/:first-line 设置对象内的第一行的样式。 before/:before 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 after/:after 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 :selection 设置对象被选择时的颜色。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5地理定位]]></title>
    <url>%2F2019%2F08%2F27%2FHTML5%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[位置定位地理位置（Geolocation）是 HTML5 的重要特性之一，提供了确定用户位置的功能，借助这个特性能够开发基于位置信息的应用。 检测浏览器是否支持123456if (navigator.geolocation) &#123;//console.log(&quot;浏览器支持!&quot;);&#125;else &#123;// console.log(&quot;浏览器不支持!&quot;);&#125; navigator.geolocation用于获取基于浏览器的当前用户地理位置123456789// 1、获取用户当前位置void getCurrentPosition(onSuccess,onError,options);// 2、持续获取当前用户位置int watchCurrentPosition(onSuccess,onError,options);// 3、watchId 为watchCurrentPosition返回的值void clearWatch(watchId);// 取消监控 示例代码PS：也可以调用百度地图、谷歌地图、高德地图等，只需要将HTML5 Geolocation API获取到的值传入到相应的地图接口中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;/&gt;&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no&quot;&gt;&lt;title&gt;基于浏览器的HTML5地理定位&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;div id=&quot;info&quot;&gt;&lt;/div&gt; &lt;script src=&quot;http://map.qq.com/api/js?v=2.exp&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script&gt; var clientWidth = document.documentElement.clientWidth, clientHeight = document.documentElement.clientHeight; var container = document.getElementById(&apos;container&apos;); container.style.width = clientWidth + &apos;px&apos;; container.style.height = clientHeight + &apos;px&apos;; function getLocation()&#123; var options=&#123; enableHighAccuracy:true, //boolean 是否要求高精度的地理信息，默认为false maximumAge:1000 //应用程序的缓存时间 &#125; if(navigator.geolocation)&#123; //浏览器支持geolocation navigator.geolocation.getCurrentPosition(onSuccess,onError,options); &#125;else&#123; //浏览器不支持geolocation console.log(&quot;浏览器不支持!&quot;); &#125; &#125; //成功时 function onSuccess(position)&#123; //返回用户位置 //经度 var longitude =position.coords.longitude; //纬度 var latitude = position.coords.latitude; //腾讯地图的中心地理坐标 var center = new qq.maps.LatLng(latitude, longitude); //使用腾讯地图API var map = new qq.maps.Map(document.getElementById(&quot;container&quot;), &#123; //地图的中心地理坐标 center: center, //初始化地图缩放级别 zoom: 16 &#125;); //在地图中创建信息提示窗口 var infoWin = new qq.maps.InfoWindow(&#123; map: map &#125;); //打开信息窗口 infoWin.open(); //设置信息窗口显示区的内容 infoWin.setContent(&apos;&lt;div style=&quot;width:200px;padding:10px;&quot;&gt;&apos;+ &apos;您在这里&lt;br/&gt;纬度：&apos;+ latitude+ &apos;&lt;br/&gt;经度：&apos;+longitude); //设置信息窗口的位置 infoWin.setPosition(center); &#125; //失败时 function onError(error)&#123; switch(error.code)&#123; case error.PERMISSION_DENIED: alert(&quot;用户拒绝对获取地理位置的请求&quot;); break; case error.POSITION_UNAVAILABLE: alert(&quot;位置信息是不可用的&quot;); break; case error.TIMEOUT: alert(&quot;请求用户地理位置超时&quot;); break; case error.UNKNOWN_ERROR: alert(&quot;未知错误&quot;); break; &#125; &#125; window.onload=getLocation; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 服务器发送事件]]></title>
    <url>%2F2019%2F08%2F27%2FHTML5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Server-Sent EventsServer-Sent Events(SSE)用于网页自动获取服务器上更新的数据，它是一个实时性的机制 实时性获取数据 Polling(轮询)：在客户端重复的向服务端发送新请求。如果服务器没有新的数据更动，关闭本次连接。然后客户端在稍等一段时间之后，再次发起新请求，一直重复这样的步骤。 Long-polling(长轮询)：在长轮询中，客户端发送一个请求到服务端。如果服务端没有新的数据更动，那么本次连接将会被保持，直到等待到更新后的数据，返回给客户端并关闭这个连接。 Server-Sent Events：SSE类似于长轮询的机制，但是它在每一次的连接中，不只等待一次数据的更动。客户端发送一个请求到服务端 ，服务端保持这个请求直到一个新的消息准备好，将消息返回至客户端，此时不关闭连接，仍然保持它，供其它消息使用。SSE的一大特色就是重复利用一个连接来处理每一个消息（又称event）。 WebSocker：WebSocket不同于以上的这些技术，因为它提供了一个真正意义上的双向连接。WebSocket是HTML5中非常强大的新特性，已经得到广泛应用。 Server-Sent Events实现在后台获取时间，不断发送给前台。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;获得服务器更新&lt;/h1&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt; if(typeof(EventSource)!==&quot;undefined&quot;)&#123; var source=new EventSource(&quot;/example/html5/demo_sse.php&quot;); source.onmessage=function(event)&#123; document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;; alert(&quot;提示有新的内容&quot;); this.location.reload(); &#125;; &#125; else &#123; document.getElementById(&quot;result&quot;).innerHTML=&quot;抱歉，您的浏览器不支持 server-sent 事件 ...&quot;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端代码12345678&lt;?php header(&apos;Content-Type: text/event-stream&apos;); header(&apos;Cache-Control: no-cache&apos;); $time = date(&apos;r&apos;); echo &quot;data: The server time is: &#123;$time&#125;\n\n&quot;; flush();?&gt; EventSource对象 属性 描述 onopen 当通信服务器连接被打开 onmessage 当接收到消息 onerror 当发生错误 其他自动刷新方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 1.页面自动刷新：把如下代码加入&lt;head&gt;区域中 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt;,其中20指每隔20秒刷新一次页面. // 2.页面自动跳转：把如下代码加入&lt;head&gt;区域中 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;20;url=http://www.jb51.net&quot;&gt;// 其中20指隔20秒后跳转到http://www.jb51.net页面 // 3.页面自动刷新js版 &lt;script language=&quot;javascript&quot;&gt; function myrefresh()&#123; window.location.reload(); &#125; setTimeout(&apos;myrefresh()&apos;,1000); //指定1秒刷新一次 &lt;/script&gt; // 4.websocker&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;websocket&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function WebSocketTest() &#123; if (&quot;WebSocket&quot; in window) &#123; alert(&quot;您的浏览器支持 WebSocket!&quot;); // 打开一个 web socket var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(&quot;发送数据&quot;); alert(&quot;数据发送中...&quot;); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(&quot;数据已接收...&quot;); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(&quot;连接已关闭...&quot;); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(&quot;您的浏览器不支持 WebSocket!&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sse&quot;&gt; &lt;a href=&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 Web Worker用法]]></title>
    <url>%2F2019%2F08%2F26%2FHTML5-Web-Worker%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Web Worker的用法简单来说，其实就是在Javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后再回到主线程上，在这个过程中并不影响主线程的执行过程。 判断当前浏览器是否支持web worker1234567891011121314151617if (typeof (Worker) != &quot;undefined&quot;) &#123; //浏览器支持web worker if (typeof (w) == &quot;undefined&quot;) &#123; //w是未定义的,还没有开始计数 w = new Worker(&quot;webworker.js&quot;); //创建一个Worker对象,利用Worker的构造函数 &#125; //onmessage是Worker对象的properties w.onmessage = function (event) &#123; //事件处理函数,用来处理后端的web worker传递过来的消息 // do something &#125;;&#125; else &#123; // 浏览器不支持web worker // do something&#125; API 创建新的Worker var worker = new Worker(&quot;worker.js&quot;) 传递参数 worker.postMessage() 接收消息 worker.onMessage = function(msg){} 异常处理 worker.onerror = function(err){} 结束worker worker.terminate() 载入工具类函数 importScripts() 作用域创建一个新的worker时，该代码会运行在一个全新的javascript的环境中（WorkerGlobalScope）运行,是完全和创建worker的脚本隔离，这时我们可以把创建新worker的脚本叫做主线程，而被创建的新的worker叫做子线程。 WorkerGlobalScope是worker的全局对象，所以它包含所有核心javascript全局对象拥有的属性如JSON等，window的一些属性，也拥有类似于XMLHttpRequest()等。 但是我们所开启的新的worker也就是子线程，并不支持操作页面的DOM。 共享线程（SharedWorker）共享线程是为了避免线程的重复创建和销毁过程，降低了系统性能的消耗，共享线程SharedWorker可以同时有多个页面的线程链接。 var worker = new SharedWorker(&quot;sharedworker.js&quot;); 共享线程也使用了message事件监听线程消息，但使用SharedWorker对象的port属性与线程通信如下: worker.port.onmessage = function(msg){}; 同时我们也可以使用SharedWorker对象的port属性向共享线程发送消息如下： worker.port.postMessage(msg); 应用 可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信 可以在worker中通过importScripts(url)加载另外的脚本文件 可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval() 可以使用XMLHttpRequest来发送请求 可以访问navigator的部分属性 注意事项 不能跨域加载JS worker内代码不能访问DOM 各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行 不是每个浏览器都支持这个新特性]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5本地存储]]></title>
    <url>%2F2019%2F08%2F26%2FHTML5%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[localStroage &amp; sessionStroageHTML5 提供了本地存储对象 window.localStroage - 存储没有截止日期的数据（localStorage 生命周期是永久，除非主动清除 localStorage 信息，否则这些信息将永远存在。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。） window.sessionStroage - 针对一个 Session 的数据存储（仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。） 两者区别就是一个作为临时保存，一个长期保存。 之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 localStroage123456789// 1、保存数据到本地// 第一个参数是保存的变量名，第二个是赋给变量的值localStorage.setItem(&apos;Author&apos;, &apos;local&apos;);// 2、从本地存储获取数据localStorage.getItem(&apos;Author&apos;);// 3、从本地存储删除某个已保存的数据localStorage.removeItem(&apos;Author&apos;);// 4、清除所有保存的数据localStorage.clear(); 应用场景实际工作中对 localstorage 的使用一般有以下需求： 缓存一般信息，如搜索页的出发城市，达到城市，非实时定位信息 缓存城市列表数据，这个数据往往比较大 每条缓存信息需要可追踪，比如服务器通知城市数据更新，这个时候在最近一次访问的时候要自动设置过期 每条信息具有过期日期状态，在过期外时间需要由服务器拉取数据 ………… sessionStroage123456789// 1、保存数据到本地// 第一个参数是保存的变量名，第二个是赋给变量的值sessionStorage.setItem(&apos;Author&apos;, &apos;session&apos;);// 2、从本地存储获取数据sessionStorage.getItem(&apos;Author&apos;);// 3、从本地存储删除某个已保存的数据sessionStorage.removeItem(&apos;Author&apos;);// 4、清除所有保存的数据sessionStorage.clear(); 其他隐私模式下可以采用 window.name 模拟 sessionStorage 的方式处理，因为 window.name 是可做保存的，这个也是其解决跨域方案的原因。 postMessage 发送：调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象 otherWindow.postMessage(message, targetOrigin, [transfer]); 监听：message 事件 window.addEventListener( &quot;message&quot;, function(event) {alert(event.data);}) 假设在 a.html 里嵌套个&lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;,在这两个页面里互相通信 a.com/a.html1234567window.onload = function() &#123; window.addEventListener(&quot;message&quot;, function(event) &#123; alert(event.data); &#125;); //window.frames[0].postMessage(&quot;b data&quot;, &quot;http://www.b.com/b.html&quot;); //调用postMessage方法的window对象是指要接收消息的那一个window对象&#125; b.com/b.html123456window.onload = function() &#123; //window.addEventListener(&quot;message&quot;, function(event) &#123; // alert(event.data); //&#125;); window.parent.postMessage(&quot;a需要的数据&quot;, &quot;http://www.a.com/a.html&quot;);&#125; postMessage是从a窗口发送信息到b窗口，b窗口监听到消息后做出回应； localStorage是在a窗口改变某一个存储值，b窗口监听到了存储值的变化，然后获取该值，进而完成通信的同样的效果。 HTML5 应用缓存在 Html5 中，提供了一种叫 Application Cache 应用程序缓存的技术，通俗解释就是，通过一个文本文件可以告诉浏览器，我这个网页中的资源，哪些本地有就直接用本地，哪些必须要去网络拉取。 其实就是离线资源使用，本地缓存，如果有缓存，就能提升页面访问速度，节省流量，也能减少服务端负载，进而节省带宽费用。 如何实现 HTML5 应用程序缓存？ 创建一个 cache.manifest 文件，并确保文件具有正确的内容 在服务器上设置内容类型 所有的 HTML 文件都指向 cache.manifest cache.manifest1234567891011121314151617CACHE MANIFEST# version1CACHE:index.html404.htmlfavicon.icorobots.txthumans.txtapple-touch-icon.pngcss/main.cssimg/pho-cat.jpgFALLBACK:online.js local.jsNETWORK:* 注意事项： 第一行必须是”CACHE DMANIFEST”文字，以把本文件的作用告知浏览器，即对本地缓存中的资源文件进行具体设置。 在 manifest 文件中，可以加上注释来进行一些必要说明或解释。注释行以”#”文字开头。 在 CACHE 之后的部分为列出我们需要缓存的文件。 在 FALLBACK 之后的部分每一行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时使用的备用资源文件。 在 NETWORK 之后可以指定在线白名单，即列出我们不希望离线存储的文件，因为通常它们的内容需要互联网访问才有意义。 另外，在此部分我们可以使用快捷方式：通配符* 这将告诉浏览器，应用服务器中获取没有在显示部分中提到的任何文件或 URL。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F08%2F25%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML 基础 HTML 文档元信息 &lt;meta/&gt; 的重要性&lt;meta/&gt; 可分为两大部分：[ http-equiv ] 和 [ name ] 变量 [ http-equiv ]http-equiv相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助浏览器正确地显示网页内容。 值 描述 content-type 设定页面使用的字符集&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html; charset=&quot;utf-8&quot;&gt;UTF-8：世界通用的语言编码GB2312：编码是简体中文ISO-8859-1：编码是英文 X-UA-Compatible IE8的专用标记，用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式，以此来解决部分兼容问题&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot;&gt;以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8/9都会以IE7引擎来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot;&gt;以上代码告诉IE浏览器，IE8/9都会以IE8引擎来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame expires 设定网页的过期时间&lt;meta http-equiv=&quot;expires&quot;content=&quot;Fri,12Jan200118:18:18GMT&quot;&gt;必须使用GMT的时间格式 refresh 自动刷新并指向新页面&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2;URL=https://www.baidu.com&quot;&gt; set-cookie 如果网页过期，那么自动删除本地cookie&lt;meta http-equiv=&quot;Set-Cookie&quot;content=&quot;cookie value=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt;必须使用GMT的时间格式 windows-target 强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;&gt; cache-control 缓存机制&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;Public：指示响应可被任何缓存区缓存。Private：指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。no-cache：指示请求或响应消息不能缓存。no-store：用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。max-age：指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。min-fresh：指示客户机可以接收响应时间小于当前时间加上指定时间的响应。max-stale：指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 [ name ]name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 值 描述 author 标注网页的作者&lt;meta name=&quot;author&quot; content=&quot;value&quot; /&gt; keywords 页面关键词，用于被搜索引擎收录&lt;meta name=&quot;keywords&quot; content=&quot;value1,value2&quot;&gt; description 页面描述，用于搜索引擎收录&lt;meta name=&quot;description&quot; content=&quot;value&quot;&gt; viewport 用于控制页面缩放&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt; renderer 指定双核浏览器默认以何种方式渲染页面&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;webkit：默认webkit内核ie-comp：默认IE兼容模式ie-stand：默认IE标准模式 generator 说明网站的采用的什么软件制作&lt;meta name=&quot;generator&quot; content=&quot;Microsoft&quot;/&gt; revised 网页文档的修改时间&lt;meta name=&quot;revised&quot; content=&quot;WebName, MM/DD/YYYY&quot;/&gt; robots 用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引&lt;meta name=&quot;robots&quot; content=&quot;all&quot;/&gt;all：文件将被检索，且页面上的链接可以被查询none：文件将不被检索，且页面上的链接不可以被查询index：文件将被检索noindex：页面上的链接可以被查询follow：文件将不被检索，但页面上的链接可以被查询nofollow：文件将不被检索，页面上的链接可以被查询 copyright 网站版权信息&lt;meta name=&quot;copyright&quot; content=&quot;本页版权XXX所有。All Rights Reserved&quot; /&gt; HTML 块级元素 &amp; 内联元素 &amp; 置换元素 类型 描述 块级元素 div、header、nav、article、aside、section、footer、p、h1~h6、ul、ol… 块级元素特点： 独占一行 行高和边距可变 可以容纳块级元素和内联元素 display: block / table; 类型 描述 内联元素 span、img、label、input、button…. 内联元素特点： 与其他元素在同一行上 行高和边距不可变 只可容纳内联元素 display: inline / inline-block; 置换元素一个内容不受 CSS 视觉格式化模型控制，CSS 渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，浏览器会根据置换元素的标签和属性，来决定元素的具体显示内容。 置换元素与一般行内元素的区别在于：置换元素拥有内在尺寸，可以设置宽高，其性质等同于设置了 display: inline-block; 的元素。 常见的有 &lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;等 HTML 语义化 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 标签 语义 &lt;article&gt; 定义文档内的文章 &lt;aside&gt; 定义页面内容之外的内容 &lt;details&gt; 定义用户可查看或隐藏的额外细节 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题 &lt;figure&gt; 定义自包含内容，比如图示、图表、照片、代码清单等等 &lt;footer&gt; 定义文档或节的页脚 &lt;header&gt; 定义文档或节的页眉 &lt;main&gt; 定义文档的主内容 &lt;mark&gt; 定义重要或强调的内容 &lt;nav&gt; 定义文档内的导航链接 &lt;section&gt; 定义文档中的节 &lt;summary&gt; 定义 &lt;details&gt;元素的可见标题 &lt;time&gt; 定义日期/时间 例如下面这段代码:12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--页眉--&gt; &lt;header&gt;&lt;/header&gt; &lt;!--导航--&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!--主内容--&gt; &lt;main&gt; &lt;!--文章--&gt; &lt;article&gt; &lt;!--节--&gt; &lt;section&gt; &lt;!-- 表单 --&gt; &lt;form&gt; &lt;!-- 围绕表单的边框 --&gt; &lt;fieldset&gt; &lt;!-- fieldset 元素的标题 --&gt; &lt;legend&gt;Personalia:&lt;/legend&gt; &lt;!-- input标注 --&gt; &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt; &lt;!-- 重置按钮 --&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/fieldset&gt;&gt; &lt;/form&gt; &lt;/section&gt; &lt;/article&gt; &lt;!-- 页面内容之外的内容 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;!--页脚--&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; Canvas 图形绘制1234&lt;script&gt; var c = document.getElementById(&apos;myCanvas&apos;); var ctx = c.getContext(&apos;2d&apos;)&lt;/script&gt; 绘制基本图形 图形 方法 直线 moveTo(x,y) lineTo(x,y) 闭环 closePath() 矩形 rect(x,y,w,h) 曲线 二次贝塞尔曲线：context.quadraticCurveTo(cpx,cpy,x,y)三次方贝塞尔曲线：bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y) 圆形 arc(x,y,r,sAngle,eAngle,counterclockwise) 线性渐变 createLinearGradient(x0,y0,x1,y1) addColorStop(stop,color) 平移图形 translate(x,y) 缩放效果 scale(scalewidth,scaleheight) 旋转效果 rotate(angle) 颜色 &amp; 阴影 属性 描述 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 图像的应用复制图像：drawImage(img,sx,sy,swidth,sheight,x,y,width,height)裁剪图像：clip()平铺图像：createPattern(image,”repeat|repeat-x|repeat-y|no-repeat”) 属性 描述 img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度。（伸展或缩小图像） height 可选。要使用的图像的高度。（伸展或缩小图像） 文字的应用“被填充的”文本：fillText(text,x,y,maxWidth)绘制文本（无填充）：strokeText(text,x,y,maxWidth) HTML5 代码规范 请使用正确的文档类型&lt;!DOCTYPE html&gt; 使用小写元素名混合大小写名称并不好开发者习惯使用小写名（比如在 XHTML 中）小写更起来更纯净小写更易书写 关闭所有HTML元素 关闭空的HTML元素 使用小写属性名混合属性名并不好开发者习惯于使用小写属性名（比如在 XHTML 中）小写属性名看情况更纯净小写属性名更易书写 属性值加引号如果属性值包含值，则必须使用引号混合样式绝对不好加引号的值更易阅读 必要的属性请始终对图像使用 alt 属性。当图像无法显示时该属性很重要。 空格和等号，精简空格更易阅读。 避免长代码行(80个字符以内) 空格和缩进，请勿毫无理由地增加空行。 不能省略&lt;html&gt;&lt;/html&gt;和&lt;body&gt;&lt;/body&gt;、&lt;head&gt;&lt;/head&gt; 元数据，文档中对语言和字符编码的定义越早越好。 HTML注释短注释应该在单行中书写，并在 &lt;!-- 之后增加一个空格，在 &lt;!--之前增加一个空格 样式表开括号与选择器位于同一行在开括号之前用一个空格使用两个字符的缩进在每个属性与其值之间使用冒号加一个空格在每个逗号或分号之后使用空格在每个属性值对（包括最后一个）之后使用分号只在值包含空格时使用引号来包围值把闭括号放在新的一行，之前不用空格避免每行超过 80 个字符注释：在逗号或分号之后添加空格，是所有书写类型的通用规则。 在HTML中加载JavaScript 通过JavaScript访问HTML元素 使用小写文件名 文件扩展名.html]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
