<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML5 Web Worker用法]]></title>
    <url>%2F2019%2F08%2F26%2FHTML5-Web-Worker%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Web Worker的用法简单来说，其实就是在Javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后再回到主线程上，在这个过程中并不影响主线程的执行过程。 判断当前浏览器是否支持web worker1234567891011121314151617if (typeof (Worker) != &quot;undefined&quot;) &#123; //浏览器支持web worker if (typeof (w) == &quot;undefined&quot;) &#123; //w是未定义的,还没有开始计数 w = new Worker(&quot;webworker.js&quot;); //创建一个Worker对象,利用Worker的构造函数 &#125; //onmessage是Worker对象的properties w.onmessage = function (event) &#123; //事件处理函数,用来处理后端的web worker传递过来的消息 // do something &#125;;&#125; else &#123; // 浏览器不支持web worker // do something&#125; API 创建新的Worker var worker = new Worker(&quot;worker.js&quot;) 传递参数 worker.postMessage() 接收消息 worker.onMessage = function(msg){} 异常处理 worker.onerror = function(err){} 结束worker worker.terminate() 载入工具类函数 importScripts() 作用域创建一个新的worker时，该代码会运行在一个全新的javascript的环境中（WorkerGlobalScope）运行,是完全和创建worker的脚本隔离，这时我们可以把创建新worker的脚本叫做主线程，而被创建的新的worker叫做子线程。 WorkerGlobalScope是worker的全局对象，所以它包含所有核心javascript全局对象拥有的属性如JSON等，window的一些属性，也拥有类似于XMLHttpRequest()等。 但是我们所开启的新的worker也就是子线程，并不支持操作页面的DOM。 共享线程（SharedWorker）共享线程是为了避免线程的重复创建和销毁过程，降低了系统性能的消耗，共享线程SharedWorker可以同时有多个页面的线程链接。 var worker = new SharedWorker(&quot;sharedworker.js&quot;); 共享线程也使用了message事件监听线程消息，但使用SharedWorker对象的port属性与线程通信如下: worker.port.onmessage = function(msg){}; 同时我们也可以使用SharedWorker对象的port属性向共享线程发送消息如下： worker.port.postMessage(msg); 应用 可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信 可以在worker中通过importScripts(url)加载另外的脚本文件 可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval() 可以使用XMLHttpRequest来发送请求 可以访问navigator的部分属性 注意事项 不能跨域加载JS worker内代码不能访问DOM 各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行 不是每个浏览器都支持这个新特性]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5本地存储]]></title>
    <url>%2F2019%2F08%2F26%2FHTML5%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[localStroage &amp; sessionStroageHTML5 提供了本地存储对象 window.localStroage - 存储没有截止日期的数据（localStorage 生命周期是永久，除非主动清除 localStorage 信息，否则这些信息将永远存在。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。） window.sessionStroage - 针对一个 Session 的数据存储（仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。） 两者区别就是一个作为临时保存，一个长期保存。 之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 localStroage123456789// 1、保存数据到本地// 第一个参数是保存的变量名，第二个是赋给变量的值localStorage.setItem(&apos;Author&apos;, &apos;local&apos;);// 2、从本地存储获取数据localStorage.getItem(&apos;Author&apos;);// 3、从本地存储删除某个已保存的数据localStorage.removeItem(&apos;Author&apos;);// 4、清除所有保存的数据localStorage.clear(); 应用场景实际工作中对 localstorage 的使用一般有以下需求： 缓存一般信息，如搜索页的出发城市，达到城市，非实时定位信息 缓存城市列表数据，这个数据往往比较大 每条缓存信息需要可追踪，比如服务器通知城市数据更新，这个时候在最近一次访问的时候要自动设置过期 每条信息具有过期日期状态，在过期外时间需要由服务器拉取数据 ………… sessionStroage123456789// 1、保存数据到本地// 第一个参数是保存的变量名，第二个是赋给变量的值sessionStorage.setItem(&apos;Author&apos;, &apos;session&apos;);// 2、从本地存储获取数据sessionStorage.getItem(&apos;Author&apos;);// 3、从本地存储删除某个已保存的数据sessionStorage.removeItem(&apos;Author&apos;);// 4、清除所有保存的数据sessionStorage.clear(); 其他隐私模式下可以采用 window.name 模拟 sessionStorage 的方式处理，因为 window.name 是可做保存的，这个也是其解决跨域方案的原因。 postMessage 发送：调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象 otherWindow.postMessage(message, targetOrigin, [transfer]); 监听：message 事件 window.addEventListener( &quot;message&quot;, function(event) {alert(event.data);}) 假设在 a.html 里嵌套个&lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;,在这两个页面里互相通信 a.com/a.html1234567window.onload = function() &#123; window.addEventListener(&quot;message&quot;, function(event) &#123; alert(event.data); &#125;); //window.frames[0].postMessage(&quot;b data&quot;, &quot;http://www.b.com/b.html&quot;); //调用postMessage方法的window对象是指要接收消息的那一个window对象&#125; b.com/b.html123456window.onload = function() &#123; //window.addEventListener(&quot;message&quot;, function(event) &#123; // alert(event.data); //&#125;); window.parent.postMessage(&quot;a需要的数据&quot;, &quot;http://www.a.com/a.html&quot;);&#125; postMessage是从a窗口发送信息到b窗口，b窗口监听到消息后做出回应； localStorage是在a窗口改变某一个存储值，b窗口监听到了存储值的变化，然后获取该值，进而完成通信的同样的效果。 HTML5 应用缓存在 Html5 中，提供了一种叫 Application Cache 应用程序缓存的技术，通俗解释就是，通过一个文本文件可以告诉浏览器，我这个网页中的资源，哪些本地有就直接用本地，哪些必须要去网络拉取。 其实就是离线资源使用，本地缓存，如果有缓存，就能提升页面访问速度，节省流量，也能减少服务端负载，进而节省带宽费用。 如何实现 HTML5 应用程序缓存？ 创建一个 cache.manifest 文件，并确保文件具有正确的内容 在服务器上设置内容类型 所有的 HTML 文件都指向 cache.manifest cache.manifest1234567891011121314151617CACHE MANIFEST# version1CACHE:index.html404.htmlfavicon.icorobots.txthumans.txtapple-touch-icon.pngcss/main.cssimg/pho-cat.jpgFALLBACK:online.js local.jsNETWORK:* 注意事项： 第一行必须是”CACHE DMANIFEST”文字，以把本文件的作用告知浏览器，即对本地缓存中的资源文件进行具体设置。 在 manifest 文件中，可以加上注释来进行一些必要说明或解释。注释行以”#”文字开头。 在 CACHE 之后的部分为列出我们需要缓存的文件。 在 FALLBACK 之后的部分每一行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时使用的备用资源文件。 在 NETWORK 之后可以指定在线白名单，即列出我们不希望离线存储的文件，因为通常它们的内容需要互联网访问才有意义。 另外，在此部分我们可以使用快捷方式：通配符* 这将告诉浏览器，应用服务器中获取没有在显示部分中提到的任何文件或 URL。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础语法]]></title>
    <url>%2F2019%2F08%2F25%2FHTML%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[HTML 基础 HTML 文档元信息 &lt;meta/&gt; 的重要性&lt;meta/&gt; 可分为两大部分：[ http-equiv ] 和 [ name ] 变量 [ http-equiv ]http-equiv相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助浏览器正确地显示网页内容。 值 描述 content-type 设定页面使用的字符集&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html; charset=&quot;utf-8&quot;&gt;UTF-8：世界通用的语言编码GB2312：编码是简体中文ISO-8859-1：编码是英文 X-UA-Compatible IE8的专用标记，用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式，以此来解决部分兼容问题&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot;&gt;以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8/9都会以IE7引擎来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot;&gt;以上代码告诉IE浏览器，IE8/9都会以IE8引擎来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame expires 设定网页的过期时间&lt;meta http-equiv=&quot;expires&quot;content=&quot;Fri,12Jan200118:18:18GMT&quot;&gt;必须使用GMT的时间格式 refresh 自动刷新并指向新页面&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2;URL=https://www.baidu.com&quot;&gt; set-cookie 如果网页过期，那么自动删除本地cookie&lt;meta http-equiv=&quot;Set-Cookie&quot;content=&quot;cookie value=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt;必须使用GMT的时间格式 windows-target 强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;&gt; cache-control 缓存机制&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;Public：指示响应可被任何缓存区缓存。Private：指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。no-cache：指示请求或响应消息不能缓存。no-store：用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。max-age：指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。min-fresh：指示客户机可以接收响应时间小于当前时间加上指定时间的响应。max-stale：指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 [ name ]name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 值 描述 author 标注网页的作者&lt;meta name=&quot;author&quot; content=&quot;value&quot; /&gt; keywords 页面关键词，用于被搜索引擎收录&lt;meta name=&quot;keywords&quot; content=&quot;value1,value2&quot;&gt; description 页面描述，用于搜索引擎收录&lt;meta name=&quot;description&quot; content=&quot;value&quot;&gt; viewport 用于控制页面缩放&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt; renderer 指定双核浏览器默认以何种方式渲染页面&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;webkit：默认webkit内核ie-comp：默认IE兼容模式ie-stand：默认IE标准模式 generator 说明网站的采用的什么软件制作&lt;meta name=&quot;generator&quot; content=&quot;Microsoft&quot;/&gt; revised 网页文档的修改时间&lt;meta name=&quot;revised&quot; content=&quot;WebName, MM/DD/YYYY&quot;/&gt; robots 用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引&lt;meta name=&quot;robots&quot; content=&quot;all&quot;/&gt;all：文件将被检索，且页面上的链接可以被查询none：文件将不被检索，且页面上的链接不可以被查询index：文件将被检索noindex：页面上的链接可以被查询follow：文件将不被检索，但页面上的链接可以被查询nofollow：文件将不被检索，页面上的链接可以被查询 copyright 网站版权信息&lt;meta name=&quot;copyright&quot; content=&quot;本页版权XXX所有。All Rights Reserved&quot; /&gt; HTML 块级元素 &amp; 内联元素 &amp; 置换元素 类型 描述 块级元素 div、header、nav、article、aside、section、footer、p、h1~h6、ul、ol… 块级元素特点： 独占一行 行高和边距可变 可以容纳块级元素和内联元素 display: block / table; 类型 描述 内联元素 span、img、label、input、button…. 内联元素特点： 与其他元素在同一行上 行高和边距不可变 只可容纳内联元素 display: inline / inline-block; 置换元素一个内容不受 CSS 视觉格式化模型控制，CSS 渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，浏览器会根据置换元素的标签和属性，来决定元素的具体显示内容。 置换元素与一般行内元素的区别在于：置换元素拥有内在尺寸，可以设置宽高，其性质等同于设置了 display: inline-block; 的元素。 常见的有 &lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;等 HTML 语义化 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 标签 语义 &lt;article&gt; 定义文档内的文章 &lt;aside&gt; 定义页面内容之外的内容 &lt;details&gt; 定义用户可查看或隐藏的额外细节 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题 &lt;figure&gt; 定义自包含内容，比如图示、图表、照片、代码清单等等 &lt;footer&gt; 定义文档或节的页脚 &lt;header&gt; 定义文档或节的页眉 &lt;main&gt; 定义文档的主内容 &lt;mark&gt; 定义重要或强调的内容 &lt;nav&gt; 定义文档内的导航链接 &lt;section&gt; 定义文档中的节 &lt;summary&gt; 定义 &lt;details&gt;元素的可见标题 &lt;time&gt; 定义日期/时间 例如下面这段代码:12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--页眉--&gt; &lt;header&gt;&lt;/header&gt; &lt;!--导航--&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!--主内容--&gt; &lt;main&gt; &lt;!--文章--&gt; &lt;article&gt; &lt;!--节--&gt; &lt;section&gt; &lt;!-- 表单 --&gt; &lt;form&gt; &lt;!-- 围绕表单的边框 --&gt; &lt;fieldset&gt; &lt;!-- fieldset 元素的标题 --&gt; &lt;legend&gt;Personalia:&lt;/legend&gt; &lt;!-- input标注 --&gt; &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt; &lt;!-- 重置按钮 --&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/fieldset&gt;&gt; &lt;/form&gt; &lt;/section&gt; &lt;/article&gt; &lt;!-- 页面内容之外的内容 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;!--页脚--&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; Canvas 图形绘制1234&lt;script&gt; var c = document.getElementById(&apos;myCanvas&apos;); var ctx = c.getContext(&apos;2d&apos;)&lt;/script&gt; 绘制基本图形 图形 方法 直线 moveTo(x,y) lineTo(x,y) 闭环 closePath() 矩形 rect(x,y,w,h) 曲线 二次贝塞尔曲线：context.quadraticCurveTo(cpx,cpy,x,y)三次方贝塞尔曲线：bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y) 圆形 arc(x,y,r,sAngle,eAngle,counterclockwise) 线性渐变 createLinearGradient(x0,y0,x1,y1) addColorStop(stop,color) 平移图形 translate(x,y) 缩放效果 scale(scalewidth,scaleheight) 旋转效果 rotate(angle) 颜色 &amp; 阴影 属性 描述 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 图像的应用复制图像：drawImage(img,sx,sy,swidth,sheight,x,y,width,height)裁剪图像：clip()平铺图像：createPattern(image,”repeat|repeat-x|repeat-y|no-repeat”) 属性 描述 img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度。（伸展或缩小图像） height 可选。要使用的图像的高度。（伸展或缩小图像） 文字的应用“被填充的”文本：fillText(text,x,y,maxWidth)绘制文本（无填充）：strokeText(text,x,y,maxWidth) HTML5 代码规范 请使用正确的文档类型&lt;!DOCTYPE html&gt; 使用小写元素名混合大小写名称并不好开发者习惯使用小写名（比如在 XHTML 中）小写更起来更纯净小写更易书写 关闭所有HTML元素 关闭空的HTML元素 使用小写属性名混合属性名并不好开发者习惯于使用小写属性名（比如在 XHTML 中）小写属性名看情况更纯净小写属性名更易书写 属性值加引号如果属性值包含值，则必须使用引号混合样式绝对不好加引号的值更易阅读 必要的属性请始终对图像使用 alt 属性。当图像无法显示时该属性很重要。 空格和等号，精简空格更易阅读。 避免长代码行(80个字符以内) 空格和缩进，请勿毫无理由地增加空行。 不能省略&lt;html&gt;&lt;/html&gt;和&lt;body&gt;&lt;/body&gt;、&lt;head&gt;&lt;/head&gt; 元数据，文档中对语言和字符编码的定义越早越好。 HTML注释短注释应该在单行中书写，并在 &lt;!-- 之后增加一个空格，在 &lt;!--之前增加一个空格 样式表开括号与选择器位于同一行在开括号之前用一个空格使用两个字符的缩进在每个属性与其值之间使用冒号加一个空格在每个逗号或分号之后使用空格在每个属性值对（包括最后一个）之后使用分号只在值包含空格时使用引号来包围值把闭括号放在新的一行，之前不用空格避免每行超过 80 个字符注释：在逗号或分号之后添加空格，是所有书写类型的通用规则。 在HTML中加载JavaScript 通过JavaScript访问HTML元素 使用小写文件名 文件扩展名.html]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
