<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ECMAScript]]></title>
    <url>%2F2019%2F09%2F18%2FECMAScript%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;ECMAScript&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- ECMAScript语法 --&gt; 1.变量是弱类型的 2.每行结尾的分号可有可无 3.注释与 Java、C 和 PHP 语言的注释相同 4.括号表示代码块 &lt;!-- ECMAScript 变量 --&gt; 1.声明变量 2.命名变量 * 第一个字符必须是字母、下划线（_）或美元符号（$） * 余下的字符可以是下划线、美元符号或任何字母或数字字符 3.著名的变量命名规则 * Camel 标记法：首字母是小写的，接下来的字母都以大写字符开头。 * Pascal 标记法：首字母是大写的，接下来的字母都以大写字符开头。 * 匈牙利类型标记法：在以 Pascal 标记法命名的变量前附加一个小写字母（或小写字母序列），说明该变量的类型。 4.变量声明不是必须的 &lt;!-- 关键字 --&gt; 1.ECMAScript 关键字：关键字是保留的，不能用作变量名或函数名。 &lt;!-- 保留字 --&gt; 1.ECMAScript 保留字：保留字在某种意思上是为将来的关键字而保留的单词。因此保留字不能被用作变量名或函数名。 &lt;!-- ECMAScript 原始值和引用值 --&gt; 1.变量可以存在两种类型的值，即原始值和引用值。 * 原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。 * 引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。 2.原始类型 * ECMAScript有5种原始类型（primitive type），即Undefined、Null、Boolean、Number和String。 &lt;!-- ECMAScript 原始类型 --&gt; 1.typeof运算符，返回值： * undefined - 如果变量是Undefined类型的 * boolean - 如果变量是Boolean类型的 * number - 如果变量是Number类型的 * string - 如果变量是String类型的 * object - 如果变量是一种引用类型或Null类型的 &lt;!-- ECMAScript 引用类型 --&gt; 1.引用类型 * 引用类型通常叫做类（class），也就是说，遇到引用值，所处理的就是对象。 2.Object 对象 * Object 对象具有下列属性： - constructor，对创建对象的函数的引用（指针）。对于Object对象，该指针指向原始的Object()函数。 - Prototype，对该对象的对象原型的引用。对于所有的对象，它默认返回Object对象的一个实例。 * Object 对象还具有几个方法： - hasOwnProperty(property)，判断对象是否有某个特定的属性。必须用字符串指定该属性。 - IsPrototypeOf(object)，判断该对象是否为另一个对象的原型。 - PropertyIsEnumerable，判断给定的属性是否可以用for...in语句进行枚举。 - ToString()，返回对象的原始字符串表示。 - ValueOf()，返回最适合该对象的原始值。对于许多对象，该方法返回的值都与ToString()的返回值相同。 3.Boolean 对象 * Boolean对象是Boolean原始类型的引用类型。 4.Number 对象 * Number对象是Number原始类型的引用类型。 - toFixed() 方法，返回的是具有指定位数小数的数字的字符串表示。例如：alert(oNumberObject.toFixed(2)); //输出 &quot;68.00&quot; - toExponential() 方法，返回的是用科学计数法表示的数字的字符串形式。例如：alert(oNumberObject.toExponential(1)); //输出 &quot;6.8e+1&quot; - toPrecision() 方法，根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如：alert(oNumberObject.toPrecision(1)); //输出 &quot;7e+1&quot; 5.String 对象 * String对象是String原始类型的对象表示法 - valueOf()方法，返回String类型的原始值。 - toString()方法，返回String类型的原始值。例如：alert(oStringObject.valueOf() == oStringObject.toString()); //输出 &quot;true&quot; - charAt()方法，返回字符串中的单个字符。例如：alert(oStringObject.charAt(1)); //输出 &quot;e&quot; - charCodeAt()方法，返回字符串中的字符代码。例如：alert(oStringObject.charCodeAt(1)); //输出 &quot;101&quot; - concat() 方法，用于把一个或多个字符串连接到String对象的原始值上。该方法返回的是String原始值。例如：var sResult = oStringObject.concat(&quot;world&quot;); alert(sResult); //输出 &quot;hello world&quot; - indexOf()方法，从字符串的开头（位置0）开始检索字符串。例如：alert(oStringObject.indexOf(&quot;o&quot;)); 输出 &quot;4&quot; - lastIndexOf()方法，从字符串的结尾开始检索子串。例如：alert(oStringObject.lastIndexOf(&quot;o&quot;)); 输出 &quot;7&quot; - localeCompare()方法，对字符串进行排序。该方法有一个参数 - 要进行比较的字符串，返回的是下列三个值之一： 1). 如果String对象按照字母顺序排在参数中的字符串之前，返回负数。例如：alert(oStringObject.localeCompare(&quot;zoo&quot;)); //输出 &quot;-1&quot; 2). 如果String对象等于参数中的字符串，返回0。例如：alert(oStringObject.localeCompare(&quot;yellow&quot;)); //输出 &quot;0&quot; 3). 如果String对象按照字母顺序排在参数中的字符串之后，返回正数。例如：alert(oStringObject.localeCompare(&quot;brick&quot;)); //输出 &quot;1&quot; - slice()、substring()方法，返回要处理的字符串的子串，接受一个或两个参数。 - toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()方法，涉及大小写转换。 例如： var oStringObject = new String(&quot;Hello World&quot;); alert(oStringObject.toLocaleUpperCase()); //输出 &quot;HELLO WORLD&quot; alert(oStringObject.toUpperCase()); //输出 &quot;HELLO WORLD&quot; alert(oStringObject.toLocaleLowerCase()); //输出 &quot;hello world&quot; alert(oStringObject.toLowerCase()); //输出 &quot;hello world&quot; * String对象属性： - length 属性，返回字符串中的字符个数。例如：alert(oStringObject.length); //输出 &quot;11&quot; * instanceof 运算符，instanceof方法要求开发者明确地确认对象为某特定类型。例如：alert(oStringObject instanceof String); //输出 &quot;true&quot; &lt;!-- ECMAScript 位运算符 --&gt; * ECMAScript整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。 * 位运算 NOT：位运算NOT由否定号（~）表示，它是ECMAScript中为数不多的与二进制算术有关的运算符之一。 * 位运算 AND：位运算AND由和号（&amp;）表示，直接对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后用下面的规则对同一位置上的两个数位进行AND运算。 * 位运算 OR：位运算OR由符号（|）表示，也是直接对数字的二进制形式进行运算。 * 位运算 XOR：位运算XOR由符号（^）表示，当然，也是直接对二进制形式进行运算。 * 左移运算：左移运算由两个小于号表示（&lt;&lt;）。它把数字中的所有数位向左移动指定的数量。 * 有符号右移运算：有符号右移运算符由两个大于号表示（&gt;&gt;）。它把32位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。 * 无符号右移运算：无符号右移运算符由三个大于号（&gt;&gt;&gt;）表示，它将无符号32位数的所有数位整体右移。对于正数，无符号右移运算的结果与有符号右移运算一样。 &lt;!-- ECMAScript Boolean 运算符 --&gt; * 逻辑 NOT 运算符：由感叹号（!）表示。与逻辑OR和逻辑AND运算符不同的是，逻辑NOT运算符返回的一定是Boolean值。 * 逻辑 AND 运算符：在ECMAScript中，逻辑AND运算符用双和号（&amp;&amp;）表示。 * 逻辑 OR 运算符：ECMAScript中的逻辑OR运算符与Java中的相同，都由双竖线（||）表示。 &lt;!-- ECMAScript 乘性运算符 --&gt; * 乘法运算符，乘法运算符由星号（*）表示，用于两数相乘。 * 除法运算符，除法运算符由斜杠（/）表示，用第二个运算数除第一个运算数。 * 取模运算符，除法（余数）运算符由百分号（%）表示。 &lt;!-- ECMAScript 加性运算符 --&gt; * 加法运算符，加法运算符由加号（+）表示。 * 减法运算符，减法运算符（-），也是一个常用的运算符。 &lt;!-- ECMAScript 关系运算符 --&gt; * 关系运算符小于、大于、小于等于和大于等于执行的是两个数的比较运算，比较方式与算术比较运算相同。 &lt;!-- ECMAScript 等性运算符 --&gt; * ECMAScript 提供了两套等性运算符：等号和非等号用于处理原始值，全等号和非全等号用于处理对象。 1.等号和非等号 * 等号由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。非等号由感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回 true。 2.全等号和非全等号 * 等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。 - 全等号由三个等号表示（===），只有在无需类型转换运算数就相等的情况下，才返回 true。 - 非全等号由感叹号加两个等号（!==）表示，只有在无需类型转换运算数不相等的情况下，才返回 true。 &lt;!-- ECMAScript 条件运算符 --&gt; * 条件运算符，例如：variable = boolean_expression ? true_value : false_value。 &lt;!-- ECMAScript 赋值运算符 --&gt; * 赋值运算符：简单的赋值运算符由等号（=）实现，只是把等号右边的值赋予等号左边的变量。 &lt;!-- ECMAScript 逗号运算符 --&gt; * 逗号运算符：用逗号运算符可以在一条语句中执行多个运算。 &lt;!-- ECMAScript if 语句 --&gt; * if 语句是 ECMAScript 中最常用的语句之一。 &lt;!-- ECMAScript 迭代语句 --&gt; * 迭代语句又叫循环语句，声明一组要反复执行的命令，直到满足某些条件为止。循环通常用于迭代数组的值（因此而得名），或者执行重复的算术任务。 1.do-while 语句：do-while 语句是后测试循环，即退出条件在执行循环内部的代码之后计算。 2.while 语句：while 语句是前测试循环。这意味着退出条件是在执行循环内部的代码之前计算的。 3.for 语句：for 语句是前测试循环，而且在进入循环之前，能够初始化变量，并定义循环后要执行的代码。 4.for-in 语句：for-in 语句是严格的迭代语句，用于枚举对象的属性。 &lt;!-- ECMAScript 标签语句 --&gt; * 有标签的语句 &lt;!-- ECMAScript break 和 continue 语句 --&gt; * break 和 continue 语句对循环中的代码执行提供了更严格的控制。 * break 和 continue 语句的不同之处 - break 语句可以立即退出循环，阻止再次反复执行任何代码。 - continue 语句只是退出当前循环，根据控制表达式还允许继续进行下一次循环。 * 与有标签的语句一起使用 - break 语句和 continue 语句都可以与有标签的语句联合使用，返回代码中的特定位置。 - 例如： var iNum = 0; outermost: for (var i=0; i&lt;10; i++) &#123; for (var j=0; j&lt;10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; iNum++; &#125; &#125; alert(iNum); //输出 &quot;55&quot; &lt;!-- ECMAScript with 语句 --&gt; * 有标签的语句：with 语句用于设置代码在特定对象中的作用域。 &lt;!-- ECMAScript switch 语句 --&gt; * switch 语句：switch 语句是 if 语句的兄弟语句。 * 语法： switch (expression) case value: statement; break; case value: statement; break; case value: statement; break; case value: statement; break; ... case value: statement; break; default: statement; * 每个情况（case）都是表示“如果 expression 等于 value，就执行 statement”。 &lt;!-- ECMAScript 函数概述 --&gt; * 什么是函数？函数是由这样的方式进行声明的：关键字 function、函数名、一组参数，以及置于括号中的待执行代码。 * 如何调用函数？函数可以通过其名字加上括号中的参数进行调用，如果有多个参数。 * 函数如何返回值？即使函数确实有值，也不必明确地声明它。该函数只需要使用 return 运算符后跟要返回的值即可。 &lt;!-- ECMAScript arguments 对象 --&gt; * 在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。 * 检测参数个数，还可以用 arguments 对象检测函数的参数个数，引用属性 arguments.length 即可。 * 模拟函数重载，用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载。 &lt;!-- ECMAScript Function 对象（类） --&gt; * ECMAScript 的函数实际上是功能完整的对象。 * Function 对象（类） - Function 对象的 length 属性 - Function 对象的方法，与所有对象共享的 valueOf() 方法和 toString() 方法。 &lt;!-- ECMAScript 闭包（closure） --&gt; * 在ECMAScript中 最容易让人误解的一点是——它支持闭包（closure）。闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。 &lt;!-- ECMAScript 面向对象技术 --&gt; * 一种面向对象语言需要向开发者提供四种基本能力： 封装 - 把相关的信息（无论数据或方法）存储在对象中的能力 聚集 - 把一个对象存储在另一个对象内的能力 继承 - 由另一个类（或多个类）得来类的属性和方法的能力 多态 - 编写能以多种方法运行的函数或方法的能力 &lt;!-- ECMAScript 对象应用 --&gt; * 对象的创建和销毁都在 JavaScript 执行过程中发生，理解这种范式的含义对理解整个语言至关重要。 1.声明和实例化 2.对象引用 3.对象废除 4.早绑定和晚绑定 - 早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。 - 晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。 &lt;!-- ECMAScript 对象类型 --&gt; * 在 ECMAScript 中，所有对象并非同等创建的。一般来说，可以创建并使用的对象有三种：本地对象、内置对象和宿主对象。 &lt;!-- ECMAScript 对象作用域 --&gt; * 作用域指的是变量的适用范围。 1.公用、私有和受保护作用域：ECMAScript 只有公用作用域。 2.静态作用域：ECMAScript 没有静态作用域 3.关键字 this：关键字 this 总是指向调用该方法的对象。 &lt;!-- ECMAScript 定义类或对象 --&gt; * 使用预定义对象只是面向对象语言的能力的一部分，它真正强大之处在于能够创建自己专用的类和对象。 1.工厂方式： function createCar() &#123; var oTempCar = new Object; oTempCar.color = &quot;blue&quot;; oTempCar.doors = 4; oTempCar.mpg = 25; oTempCar.showColor = function() &#123; alert(this.color); &#125;; return oTempCar; &#125; var oCar1 = createCar(); var oCar2 = createCar(); 2.构造函数方式： function Car(sColor,iDoors,iMpg) &#123; this.color = sColor; this.doors = iDoors; this.mpg = iMpg; this.showColor = function() &#123; alert(this.color); &#125;; &#125; var oCar1 = new Car(&quot;red&quot;,4,23); var oCar2 = new Car(&quot;blue&quot;,3,25); 3.原型方式： function Car() &#123; &#125; Car.prototype.color = &quot;blue&quot;; Car.prototype.doors = 4; Car.prototype.mpg = 25; Car.prototype.showColor = function() &#123; alert(this.color); &#125;; var oCar1 = new Car(); var oCar2 = new Car(); 4.混合的构造函数/原型方式： function Car(sColor,iDoors,iMpg) &#123; this.color = sColor; this.doors = iDoors; this.mpg = iMpg; this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;); &#125; Car.prototype.showColor = function() &#123; alert(this.color); &#125;; var oCar1 = new Car(&quot;red&quot;,4,23); var oCar2 = new Car(&quot;blue&quot;,3,25); oCar1.drivers.push(&quot;Bill&quot;); alert(oCar1.drivers); //输出 &quot;Mike,John,Bill&quot; alert(oCar2.drivers); //输出 &quot;Mike,John&quot; 5.动态原型方法： class Car &#123; public String color = &quot;blue&quot;; public int doors = 4; public int mpg = 25; public Car(String color, int doors, int mpg) &#123; this.color = color; this.doors = doors; this.mpg = mpg; &#125; public void showColor() &#123; System.out.println(color); &#125; &#125; 6.混合工厂方式： function Car() &#123; var oTempCar = new Object; oTempCar.color = &quot;blue&quot;; oTempCar.doors = 4; oTempCar.mpg = 25; oTempCar.showColor = function() &#123; alert(this.color); &#125;; return oTempCar; &#125; &lt;!-- ECMAScript 修改对象 --&gt; * prototype 属性不仅可以定义构造函数的属性和方法，还可以为本地对象添加属性和方法。 1.通过已有的方法创建新方法 2.重命名已有方法 3.添加与已有方法无关的方法 4.为本地对象添加新方法 5.重定义已有方法 6.极晚绑定（Very Late Binding） &lt;!-- ECMAScript 继承机制实例 --&gt; * 继承机制的实现：要用 ECMAScript 实现继承机制，您可以从要继承的基类入手。所有开发者定义的类都可作为基类。 * 继承的方式，所有的继承细节并非完全由解释程序处理。作为开发者，你有权决定最适用的继承方式： - 对象冒充，构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。例如： function ClassA(sColor) &#123; this.color = sColor; this.sayColor = function () &#123; alert(this.color); &#125;; &#125; function ClassB(sColor) &#123; &#125; - 对象冒充可以实现多重继承，也就是说，一个类可以继承多个超类。例如： function ClassZ() &#123; this.newMethod = ClassX; this.newMethod(); delete this.newMethod; this.newMethod = ClassY; this.newMethod(); delete this.newMethod; &#125; * call() 方法：call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。 - 例如： function sayColor(sPrefix,sSuffix) &#123; alert(sPrefix + this.color + sSuffix); &#125;; var obj = new Object(); obj.color = &quot;blue&quot;; sayColor.call(obj, &quot;The color is &quot;, &quot;a very nice color indeed.&quot;); * apply() 方法：apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。 - 例如： function sayColor(sPrefix,sSuffix) &#123; alert(sPrefix + this.color + sSuffix); &#125;; var obj = new Object(); obj.color = &quot;blue&quot;; sayColor.apply(obj, new Array(&quot;The color is &quot;, &quot;a very nice color indeed.&quot;)); * 原型链（prototype chaining）：继承这种形式在 ECMAScript 中原本是用于原型链的。 - 例如： function ClassA() &#123; &#125; ClassA.prototype.color = &quot;blue&quot;; ClassA.prototype.sayColor = function () &#123; alert(this.color); &#125;; function ClassB() &#123; &#125; ClassB.prototype = new ClassA(); * 混合方式：这种继承方式使用构造函数定义类，并非使用任何原型。 - 例如： function ClassA(sColor) &#123; this.color = sColor; &#125; ClassA.prototype.sayColor = function () &#123; alert(this.color); &#125;; function ClassB(sColor, sName) &#123; ClassA.call(this, sColor); this.name = sName; &#125;; ClassB.prototype = new ClassA(); ClassB.prototype.sayName = function () &#123; alert(this.name); &#125;;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript DOM2和DOM3扩展]]></title>
    <url>%2F2019%2F09%2F17%2FJavaScript-DOM2%E5%92%8CDOM3%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;JavaScript DOM2和DOM3扩展&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/transitions.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 立即执行函数 (function () &#123; // 严格模式 &quot;use strict&quot;; // DOM的变化 // DOM2级和3级的目的在于扩展DOM API，以满足操作XML的所有需求，同事提供更好的错误处理及特性检测能力。从某种意义上来讲，实现这一目的的很大程度意味着对命名空间的支持 // 针对XML命名空间的变化 // 1.Node类型的变化 // 在DOM2级中，Node类型包含下列特定于命名空间的属性： // localName - 不带命名空间前缀的节点名称 // namespaceURI - 命名空间URI或者（在未指定的情况下是）null // prefix - 命名空间前缀或者（在未指定的情况下是）null // DOM3级在此基础上更进一步，又引入了下列与命名空间有关的方法： // isDefaultNamespace(namespace: DOMString) - 在指定的namespaceURI是当前节点的默认命名空间的情况下返回true // lookupNamespaceURI(prefix: DOMString) - 返回给定prefix的命名空间 // lookupPrefix(namespace: DOMString) - 返回给定 namespaceURI的前缀 // 2.Document类型的变化 // DOM2级中的Document类型也发生了变化，包含下列命名空间有关的方法： // createElementNS(namespace: DOMString, qualifiedName: DOMString) - 使用给定的 tagName 创建一个属于命名空间 namespaceURI 的新元素 // createAttributeNS(namespaceURI, attributName) - 使用给定的attributName 创建一个属于命名空间 namespaceURI的新元素 // getElementsByTagNameNS(namespace: DOMString, localName: DOMString) - 返回属于命名空间 namespaceURI 的 tagName 元素的 NodeList // 3.Element类型的变化 // DOM2级核心中有关Element的变化，主要涉及操作特性，新增的方法如下： // getAttributeNS(namespace: DOMString, localName: DOMString) - 取得属于命名空间 namespaceURI 且名为 localName 的特性 // getAttributeNodeNS(namespaceURI, tagName) - 返回属于命名空间 namespaceURI 且名为 localName 的特性 // getElementsByTagNameNS(namespace: DOMString, localName: DOMString) - 返回属于命名空间 namespaceURI 的 tagName 元素的 NodeList // hasAttributeNS(namespace: DOMString, localName: DOMString) - 确定当前元素是否有一个名为 localName 的特性，而且该特性的命名空间是 namespaceURI。 // removeAttributeNS(namespace: DOMString, localName: DOMString) - 删除属于命名空间 namespaceURI 且名为 localName 的特性。 // setAttributeNS(namespace: DOMString, name: DOMString, value: DOMString) - 设置属于命名空间 namespaceURI 且名为 qualifiedName 的特性的值为 value。 // setAttributeNodeNs(attNode) - 设置属于命名空间 namespaceURI的特性节点。 // 4.NamedNodeMap类型的变化 // NamedNodeMap类型也新增了下列与命名空间有关的方法。由于特性是通过NamedNodeMap表示的，因此这些方法多数情况下只针对特性使用。 // getNamedItemNS(namespaceURI, localName) - 取得属于命名空间 namespaceURI 且名为 localName 的项 // removeNamedItemNS(namespaceURI, localName) - 移出属于命名空间 namespaceURI 且名为 localName 的项。 // setNamedItemNS(node) - 添加node，这个节点已经实现指定了命名空间信息。 // 其他方面的变化 // 1.DocumentType 类型的变化 // DocumentType 类型新增了3个属性：publicId、systemId 和 internalSubset。其中，前两个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。 // 2.Document 类型的变化 // Document类型的变化中唯一与命名空间无关的方法是importNode()。这个方法的用途是从一个文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分。需要注意的是，每个节点都有一个ownerDocument属性，表示所属的文档。 // 如果调用appendChild()时传入的节点属于不同的文档（ownerDocument属性的值不一样），则会导致错误。 // 但在调用importNode()时传入不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。 // importNode()方法与Element与cloneNode()方法非常相似，它接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。 // var newNode = document.importNode(oldNode, true) //导入节点机器所有子节点 // document.body.appendChild(newNode) // DOM2级视图模块添加了一个名为defaultView的属性，其中保存着一个指针，指向拥有给定文档的窗口（或框架）。 // var parentWindow = document.defaultView || document.parentWindow; // DOM2级核心为document.implementation对象规定了两个新方法：createDocumentType() 和 createDocument()。前者用于创建一个新的DocumentType节点，接收3个参数：文档类型名称、publicId、systemId。 // createDocumentType()只在创建新文档时有用：创建新文档时需要用到createDocument()方法。这个方法接受3个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型。 // var doctype = document.implementation.createDocumentType(&quot;html&quot;,&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;, &quot;http://www.w3.org/TR/xhtml/DTD/xhtml-strict.dtd&quot;); // var doc = document.implementation.createDocument(&quot;http://www.w3.org/1999/xhtml&quot;,&quot;html&quot;,doctype); // DOM2级HTML模块也为document.implementation新增了一个方法，名叫createHTMLdocument()。这个方法用途是创建一个完整的HTML文档，包括&lt;html&gt;、&lt;head&gt;、&lt;title&gt;和&lt;body&gt;元素。这个方法只接受一个参数，即新创建文档的标题(放在&lt;title&gt;元素中的字符串)，返回新的HTML文档。 // var htmldoc = document.implementation.createHTMLDocument(&quot;New Doc&quot;); // console.log(htmldoc.title); // console.log(typeof htmldoc.body); // 3.Node类型的变化 // Node类型中唯一与命名空间无关的变化，及时添加了isSupported()方法。用于确定当前节点具有什么能力。 // if(document.body.isSupported(&quot;html&quot;, &quot;2.0&quot;))&#123; // 执行只有“DOM2 级HTML”才支持的操作 // &#125; // DOM3级引入了两个辅助比较节点的方法 isSameNode() 和isEqualNode()。这两个方法都接收一个节点参数，并在窜入节点与引用的节点相同或相等时返回true。所谓相同，指的是两个节点引用的是同一个对象。 // var div1 = document.createElement(&apos;div&apos;); // div1.setAttribute(&apos;class&apos;,&apos;box&apos;); // var div2 = document.createElement(&apos;div&apos;); // div2.setAttribute(&apos;class&apos;, &apos;box&apos;); // console.log(div1.isSameNode(div2)); // console.log(div1.isEqualNode(div2)); // console.log(div1.isSameNode(div2)); // DOM3级还针对DOM节点添加额外数据引入了新方法。其中，setUserData() 方法会将数据指定节点，它接受3个参数：要设置的键、实际的数据（可以是任何数据类型）和处理函数。一下代码可以将数据指定给一个节点。 // document.body.setUserData(&quot;name&quot;,&quot;Nicholas&quot;,function()&#123;&#125;); // var value = document.body.getUserData(&quot;name&quot;); // 传入 setUserData()中的处理函数会在带有数据的节点被复制、删除、重命名或引入一个文档时调用，因而你可以实现决定在上述操作发生时如何处理用户数据。处理函数接受5个参数：表示操作类型的数值（1 - 表示复制 2 - 表示导入 3 - 表示删除 4 - 表示重命名）、数据键、数据值、源节点和目标节点。再删除节点时，源节点null；复制节点时，目标节点时null。 // var div = document.createElement(&apos;div&apos;); // div.setUserData(&apos;name&apos;,&apos;Nicholas&apos;,function(operation,key,value,src,dest)&#123; // if(operation === 1)&#123; // dest.setUserData(key,value,function()&#123;&#125;); // &#125; // &#125;); // var newDiv = div.cloneNode(true); // console.log(newDiv.getUserData(&apos;name&apos;)); // 4.框架的变化 // 框架和内嵌框架分别用HTMLFrameElement和HTMLFrameElement表示，它们在DOM2级中都有了一个新属性，名叫contentDocument。这个属性包含一个指针，指向表示框架内容的文档对象。 // var iframe = document.getElementById(&apos;myIframe&apos;); // var iframeDoc = iframe.contentDocument; // 在IE8以前的版本中无效 // IE8之前支持的一个属性contentWindow的属性。改属性返回框架的window对象，而这个window对象又有一个document属性。因此，要向在上述所有浏览器汇总访问内嵌框架的文档对象 // var iframe = document.getElementById(&apos;myIframe&apos;); // var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; // 样式 // 访问元素的样式 // css属性 —— javascript属性 // background-image style.backgroundImage // color style.color // display style.display // font-family style.fontFamily // 1.DOM样式属性和方法 // DOM2级样式规范还未style对象定义了一些属性和方法。 // cssText: 通过它能够访问到style特性中的CSS代码。 // length: 应用给元素的CSS属性的数量 // parentRule: 表示CSS信息CSSRule对象。 // getPropertyCSSValue(propertyName): 返回包含给定属性值的CSSValu对象。 // getProperPriority(propertyName): 如果给定属性使用了!important设置，则返回“important”,否则返回空字符串。 // getPropertyValue(propertyName): 返回给定属性的字符串值。 // item(index): 返回给定位置的CSS属性的名称。 // removeProperty(propertyName): 从样式中删除给定属性。 // setProperty(propertyName,value,priority): 将给定属性设置为相应的值，并加上优化权标志（“important”或者一个空字符串）。 // 2.计算的样式 // DOM2级样式增强了document.defaultView，提供了getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个微元素字符串（例如：“:after”）.如果不需要伪元素信息，第二个参数可以是null。getComputedStyle()方法返回一个CSSStyleDeclaration对象（与style属性的类型相同），其中包含当前元素的所有计算的样式。 // 操作样式表 // CSSStyleSheet类型表示的是样式表，报错通过&lt;link&gt;元素包含的样式表在&lt;sytle&gt;元素中定义的样式表。从StyleSheet接口继承而来的属性如下： // disabled: 表示样式表是否被禁用的布尔值。 // href：如果样式表示通过&lt;link&gt;包含的，则样式表的URL，否则，是NULL。 // media：当前样式表支持的所有媒体类型的集合。 // ownerNode：指向拥有当前样式表的节点的指针。样式表可能在HTML通过&lt;link&gt;或&lt;style/&gt;引入的（在XML中可能是通过处理指令引入的）。如果当前样式表是其他样式表通过@import导入的情况下，这个属性值为null。 // parentStyleSheet：在当前样式表是通过@import导入的情况下，这个属性是一个指向导入他的样式表的指针。 // title：ownerNode中title属性的值。 // type：表示样式表类型的字符串。 // cssRule：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为null。 // deleteRule(index)：删除cssRules集合中指定的位置插入rule字符串。 // insertRule(rule, index)：向cssRules集合中指定的位置插入rule字符串。 // 1.CSS规则 // cssText：返回整条规则对应的文本。 // parentRule：如果当前规则是导入的规则，这个属性应用就是导入规则；否则，这个值为null。 // parentStyleSheet：当前规则所属的样式表。 // selectorText：返回当前规则的选择符文本。 // style：一个CSSStyleDeclaration对象，可以通过它设置或取得规则中特性的样式值。 // type: 表示规则类型的常量值。 // 2.创建规则 // insertRule()方法。这个方法接受两个参数：规则文本和表示在哪里插入规则的索引。 // 3.删除规则 // deleteRule()方法，这个方法接受一个参数：要删除的规则的位置。 // 元素大小 // 1.偏移量 - 包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意：不包括外边距）。有4个属性可以取得元素偏移量： // offsetHeight：元素在垂直方向上占用的空间大小，以像素计。 // offsetWidth：元素在水平方向上占用的空间大小，以像素计。 // offsetLeft：元素左外边框至包含元素的左内边距之间的像素距离。 // offsetRight：元素上外边框至包含元素的上内边框之间的像素距离。 // 2.客户区大小 - 元素内容及其内边距所占据的空间大小。 // clientWidth：元素内容区宽度加上左右边距宽度。 // clientHeight：元素内容区高度加上上下内边距高度。 // 3.滚动大小 - 包含滚动内容的元素大小。 // scrollHeight：在没有滚动条的情况下，元素内容的总高度。 // scrollWidth：在没有滚动条的情况下，元素内容的总宽度。 // scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。 // scrollTop: 被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 // 4.确定元素大小 // getBoundingClientRect()方法。这个方法返回一个矩形对象，包含4个属性：left、top、right和bottom。 // 遍历 // DOM2级遍历和范围模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优化的遍历操作。 // 检测浏览器对DOM2级遍历能力的支持情况 // var supportsTraversale = document.implementation.hasFocus(&quot;Traversal&quot;, &apos;2.0&apos;); // var supportsNodeIterator = (typeof document.createNodeIterator === &quot;function&quot;); // var supportaTreeWalker = (typeof document.createTreeWalker === &quot;function&quot;) // createNodeIterator(root: Node, whatToShow?: unsigned long, filter?: NodeFilter) // 这个方法接受下列4个参数： // root：想要座位搜索起点的树中的节点。 // whatToShow：表示要访问哪些节点的数字代码。 // filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝谋众特定节点的函数。 // entityReferenceExpansion：布尔值，便是是否要扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展。 // whatToShow参数是一个位掩码，通过应用一个或多个过滤器（filter）来确定要访问哪些节点。这个参数与的值以常量形式在NodeFilter类型中定义，如下所示： // NodeFilter.SHOW_All：显示所有类型的节点。 // NodeFilter.SHOW_ELEMENT：显示元素节点。 // NodeFilter.SHOW_ATTRIBUTE：显示特性节点。 // NodeFilter.SHOW_TEXT：显示文本节点。 // NodeFilter.SHOW_CDATA_SECTION：显示CDAT节点。对HTML页面没有用。 // NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没有用。 // NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没有用。 // NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没有用。 // NodeFilter.SHOW_COMMENT：显示注释节点。 // NodeFilter.SHOW_DOCUMENT：显示文档节点。 // NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型的节点。 // NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段的节点。对HTML页面没有用。 // NodeFilter.SHOW_NOTATION：显示符合节点。对HTML页面没有用。 // TreeWalker，是NodeIterator的一个更高级的版本。除了包括nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。 // parentNode()：遍历当前节点的父节点。 // firstChild()：遍历当前节点的第一个子节点。 // lastChild()：遍历当前节点的最后一个子节点。 // nextSibling()：遍历当前节点的下一个同辈节点。 // previousSibling()：遍历当前节点的上一个同辈节点。 // 创建TreeWalker对象要使用document.createTreeWalker(root: Node, whatToShow?: unsigned long, filter?: NodeFilter)方法，这个方法接受4个参数与document.createNodeIterator(root: Node, whatToShow?: unsigned long, filter?: NodeFilter)方法相同： // 作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。 // var div = document.getElementById(&apos;div1&apos;); // var filter = function(node)&#123; // return node.tagName.toLowerCase() === &quot;li&quot; ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; // &#125;; // var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, filter, false); // var node = iterator,nextNode(); // while(node !== null)&#123; // console.log(node.tagName); // 输出标签名 // node = iterator.nextNode(); // &#125; // 范围，DOM2级遍历和范围模块定义了范围接口。 // DOM中的范围 // DOM2级在Document类型中定义了createRange()方法。每个范围由一个Range类型的实例来表示，这个实例拥有很多属性和方法： // startContainer：包含范围起点的节点（即选区中第一个节点的父节点） // startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本节点、注释节点或CDATA节点，那么startOffset就是范围起点之前跳过的字符数量。否则startOffset就是范围中第一个子节点的索引。 // endContainer：包含范围重点的节点（即选区中最后一个节点的父节点） // endOffset：范围在endContainer中终点的偏移量（与startOffset遵循相同的取值规则）。 // commonAncestorContainer：startContainer和endContainer共同的祖先节点在文档树中位置最深的那个。 // setStartBefore(refNode)：将范围的起点设置在refNode之前，因此refNode也就是范围选区中的第一个子节点。同事会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引。 // setStartAfter(refNode)：将范围的起点设置在refNode之后，因此refNode也就不再范围之内了，其下一个同辈节点才是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引加1. // setEndBefore(refNode)：将范围的重点设置在refNode之前，因此refNode也就不再范围之内了，其上一个同辈节点才是范围选区中的最后一个子节点。同时会将endContainer属性设置为refNode.parentNode，将endOffset属性设置为refNode再其父节点的childNodes集合中的索引。 // setEndAfter(refNode)：将范围的重点设置在refNode之后，因此refNode也就是范围选区中的最后一个子节点。同时会将endCOntainer属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNode集合中的索引加1. // 1.用DOM范围实现简单选择 // &lt;!DOCTYPE html&gt; // &lt;html&gt; // &lt;head&gt; // &lt;meta charset=&quot;utf-8&quot;&gt; // &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; // &lt;title&gt;&lt;/title&gt; // &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt; // &lt;/head&gt; // &lt;body&gt; // &lt;p id=&quot;p1&quot;&gt; // &lt;b&gt;Hello&lt;/b&gt; world! // &lt;/p&gt; // &lt;/body&gt; // &lt;/html&gt; // var range1 = document.createRange(); // range2 = document.createRange(); // p1 = document.getElementById(&apos;p1&apos;); // range1.selectNode(p1); // range2.selectNodeContents(p1); // 2.用DOM范围实现复杂选择 // 要创建复杂的范围就得使用setStart()和setEnd()方法。这两个方位都接受两个参数：一个参展节点和一个偏移量。 // 3.操作DOM范围中的内容 // deleteContents()，这个方法能够从文档中删除范围所包含的内容。 // extractContents()，也会从文档中移出范围选区。会返回范围的文档片段。 // cloneContents()，创建范围对象的一个副本，然后在文档的其他地方插入该副本。返回范围中节点的副本。 // 4.插入DOM范围中的内容 // insertNode()可以向范围选区的开始处插入一个节点。 // surroundContents(newParent: Node)，环绕范围插入节点，这个方法接受一个参数，即环绕范围内容的节点。 // 5.折叠DOM范围 // collapse()方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠刀范围的哪一端。 // 6.比较DOM范围 // compareBoundaryPoints(how: unsigned short, sourceRange: Range) 方法来确定这些范围是否有公共的边界（起点或重点）。这个方法接受两个采纳数：表示比较方式的常量值和要比较的范围。 // 7.复制DOM范围 // cloneRange() // 8.清理DOM范围 // 在使用完范围之后，最好是调用detach()方法，以便从创建范围的文档中分离出该范围。 // range1.detach(); // 从文档中分离 // range1 = null; // 解除引用 // IE8及更早版本中的范围 &#125;)() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript DOM扩展]]></title>
    <url>%2F2019%2F09%2F16%2FJavaScript-DOM%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;JavaScript DOM扩展&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/transitions.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot; id=&quot;box&quot; name=&quot;box&quot; title=&quot;box&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;!-- &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;第一个节点&lt;/li&gt; &lt;li&gt;第二个节点&lt;/li&gt; &lt;li&gt;第三个节点&lt;/li&gt; &lt;li&gt;第四个节点&lt;/li&gt; &lt;li&gt;第五个节点&lt;/li&gt; &lt;/ul&gt; --&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 立即执行函数 (function () &#123; // 严格模式 &quot;use strict&quot;; // JavaScript单线程设计的初衷就是为了操作DOM元素 // Node类型 // if (someNode.nodeType === Node.ELEMENT_NODE) &#123; // // 在IE中无效 // console.log(&quot;node is an element&quot;); // if (someNode.nodeType === 1) &#123; // // 适用所有浏览器 // console.log(&quot;node is an element&quot;); // &#125; // &#125; // nodeName的值是元素的标签名 nodeValue的值始终是null // if (someNode.nodeType === 1) &#123; // value = someNode.nodeName; // &#125; // 节点关系 childNodes firstNode lastNode parentNode nextSibling perviousSlibling // var firstChild = someNode.childNodes[0]; // var secondChild = someNode.childNodes.item[1]; // var count = someNode.childNodes.length; // 操作节点 // appendChild() 向childNodes列表的末尾添加一个节点 // insertBefore() 参数：要插入的节点，作为参照的节点。 被插入的节点会变成参照节点前的一个同胞节点previousSlibing，同时方法被返回。如果参照节点为null，则执行结果与appendChild()相同。 // replaceChild() 参数：要插入的节点，要替换的节点。 // removeChild() 参数：要移出的节点 // 其他方法： cloneNode() 用于创建调用这个方法的节点的一个完全相同的副本。 // var list = document.getElementById(&apos;list&apos;); // var clist = list.cloneNode(true); // console.log(clist.childNodes.length) // var clonelist = list.cloneNode(false); // console.log(clonelist.childNodes.length) // document方法 // 对HTML的引用 var html = document.documentElement; console.log(html === document.childNodes[0]); console.log(html === document.firstChild); // 对Body的引用 var body = document.body; // 对&lt;!DOCTYPE&gt;的引用 var doctype = document.doctype; // 设置文档标题 document.title = &apos;标题&apos;; // 取得完整URL console.log(document.URL); // 取得域名 console.log(document.domain); // 取得来源页面的URL console.log(document.referrer); // 查找元素 // document.getElementById(&apos;id&apos;) 通过元素ID获取节点。 var div = document.getElementById(&apos;box&apos;); // document.getElementByName(&apos;name&apos;) 通过元素Name获取节点。 var box = document.getElementsByName(&apos;box&apos;); // document.getElementByTabName(&apos;div&apos;) 通过元素标签获取节点。 var tagDiv = document.getElementsByTagName(&apos;div&apos;); // htmlControl console.log(tagDiv.length); console.log(tagDiv.item(0).className); // document.getElementByTagName(&apos;*&apos;) 返回所有注释的节点 console.log(document.getElementsByTagName(&apos;*&apos;)); // 特殊集合 // document.anchors 包含文档中所有带name特性的a元素 console.log(document.anchors); // document.forms 包含所当中所有form元素 console.log(document.forms); // document.images 包含文档中所有image元素 console.log(document.images); // document.links 包含文档中所有带有href特性的a元素 console.log(document.links); // Dom一致性检测 浏览器支持此给定名称及版本的功能，则返回true var hasXmlDom = document.implementation.hasFeature(&apos;XML&apos;, &apos;1.0&apos;); console.log(hasXmlDom); // 文档写入 document.writeln(&apos;我是无敌的！&apos;); // 会在字符串末尾添加一个换行\n document.write(&apos;我就是超级无敌宇宙赛亚人！&apos;); // 要写入输出流的文本 document.open() // 打开网页的输出流 document.close() // 关闭网页的输出流 // element类型 var dbox = document.getElementById(&apos;box&apos;); // 适用于任何文档 if(dbox.tagName.toLowerCase === &apos;div&apos;)&#123; return true; &#125; // html元素 console.log(dbox.id); console.log(dbox.className); console.log(dbox.title); console.log(dbox.lang); console.log(dbox.dir); // 取得特性 console.log(dbox.getAttribute(&apos;id&apos;)); // 删除特性 console.log(dbox.removeAttribute(&apos;class&apos;)) // 设置特性 console.log(dbox.setAttribute(&apos;class&apos;,&apos;box&apos;)); // attributes 属性 // attributes.getNamedItem(name) 返回nodeName属性等于name的节点 // attributes.removeNamedItem(name) 从列表中移除nodeName属性等于name的节点 // attributes.setNamedItem(node) 向列表中添加节点，以节点的nodeName属性为索引 // attributes.item(pos) 返回位于数字pos位置出的节点 console.log(dbox.attributes.length); // attributes.specified 默认值为false console.log(dbox.attributes.specified); // 创建元素 var div = document.createElement(&apos;div&apos;) document.getElementById(&apos;box&apos;).appendChild(div); // 元素的子节点 for(var i = 0; i &lt; document.childNodes.length; i++)&#123; if(dbox.childNodes[i].nodeType === 1)&#123; return true; &#125; &#125; // Text类型 // appendData(text) 将text添加到节点的末尾 // deleteData(offset, count) 从offset指定位置开始删除count个字符 // instertData(offset, text) 在offset指定的位置插入text // replaceData(offset, count, text) 用text替换从offset指定的位置开始到offset+count为止处的文本 // splitText(offset) 从offset指定的位置将当前文本节点分成两个文本节点 // substringData(offset, count) 提取从offset指定的位置开始到offset+count为止出的字符串 // length属性 // 创建文本节点 document.createTextNode(&apos;文本节点&apos;) // 规范化文本节点 // normalize() // 分割文本节点 // splitText(offset: unsigned long) // Comment类型 CDATASection类型 // comment类型、CDATASection类型与text类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法。 // DocumentType类型 console.log(document.doctype) // DocumentFragment类型 // document fragment 是一种轻量级文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。 // 创建文档片段 document.createDocumentFragment() // Attr类型 // Attr对象有三个属性：name, value, specified // Dom操作技术 // 动态脚本 var js = document.createElement(&apos;script&apos;); js.type = &apos;text/javascript&apos;; document.body.appendChild(js); // 动态样式 function loadStyle(url)&#123; var link = document.createElement(&apos;link&apos;); link.rel = &apos;stylesheet&apos;; link.type = &apos;text/css&apos;; link.href = url; var head = document.getElementsByTagName(&apos;head&apos;)[0]; head.appendChild(link); &#125; loadStyle(&quot;style.css&quot;); // 操作表格 // &lt;table&gt; 的属性和方法 // caption 保存着对&lt;caption&gt;元素的指针 // tBodies 是一个&lt;tbody&gt;元素的HTMLCollection // tFoot 保存着对&lt;tfoot&gt;元素的指针 // tHead 保存着对&lt;thead&gt;元素的指针 // rows 是一个表格所有行的HTMLCollection // createTHead() 创建&lt;thead&gt;元素，将其放到表格中，返回引用 // createTFoot() 创建&lt;tfoot&gt;元素，将其放到表格中，返回引用 // createCaption() 创建&lt;caption&gt;元素，将其放到表格中，返回引用 // deleteTHead() 删除&lt;thead&gt;元素 // deleteTFoot() 删除&lt;tfoot&gt;元素 // deleteCaption() 删除&lt;caption&gt;元素 // deleteRow(pos) 删除指定位置的行 // insertRow(pos) 向rows集合中指定位置插入一行 // &lt;tbody&gt; 的属性和方法 // rows 保存&lt;tbody&gt;元素中的HTMLCollection // deleteRow(pos) 删除指定位置的行 // insertRow(pos) 向rows集合中指定位置插入一行 // &lt;tr&gt; 的属性和方法 // cells 保存着&lt;tr&gt;元素中单元格的HTMLCollection // deleteCell(pos) 删除指定位置的单元格 // insertCell(pos) 向cells集合中的指定为会插入一个单元格，返回对新插入的单元格的引用 // 使用NodeList // querySelector() 方法 接收一个CSS选择符，返回与该模式匹配的第一个元素，没有则返回null var body = document.querySelector(&apos;body&apos;); // querySelectorAll() 方法 接收一个CSS选择符，返回与该模式匹配的所有元素，没有则返回null var stongs = document.querySelectorAll(&apos;p strong&apos;); // matchesSelector() 方法 接收一个CSS选择符，如果调用元素与该选择符匹配，则返回true，否则，返回false. matchesSelector(document.body, &quot;body.page1&quot;) // 元素遍历 // childElementCount 返回子元素的个数 // firstElementChild 指向第一个子元素：firstChild的元素版 // lastElementChild 指向最后一个子元素：lastChild的元素版 // previousElementSibling 指向前一个同辈元素：previousSibling的元素版 // nextElementSibling 指向后一个同辈元素：nextSibling的元素版 // HTML // 与类相关的扩充 // getElementsByClassName()方法 接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList // classList属性 这个classList属性是新集合类型DOMTokenList的实例 // add(value) 将给定的字符串值添加到列表中。如果值已经存在，就不添加了 // contains(value) 表示列表中是否存在给定的值，返回true/false // remove(value) 从列表中删除给定的字符串 // toggle(value) 如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它 // 焦点管理 // document.activeElement 属性 // HTML5添加了辅助管理DOM焦点的功能。首先是document.activeElement属性。这个属性始终会引用DOM中当前获得焦点的元素 // document.hasFocus()方法 确定文档是否获得了焦点 // HTMLDocument的变化 // readyState属性值：loading，正在加载文档 | complete，已经加载完文档 // 兼容模式 compatMode的属性 if (document.compatMode === &quot;CSS1Compat&quot;) &#123; console.log(&apos;Standards mode&apos;); &#125; else &#123; console.log(&apos;Quirks mode&apos;); &#125; // head属性 document.head // 字符集属性 document.charset = &quot;UTF-8&quot;; //自定义数据属性 // 设置值 // document.getElementById(&apos;box&apos;).dataset.appId = 123 // document.getElementById(&apos;box&apos;).dataset.myname = &quot;Michael&quot; // if (document.getElementById(&apos;box&apos;).dataset.myname) &#123; // console.log(document.getElementById(&apos;box&apos;).dataset.myname); // &#125; // 插入标记 // div.innerHTML = &quot;&lt;input type=\&quot;hidden\&quot;&gt;&lt;script&gt;alert(&apos;hi&apos;);&lt;\/script&gt;&quot;; // outerHTML属性 // 返回调用他的元素及所有子节点的HTML标签 // div.outerHTML = &quot;&lt;p&gt;This is a paragrph.&lt;/p&gt;&quot; // insertAdjacentHTML()方法 // beforebegin 在当前元素之前插入一个紧邻的同辈元素 // element.insertAdjacentHTML(&quot;beforebegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); // afterbegin 在当前元素之下插入一个新的子元素火灾第一个子元素之前再插入新的子元素 // element.insertAdjacentHTML(&quot;afterbegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); // beforeend 在当前元素之下插入新的子元素或最后一个子元素之后再插入新的子元素 // element.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); // afterend 在当前元素之后插入一个紧邻的同辈元素 // element.insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); // 内存和性能问题 // 在替换子节点可能会导致浏览器的内存占用问题。在使用innerHTML、outerHTML、insertAdjacentHTML方法时，最好手工删除要被替换的元素的所有回见处理程序和JavaScript对象属性。 // scrollIntoView()方法 // 可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。 // 传入true作为参数，或者不传入任何参数时，串口滚动之后会让调用元素的顶部与视口尽可能平齐 // 传入false作为参数，调用元素会尽可能全部出现在视口中，（可能的话，调用元素的底部会与视口顶部平齐。）不过顶部不一定平齐 // 让元素可见 // document.forms[0].scrollIntoView(); // 文档模式 // &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content = &apos;IE=IEVersion&apos;&gt; // IEVersion： // Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。 // EmulateIE9：如果有文档类型声明，则以IE9标准模式渲染页面，否则将文档模式设置为IE5。 // EmulateIE8：如果有文档类型声明，则以IE8标准模式渲染页面，否则将文档模式设置为IE5。 // EmulateIE7：如果有文档类型声明，则以IE7标准模式渲染页面，否则将文档模式设置为IE5。 // 9：强制以IE9标准模式渲染页面，忽略文档类型声明。 // 8：强制以IE8标准模式渲染页面，忽略文档类型声明。 // 7：强制以IE7标准模式渲染页面，忽略文档类型声明。 // 5：强制以IE5标准模式渲染页面，忽略文档类型声明。 // children属性 只包含元素中同样还是元素的子节点 // var childCount = element.children.length; // contains()方法 // 调用contains()方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检查的后代节点。返回值 true/false // document.documentElement.contains(document.body); // 插入文本 // innerText 属性 可以操作元素中包含的所有文本内容，包括子文档树中的文本。 // div.innerText = &quot;Hello world!&quot; // outerText 属性 读取文本内容 // console.log(div.outerText) // 滚动 // scrollIntoViewIfNeeded() 只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。 // scrollByLines() 将元素的内容滚动指定的行高 // scrollByPages() 将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。 // document.body.scrollIntoViewIfNeeded(true) // 将页面主体滚动5行 // document.body.scrollByLines(5) // 将页面主体滚动1页 // document.body.scrollByPages(-1) &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 数组]]></title>
    <url>%2F2019%2F09%2F16%2FJavaScript-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;script type=&quot;text/javascript&quot;&gt;// 立即执行函数(function () &#123; // 严格模式 &quot;use strict&quot;; var arr = [1, 3, 5, 3, 21, 5]; if (typeof (arr)) &#123; console.log(&apos;此数据类型为对象&apos;); // 检测数组 isArray返回 true or false if (Array.isArray(arr)) &#123; console.log(&apos;此对象为数组对象&apos;); // 数组的转化 console.log(arr.toString()); var list = new Array(); // 栈方法：LIFO(后进先出) list.push(&apos;张三&apos;, &apos;李四&apos;, &apos;王五&apos;); console.log(list); console.log(list.pop()); console.log(list); // 队列方法：FIFO(先进先出) list.unshift(&apos;陈六&apos;, &apos;赵七&apos;); console.log(list); console.log(list.shift()); console.log(list); // 数组重排 list.reverse(); console.log(list); // 升序排序 list.sort(); console.log(list); // 操作方法 console.log(list.concat(&apos;钱八&apos;, [&apos;豆豆&apos;, &apos;豆花&apos;])); console.log(list.slice(1, 4)); console.log(list); // 删除 console.log(list.splice(0, 1)); console.log(list); // 插入 console.log(list.splice(0, 0, &apos;花花&apos;, &apos;毛毛&apos;)); console.log(list); // 替换 console.log(list.splice(2, 1, &apos;二狗子&apos;, &apos;铁头&apos;)); console.log(list); // 位置方法 console.log(list.indexOf(&quot;二狗子&quot;)); console.log(list.lastIndexOf(&quot;铁头&quot;)); // 迭代方法 // every() 对数组中的每一项给定函数，若该函数都返回true，则返回true console.log(list.every(function (item, index, arry) &#123; return typeof (item) === &apos;string&apos;; &#125;)); /**************************/ list.push(1, 4, 5, 7, 21, 100); console.log(list); /**************************/ // some() 对数组中的每一项给定函数，若该函数有一项返回true，则返回true console.log(list.some(function (item, index, arry) &#123; return typeof (item) === &apos;string&apos;; &#125;)); // filter() 对数组中的每一项给定函数，返回该函数返回true的项组成新的数组 console.log(list.filter(function (item, index, arry) &#123; return item === &apos;二狗子&apos;; &#125;)); // forEach() 对数组中的每一项给定函数。这个方法没有返回值 console.log(list.forEach(function (item, index, arry) &#123; console.log(item); &#125;)); // map() 对数组中的每一项给定函数，返回每次函数调用的结果组成的数组 console.log(list.map(function (item, index, arry) &#123; return item &gt; 0; &#125;)); // 缩小方法 // reduce() 从第一项向后叠加 console.log(list.reduce(function (prev, cur, index, array) &#123; return prev + cur; &#125;)) // reduceRight 从最后一项向第一项叠加 console.log(list.reduceRight(function (prev, cur, index, array) &#123; return prev + cur; &#125;)) &#125; &#125; else &#123; // console.log(typeof(arr)) console.log(&apos;数据类型非数组&apos;); &#125; // 数据基本类型：null undefined number string object boolean // 从这里我们可以看出typeof验证数据的返回类型：undefined、boolean、string、number、object、function&#125;)();&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5 核心]]></title>
    <url>%2F2019%2F09%2F11%2FES5-%E6%A0%B8%E5%BF%83%2F</url>
    <content type="text"><![CDATA[作用域在 JavaScript 中, 作用域（scope，或译有效范围）就是变量和函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。在ES5中没有块级作用域的概念。 全局作用域（Global Scope）：最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的。 局部作用域（Local Scope）：和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部。 如果局部作用域的“预解析空间”（AO-活动对象（Active object））没有找到，那么代码会从上一级的作用域寻找，上级作用域不能在下级作用域寻找。 注意事项： 需要注意的是，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明” 作用域链（Scope Chain）通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。当执行函数时，总是先从函数内部找寻局部变量；如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上。 执行环境（execution context）：JavaScript为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。 闭包 可以读取自身函数外部的变量（沿着作用域链寻找） 让这些外部变量始终保存在内存中 js函数内的变量值不是在编译的时候就确定的，而是等在运行时期再去寻找的。 模块 必须有外部的封闭函数，该函数至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改其他私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 this对象“谁调用指向谁” this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象调用时，this等于那个对象。不过，匿名函数具有全局性，因此this对象同常指向window。 严格模式 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全 为未来新版本的Javascript做好铺垫 在使用严格模式的时候在全局或函数的第一条语句需定义为: ‘use strict’; 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用 主要内容： 必须用var声明变量（混杂模式中可以直接使用变量而不定义，但是这种做法会对后期造成很大的麻烦） 创建eval作用域 禁止this指向window 对象不能用重名的属性 函数不能有重名的形参 12345678910111213141516171819&apos;use strict&apos;; //在全局或函数内第一行书写//1.变量必须使用var 定义 否则报错str=&quot;xxx&quot;;//2.函数内的this指向不再是windowfunction Person(name,age) &#123; console.log(this);//undefined this.name=name;//相当于设置undefined.name =name 报错 this.age=age; &#125;//3.让eval有自己的作用域 var str =123; eval(&apos;var str=456;alert(str)&apos;);//456 alert(str);//123//4.对象不能用重名属性var obj =&#123; username:&apos;kobe&apos;, username:&apos;zs&apos; &#125; console.log(obj);//运行时没有报错,不过编辑器内有提示 最好别这么写就是了 json对象JSON.stringify(obj/arr)js对象（数组）转换为json对象（数组）JSON.parse(json)json对象（数组）转换为js对象（数组） 12345var obj=&#123;username:&quot;mike&quot;&#125;;obj=JSON.stringify(obj);console.log(typeof obj);//json对象和数组，不要说json字符串//json是一种传输数据的格式，还有xml。 object对象方法扩展ES5给Object扩展了好一些静态方法, 常用的2个: Object.create(prototype[, descriptors]) : 创建一个新的对象 以指定对象（prototype）为原型创建新的对象 指定新的属性, 并对属性进行描述value : 指定值writable : 标识当前属性值是否是可修改的, 默认为trueget : 用来得到当前属性值的回调函数set : 用来监视当前属性值变化的回调函数 1234var obj=&#123;username:&quot;damu&quot;,age:30&#125;;var obj1=&#123;&#125;;obj1=Object.create(obj); //Object是obj1上一级的构造函数，调用他所具有的函数creatconsole.log(obj1); //也就是obj1可以继承obj的属性username和age 1234567891011121314151617181920var obj=&#123;username:&quot;damu&quot;,age:30&#125;;var obj1=&#123;&#125;;obj1=Object.create(obj,&#123;sex:&#123; value:&quot;男&quot;, writable:true,//有一个writable属性：标识当前属性值是否是可以修改的，默认为false configurable:true,//有一个属性configurable：标识当前属性是否可以被删除 enumerable:true //有一个属性enumerable：标识当前属性是否能用for in枚举 默认为false&#125;&#125; //对当前扩展属性的描述&#125;); //使用create给obj1添加扩展属性console.log(obj1.sex);obj1.sex=&quot;女&quot;console.log(obj1.sex);delete obj1.sex;//规定不能直接删掉，有一个属性configurable：标识当前属性是否可以被删除，默认为falseconsole.log(obj1.sex);for(var i in obj1)&#123;console.log(i)//for in 找不到obj1使用create扩展出来的属性//有一个属性enumerable：标识当前属性是否能用for in枚举 默认为false&#125; Object.defineProperties(object,descriptors)作用：为指定object对象定义扩展多个属性get：用来获取当前属性值的回调函数set：修改当前属性值的触发的回调函数，并且实参即为修改后的值存取器属性：setter，getter一个用来存值一个用来取值 1234567891011121314151617181920212223242526272829303132333435363738394041var obj2=&#123;firstName:&quot;kobe&quot;,lastName:&quot;bryant&quot;&#125;;Object.defineProperties(obj2,&#123;fullName:&#123; get:function () &#123;//使用get来获取扩展属性的值 return this.firstName+&quot; &quot;+this.lastName//fullName想要设置的值 &#125;, set:function (data) &#123;//监听扩展属性，当扩展属性发生变化时自动调用后会将变化的值作为实参注入到set函数。 console.log(&quot;set()&quot;,data); var names=data.split(&quot; &quot;); this.firstName=names[0]; this.lastName=names[1]; &#125;&#125;//创建一个配置对象&#125;)console.log(obj2.fullName)obj2.fullName=&quot;haha heih&quot;;console.log(obj2.fullName)//get方法什么时候调用？ 获取扩展属性值的时候，get方法自动调用//对象本身的两个方法：//get propertyName()&#123;&#125;//set propertyName()&#123;&#125;var objj=&#123;age:15,tall:180,get all()&#123; return this.age+&quot; &quot;+this.tall;&#125;,set all(data)&#123; console.log(&quot;set()&quot;,data); var names=data.split(&quot; &quot;); this.age=names[0]; this.tall=names[1];&#125;&#125;console.log(objj);objj.all=&quot;13 189&quot;;console.log(objj); 数组扩展 Array.prototype.indexOf(value):得到值在数组中的第一个下标,输入第一个3的下标 Array.prototype.lastIndexOf(value):得到值在数组中的最后一个下标 Array.prototype.forEach(function(item,index){}):遍历数组 Array.prototype.map(function(item,index){}):遍历数组返回一个新的数组，返回加工之后的值 Array.prototype.filter(function(item,index){}):遍历过滤出一个新的子数组，返回条件为true的值 123456789101112131415161718var arr=[2,3,5,1,4,6,3];console.log(arr.indexOf(3)); //输出第一个6的下标console.log(arr.lastIndexOf(3)); //输出最后一个6的下标arr.forEach(function(item,index)&#123; console.log(item+&quot; &quot;+index) //输出所有元素的值和下标&#125;)var arr1=arr.map(function(item,index)&#123; return item+10;&#125;);console.log(arr1); //根据arr产生一个新数组，要求每个元素比原来大10var arr2=arr.filter(function(item,index)&#123; return item &gt; 4; &#125;)console.log(arr2); //根据arr产生一个新数组，返回的每个元素都要大于4 bind()、call()、apply()的区别123456789101112131415161718192021222324var obj=&#123;username:&quot;kobe&quot;&#125;;function foo(data)&#123; console.log(this,data)&#125;// foo();//自调用时this指向的是window，使this指向我们定义的objfoo.call(obj);foo.apply(obj);//call和apply在不传参的情况下使用方式是一样的//区别function foo(data)&#123; console.log(this,data)&#125;foo.call(obj,33); //直接传入参数foo.apply(obj,[33]); //传入数据必须写在数组里//bindvar bar=foo.bind(obj,33);//绑定完this有一个返回值，不会立即调用当前函数而是将函数返回,通常用来指定回调函数的this。用bar来接收返回的函数然后执行bar();// 也可写成foo.bind(obj,33)()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 代码约定]]></title>
    <url>%2F2019%2F09%2F11%2FJavaScript-%E4%BB%A3%E7%A0%81%E7%BA%A6%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[可维护性 可理解性 直观性 可适应性 可扩展性 可调试性 代码约定 函数和方法：每个函数或方法都应该包含一个注释，描述其目的和用于完成任务所可能使用的算法。陈述实现的假设也非常重要，汝参数代表什么，函数是否有返回值（因为这个不能从函数定中推断出来）。 大段代码：用于完成单个任务的多行代码应该再前面放一个描述任务的注释。 复杂的算法：如果使用了一种独特的方式解决某个问题，则要在主时钟解释你是如何做的。这不仅仅可以帮助其他浏览你代码的人，也能在你自己查阅代码的时候帮助理解。 Hack：因为存在浏览器差异，JavaScript代码一般会包含一些Hack。不要假设其他人在看代码的时候能够理解Hack索要应付的浏览器问题，如果因为其他浏览器无法使用普通的方法，所以扭腰用一些不同的方法，那么请假这些信息放在注释中。这样可以减少出现这种情况的可能性：有人偶然看到你的hack,然后“修正”了它，最后重新引入了你本来修正了的错误。缩进和注释可以带来更可读的代码，未来则更容易维护。 变量名应该为名词如：car或person 函数名应该以动词开始，如getName()。返回布尔类型值得函数一般以is开头，如：isEnable（）。 变量和函数都应使用呵护逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩来缓解。 变量类型透明 123456// 用于指定数据类型的匈牙利标记法var bFound; // 布尔型var iCount; // 整数var sName; // 字符串var oPerson; // 对象 松散耦合 解耦HTML/JavaScript 在Web上，HTML和JavaScript各自代表了解决方案中的不同层次：HTML是数据，JavaScript是行为。 1234567891011121314&lt;!-- 使用了&lt;script&gt;的紧密耦合 --&gt;&lt;script&gt; docment.write(&quot;hello world&quot;)&lt;/script&gt;&lt;!-- 使用时间处理程序属性值的紧密耦合的HTML/JavaScript --&gt;&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclilck=&quot;doSomething()&quot;&gt;// 将HTML紧密耦合到JavaScriptfunction insetMessage(msg)&#123; var container = docment.getElementById(&quot;container&quot;); container.innerHTML = &quot;&lt;div&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt;&quot;&#125; 解耦CSS/JavaScript 1234567891011// CSS对JavaScript的紧密耦合element.style.color = &quot;red&quot;;element.style.backgroundColor = &quot;blue&quot;;// CSS对JavaScript的松散耦合element.className = &quot;edit&quot;//JavaScript对CSS的紧密耦合div&#123; width: exprerssion(docment.body.offsetWidth - 10 + &quot;px&quot;);&#125; 解耦应用逻辑/事件处理程序 12345678910function handleKeyPress(event)&#123; event = EventUtil.getEvent(event); if(event.keyCode == 13)&#123; var target = EventUtil/getTarget(event); var value = 5 * parseInt(target.value); if(value &gt; 10)&#123; docment.getElementById(&quot;error-msg&quot;).style.display = &quot;block&quot;; &#125; &#125;&#125; 尊重对象所有权 不要为实例或原型添加属性 不要为实例或原型添加方法 不要冲定义已存在的方法 创建包含所需功能的新对象，并用它与相关对象进行交互 创建自定义类型，继承需要进行修改的类型。然后可以为定义类型添加额外功能。 避免全局量 避免与null进行比较 使用常量 重复值：任何在多出用到的值都应该抽取为一个常量。用户界面字符串：任何用于显示给用户的字符串，都应该抽取出来以便国际化。URLs：在Web应用中，资源位置很容易变更，所以推荐使用一个公共地方存放所有的URL。任意可能会更改的值：每当你再拥戴字面量值得时候，你都要问一下自己这个值字啊未来是不是会变化。 性能 作用域 避免全局查找 避免with语句 选择正确方法 避免不必要的属性查找 优化循环：减值迭代、简化终止条件、简化循环体、使用后测试循环 展开循环 避免双重解释 性能的其他注意事项：原生方法比较快、switch语句比较快、位运算比较快 最小化语句数 多个变量声明 插入迭代值 使用数组和对象字面量 优化DOM交互 最小化现场更新 使用innerHTML 使用事件代理 注意HTMLCollection 构建过程 知识产权问题：若果吧带有完整注释的代码放到线上，那别人就跟容易知道你的以图，对它再利用，并且可能找到安全漏洞。 文件大小：书写代码要保证容易阅读，才能更好地维护，但是这对于性能是不利的。浏览器不能从额外的空白字符或者是冗长的函数名和变量名中获得什么好处。 代码组织：组织代码要考虑到可维护性并不一定是传送给浏览器的最好方式。 验证 eval()的使用 未声明变量的使用 遗漏的分号 不恰当的换行 错误的逗号使用 语句周围遗漏的括号 switch分支语句中遗漏的break 重复声明的变量 with的使用 错误使用的等号（替代了双等号或三等号） 无法到达的代码 压缩 文件压缩 删除额外的空白（包括换行） 删除所有注释 缩短变量名 HTTP压缩 不过现在基本都是用ESlint语法检测工具、webpack压缩打包了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 离线与存储]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript-%E7%A6%BB%E7%BA%BF%E4%B8%8E%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[离线检测1234567891011121314// navigator.online属性if (navigator.online)&#123; // 正常工作&#125; else &#123; // 执行离线状态时的任务&#125;// online offline事件EventUtil.addHandler(window, &quot;online&quot;, function()&#123; alert(&quot;Online&quot;);&#125;)EventUtil.addHandler(window, &quot;offline&quot;, function()&#123; alert(&quot;Offline&quot;);&#125;) 应用缓存applicationCache对象，status属性： 0：无缓存，即没有与页面相关的应用缓存； 1：闲置，即应用缓存未得到更新； 2：检查中，即正在下载描述文件并检查更新； 3：下载中，即应用缓存正在下载描述文件中指定的资源； 4：更新完成，即应用缓存已经更新了资源，而且所有资源都已下载完毕，可以通过swapCache()来使用了； 5：废弃：即应用缓存的描述文件已经不存在，因此页面无法在访问应用缓存； 事件： checking：在浏览器为应用缓存查找更新时触发； error：在检查更新或下载资源期间发生错误时触发； noupdate：在检查妙手文件发现文件无变化时触发； downloading：在开始下载应用缓存资源时触发； progress：在文件下载应用缓存的过程中持续不断地触发； updateready：在页面新的应用缓存下载完毕并且可以通过swapCache()使用时触发； cached: 在应用缓存完整可用时触发 数据存储HTTP Cookie，通常直接叫做Cookie，最初是在客户端用于存储回话信息的。该标准要求服务器对任意HTTP请求发送Set-Cookie HTTP头座位响应的一部分，其中包含回话信息。 1234HTTP/1.1 200 OKContent-TYpe: text/htmlSet-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.comOther-header: other-header-value 限制 cookie在性质上是绑定在特定的域名下的。当设定一个cookie后，再给创建它的域名发送请求时，都会包含这个cookie。 cookie的构成 名称/值/域/路径/失效时间/安全标志 子cookie 绕开浏览器的单域名下的cookie数量限制，子cookie是存放在单个cookie中的更小段数据。也就是cookie值来存储多个键值对。 name=name1=value1 &amp; name2=value2 &amp; name3=value3 &amp; name4=value4 &amp; name5=value5 子cookie一般也以查询字符串的格式进行格式化。然后这些值可以使用单个cookie进行存储和访问，而非每个键值对使用不同的cookie存储。 IE用户数据在IE5.0中，微软通过一个自定义行为引入了持久化用户数据的概念。永辉数据允许每个文档最多128kb数据，每个域名最多1MB数据。 1234567var dataStor = document.getElementById(&quot;dataStore&quot;);dataStore.setAttribute(&quot;name&quot;, &quot;张三&quot;);dateStore.setAttribute(&quot;book&quot;, &quot;书名&quot;);dataStore.save(&quot;BookInfo&quot;);dataStore.load(&quot;BookInfo&quot;);dataStore.getAttribute(&quot;name&quot;); Web存储机制Web Storage 最早是在web超文本应用技术工作组(WHAT-WG)的Web应用1.0规范中描述的。这个规范最初的工作最终成为了HTML5的一部分。主要目标有两个： 提供一种在cookie之外存储回话数据的途径； 提供一种存储大量可以跨回话存在的数据的机制。 最初的Web Storage规范包含了两种对象的定义：sessionStorage和globalStorage。这两个对象在支持的浏览器中是以windows对象属性的形式存在的。 Storage类型 clear(): 删除所有值getItem(name): 根据指定的名字那么获取对象的值key(index): 获得index位置处的值得名字removeItem(name): 喊出有那么指定名值对setItem(name,value):为指定的名值对设置一个对应的值。 sessionStorage seeionStorage对象存储特定于某个回话的数据，也就是该数据只保持浏览器关闭。这个对象就像回话cookie，也会在浏览器关闭后消失。 globalStorage对象 具备同源策略限制。 1234// 保存数据globalStorage[&quot;wrox.com&quot;].name = &quot;张三&quot;;// 获取数据var name = globalStorage[&quot;wrox.com&quot;].name; localStorage对象 localStorage对象在修订过的HTML5规范中作为持久保存客户端数据的方案取代了globalStorage。与globalStorage不同，不能给localStorage指定任何访问规则，规则事先就设定好了。要访问一个localStorage对象，页面必须来自同一个域名(子域名无效)，使用同一种协议，在同一个端口上。 12345678// 使用方法存储数据localStorage.setItem(&quot;name&quot;,&quot;张安&quot;);// 使用属性存储数据localStorage.book = &quot;book&quot;;// 使用方法读取数据var name = localStorage.getItem(&quot;name&quot;);// 使用属性读取数据var book = localStorage.book; 存储在localStorage中的数据和存储globalStorage中的数据一样，都遵循相同的规则：数据保留到通过JavaScript删除或者用户清楚浏览器缓存。 Storage事件 domain: 发生变化的存储空间域名； key:设备或删除的域名; newValue：如果是设置值，则是更新，如果是删除，则是null。 oldValue: 键被更改之前的值 限制 大多数桌面浏览器设置每个来源5MB的限制。Chrome和Safari对每个来源的限制是2.5MB。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 跨域技术]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript-%E8%B7%A8%E5%9F%9F%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[在CORS出现之前，要实现跨域Ajax通信颇费一些周折。开发人员想出了一些办法，利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求。虽然CORS技术已经无处不在，但开发人员自己发明的这些技术仍然被广泛使用，毕竟这样不需要修改服务器端代码。 图像Ping&lt;img&gt;标签，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。可以动态的创建图像，使用他们的onload和onerror事件处理程序来确定是否接受到了响应。 动态创建图像经常用于图像Ping。图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的。 12345var img = new Image();img.onload = img.onerror = function()&#123; alert(&quot;Done!&quot;);&#125;;img.src = &quot;url&quot;; JSONPJSONP是JSON with padding（填充式JSON或参数JSON）的简写，是应用JSON的一种新方法，在后来的Web服务中非常流行。JSONP看起来与JSON差不多，只不过是被包含在函数调用中的JSON，就像下面这样。 callback({&quot;name&quot;:&quot;张飒&quot;}); JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。 http://freegeoip.net/json/?callback=handleResponse 这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调参数是很常见的。JSONP是通过动态&lt;script&gt;元素来使用的，使用时可以为src属性指定一个跨域RUL。这里的&lt;script&gt;元素与&lt;img&gt;元素类似，都有能力不受限制地从其他域加载资源。因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。 1234567function handleResponse(response)&#123; alert(&quot;You&apos;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);&#125;var script = document.createElement(&quot;script&quot;);script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore(script,document.body.firstChild); 优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过，JSONP也有两点不足。 首先，JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究。因此在使用不是你自己运维的Web服务时，一定得保证它安全可靠。 其次，要确定JSONP请求是否失败并不容易。虽然HTML5给&lt;script&gt;元素新增了一个onerror事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和宽带都一样。 CometComet是Alex Russell发明的一个词，指的是一种更高级的Ajax技术（经常也有人称为”服务器推送”）。Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。 轮询轮询（Polling）是一种CPU决策如何提供周边设备服务的方式，又称“程控输入输出”（Programmed I/O）。轮询法的概念是：由CPU定时发出询问，依序询问每一个周边设备是否需要其服务，有即给予服务，服务结束后再问下一个周边，接着不断周而复始。 有两种实现Comet方式： 长轮询和流。长轮询是传统轮询（也成为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据。12345678910111213&lt;?php $i = 0; while(true)&#123; // 输出一些数据，然后立即刷新输出缓存 echo &quot;number is $i&quot;; flush(); // 等几秒钟 sleep(10); $i++; &#125;php&gt; 随着不断从服务器接收数据，readyState的值会周期性的变为3.当readyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用XHR对象实现HTTP流的典型代码如下所示： 1234567891011121314151617181920212223242526272829function createStreamingClient(url, progress, finished)&#123; var xhr = new XMLHttpRequest(), received = 0; xhr.open(&quot;get&quot;,url,true); xhr.onreadystatechange = function()&#123; var result; if(xhr.readyState === 3)&#123; // 知趣的最新数据并调整计算器 result = xhr.responseText.substring(received) recelived += result.length; // 调用progress回调函数 progress(result); &#125; else if （xhr.readyState） &#123; finished(xhr, responseText) &#125; &#125;； xhr.send(null); return xhr;&#125;var client = createStreamingClient(&quot;streaming.php&quot;, function(data)&#123; alert(&quot;Received:&quot; + data); &#125;,function(data)&#123; alert(&quot;Done!&quot;);&#125;) 这个createStreamingClient()函数接收三个参数： 要连接的URL; 在接收到数据时调用的函数以及关闭连接时调用的函数。 有时候，当连接关闭时，很可能还需要重新建立，所以关注链接什么时候关闭还是有必须要的。 只要readystatechange事件发生，而且readyState值为3，就对responseText进行分割以取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。然后通过progress回调函数来处理传入的新数据。而当readyState值为4时，则执行finished回调函数，传入响应返回的全部内容。 服务器发送事件SSE（Server-Sent Events,服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须是text/event-stream，而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。有了这么简单实用的API，再实现Comet就容易多了。 HTTP流。它在页面整个生命周期内只使用一个HTTP连接，具体使用方法即页面向浏览器发送一个请求，而服务器保持tcp连接打开，然后不断向浏览器发送数据。 SSE API SSE的javaScript API与其他传递消息的JavaScript API很相似。要预订新的事件流，首先要创建一个新的EventSource对象，并传进一个入口点： var source = new EventSource(“myevents.php”); 注意，传入的URL必须与创建对象的页面同源（相同的URL模式、域及端口）。EventSource的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭了连接。 另外，还有一下三个事件。 open: 在建立连接时触发。 message: 在从服务器接收到新事件时触发。 error: 在无法简历连接时触发。 就一般的用法而言，onmessage事件处理程序也没有什么特别的。 1234source.onmessage = function(event)&#123; var data = event.data; // 处理数据&#125;; 服务器发回的数据以字符串形式保存在event.data中。 默认情况下，EventSource对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着SSE适合长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close()方法。 source.close(); 事件流 所谓服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为 text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀data:，例如： 12345data: foodata: bardata: foodata: bar 对以上响应而言，事件流中的第一个message事件返回的event.data值为”foo”，第二个message事件返回的event.data值为”bar”,第三个message事件返回的event.data值为”foo\nbar”（注意中间的换行符）。对于多个连续的以data:开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。只有包含data:的数据行后面有空行时，才会触发message事件，因此在服务器上生成事件流时不能忘了多添加这一行。 通过id:前缀可以给特定的事件指定一个关联的ID，这个ID行位于data:行前面或后面皆可： 12data: fooid: 1 设置了ID后，EventSource对象会跟踪上一次触发的事件。如果连接断开，回想服务器发送一个包含名为Last-Event-ID的特殊HTTP头部请求，以便服务器知道下一次该触发哪个事件。在多次连接得事件流中，这种机制可以确保浏览器以正确的顺序收到连接得数据段。 Web Sockets要说是令人津津乐道的新浏览器API，就得数Web Sockets了。Web Sockets的目标是在一个单独的持久连接上提供全双工、双向通信。在JavaScript中创建了Web Socket之后，会有一个HTTP请求发送到浏览器已发起连接。在取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为Web Socket协议。也就是说，使用标准的HTTP服务器无法实现Web Sockets,只有支持这种协议的专门服务器才能正常工作。 由于WebSockets使用了自定义的协议，所以URL模式也略有不同。未加密的连接不再是http://,而是ws://；加密的链接也是不是https://,而是wss://。在使用Web SocketURL时。必须带着这个模式，因为将来还有可能支持其他模式。 使用自定义协议而非HTTP协议的好处是，能够在客户端和服务端之间发送非常少量的数据，而不必担心HTTP那样字节集的开销。由于传递的数据包很小，因此WebSockets非常适合移动应用。毕竟对移动应用而言，带宽和网络延迟都是关键问题。使用自定义协议的缺点在于，制定协议的时间比制定JavaScriptAPI的时间还要常。Web Sockets曾几度搁浅，就因为不断有人发现这个新协议存在一致性和安全性问题。 Web Sockets API 要创建WebSocket,先实例一个WebSocket对象并传入要连接得URL； var socket = new WebSocket(&quot;URL&quot;); WebSocket.OPENING(0): 正在建立连接。WebSocket.OPEN(1): 已经建立连接。WebSocket.CLOSING(2): 正在关闭连接。WebSocket.CLOSE(3): 已经关闭连接。 关闭WebSocket连接，可以在任何时候调用close()方法： socket.close(); 发送和接收数据 1234567var message = &#123; time: new Date(), text: &quot;Hello world!&quot;, clientId: &quot;54564646&quot;&#125;;socket.send(JSON.stringify(message)); 接下来，服务器要读取其中的数据，就要解析接收道德JSON字符串。 1234socket.onmessage = function(event)&#123; var data = event.data; // 处理数据&#125; 与通过send()发送到服务器的数据一样，event.data中返回的数据也是字符串。如果你想得到其他格式的数据，必须手工解析这些数据。 其他事件 WebScoket对象有其他三个事件，在连接生命周期的不同阶段触发。 open: 在成功建立连接时触发。 error: 在发生错误时触发，连接不能持续。 close: 在连接关闭时触发。 WebScoket 对象不支持DOM2级时间侦听器，因此必须使用DOM0级语法分别定义每个事件处理程序。 1234567891011121314var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);socket.onopen = function () &#123; alert(&quot;Connection established.&quot;);&#125;;socket.onerror = function () &#123; alert(&quot;Connection error.&quot;);&#125;;socket.onclose = function (event) &#123; alert(&quot;Connection closed.&quot;); console.log(&quot;Was clean ? &quot; + event.wasClean + &quot;Code = &quot; + event.code + &quot; Reason= &quot; + event.reason);&#125;; SSE 与 Web Sockets面对某个具体的用力，在考虑是使用SSE还是使用WebSockets时，可以考虑如下几个因素。首先，你是否有自由度简历和维护WebSockets服务器？其次，到底需不需要双向通信。 安全 要求以SSL连接来访问可以通过XHR请求的资源。 要求每一次请求都要附带经过响应算法计算得到的验证码。 建议采用上面两种办法。 要求发送POST而不是GET请求 检查来源URL以确定是否可信 基于cookie信息进行验证]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Ajax]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-Ajax%2F</url>
    <content type="text"><![CDATA[XMLHttpRequest对象 XHR的用法 12345// 请求类型，请求地址，是否异步xhr.open(&quot;get&quot;,&quot;http://www.baidu/com&quot;, false)// 作为请求主体发送的数据xhr.send(null) XHR对象的属性： responseText: 作为相应主体被返回的文本。 responseXML: 如果相应的内容类型是”text/html”或”application/xml”，这个属性中将保存喊着响应数据的XML DOM文档。 status: 响应HTTP状态。 statusText：HTTP状态的说明。 readyState：该属性表示请求/响应过程的当前活动阶段。（0未初始化，1启动，2发送，3接收，4完成） 12345678910111213141516var xhr = createXHR();xhr.onreadystatechange = functuin () &#123; if (xhr.readState === 4) &#123; if( (xhr &gt;= 200 &amp;&amp; xhr.status &lt;300) || xhr.status === 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125;&#125;xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);xhr.send(null);在接收响应之前还可以调用abort()方法来取消异步请求。 HTTP头部信息 默认情况下，在发送XHR请求的同时，还会发送下列头部的信息： Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够显示的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语言。 Connection：浏览器与服务器之间连接的类型。 Cookie：当前页设置的任何Cookie。 Host：发出请求的页面所在的域。 Referer：发布请求的页面的URL。 User-Agent：浏览器的用户代理字符串。 使用setRequestHeader()方法可以设置自定义的请求头部。这个方法接受两个参数：头部字段的名称和头部字段的值。 12345678910111213var xhr = createXHR();xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125; &#125;&#125;xhr.open(&quot;get&quot;,&quot;url&quot;,true);xhr.setRequestHeader(&quot;MyHeader&quot;,&quot;Myvalue&quot;);xhr.send(null) 使用getErsponseHeader()方法并栓如头部字段名称，可以取得相应的响应头部信息。使用getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串。 12var myHeader = xhr.getResponseHeader(&quot;MyHeader&quot;);var allHeader = xhr.getAllResponseHeaders(); Get请求 GET是最常见的请求类型，最常用于服务器查询某些信息。必要时，可以将查询字符串参数追加到URL的末尾，一遍将信息发送给服务器。对于XHR而言，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码才行。 使用GET请求经常会发生一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行解码，然后才能放到URL的末尾。 xhr.open(&#39;get&#39;,&#39;a.html?name=value&amp;name1=value1&#39;,true) addURLParam()函数 123456789101112// 要添加参数的URL 参数名称 参数值function addURLParam(url, name, value)&#123; url += (url.indexOf(&quot;?&quot;) === -1 ? &quot;?&quot; : &quot;&amp;&quot;); url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); return url;&#125;;// 调用url = addURLParam(url, &quot;book&quot;, &quot;张三&quot;);// 初始化请求xhr.open(&quot;get&quot;, url, false); POST请求 通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主题提交，而GET请求传统上不是这样。 12345678910111213141516function submitData()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125; &#125; &#125; xhr.open(&quot;post&quot;, &quot;example.php&quot;, true) xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;) var form = document.getElementById(&quot;user-info&quot;) xhr.send(serialize(form))&#125; XMLHttpRequest 2级 FormData 12345678910111213var xhr = createXHR();xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125; &#125;&#125;xhr.open(&quot;post&quot;,&quot;url&quot;,true);var form = document.getElementById(&quot;user-info&quot;)xhr.send(new FormData(form)) 超时设定 12345678910111213141516var xhr = createXHR();xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125; &#125;&#125;xhr.open(&quot;get&quot;,&quot;url&quot;,true);xhr.timeout = 1000;xhr.ontimeout = function () &#123; alert(&quot;Request did not return is a second.&quot;);&#125;xhr.send(null) overrideMimeType()方法 通过调用overrideMimeType()方法，可以保证把响应当做XML而非纯文本来处理 1234var xhr = createXHR();xhr.open(&quot;get&quot;,&quot;url&quot;,true);xhr.overrideMimeType(&quot;text/xml&quot;);xhr.send(null); 进度事件 loadstart：在接收到响应数据的第一个字节是触发。 progress：在接收响应期间持续不断地触发。 error：在请求发生错误时触发。 abort：在因为调用abort()方法而终止连接时触发。 load：在接收到完整响应数据时触发。 loadend：在通信完成或者触发error、abort或load事件后触发。 load事件，只要浏览器接收到服务器响应，不管其状态如何，都会触发load事件。 12345678910var xhr = createXHR();xhr.onload = function () &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125;&#125;xhr.open(&quot;get&quot;,&quot;altevents.php&quot;,true)xhr.send(null) progress事件 12345678910111213141516171819var xhr = createXHR();xhr.onload = function () &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125;&#125;xhr.onprogress = function(event)&#123; var divStatus = document.getElementById(&quot;status&quot;); if(event.lengthComputable)&#123; divStatus.innerHTML = &quot;Received&quot; + event.position + &quot;of&quot; + event.totalSize + &quot;bytes&quot;; &#125;&#125;xhr.open(&quot;get&quot;,&quot;altevents.php&quot;,true)xhr.send(null) 跨源资源共享CORS(Cross-Origin Resource Sharing, 跨源资源共享)，是W3C的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应是应该成功，还是应该失败。 IE对CORS的实现 微软在IE8中引入了XDR(XDomainRequest)类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。以下是XDR与XHR的一些不同之处。 cookie不会随请求发送，也不会随响应返回。 智能设置请求头部信息中的Content-Type字段。 不能访问响应头部信息。 只支持GET和POST请求。 这些变化使CSRF(Cross-Site Request Forgery,跨站点请求伪造)和XSS(Cross-Site Scripting,跨站点脚本)的问题得到了缓解。 被请求的资源可以根据它认为合适的任意数据（用户代理，来源页面等）来决定是否设置Access-Control-Allow-Origin头部。作为请求的一部分，Origin头部的值表示请求的来源域，以便远程 资源明确地识别XDR请求。 12345678910111213141516171819var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert(&quot;An error occurred.&quot;)&#125;;xdr.timeout = 1000;xdr.ontimeout = function()&#123; alert(&quot;Request took too long.&quot;)&#125;// GET请求xdr.open(&quot;get&quot;,&quot;url&quot;);xdr.send(null);// POST请求xdr.open(&quot;post&quot;,&quot;url&quot;);xdr.contentType = &quot;application/x-www-form-urencoded&quot;;xdr.send(&quot;name=value&amp;name2=value2&quot;); 跨域XHR对象也有一些限制，但是为了安全这些限制是必需的。 不能使用setRequestHeader()设置自定义头部。 不能发送和接收cookie。 调用getAllResponseHeaders()方法总会返回空字符串。 Preflighted Reqeusts透明服务器验证机制支持开发人员使用自定义头部、GET或POST之外的方法，以及不同类型的主体内容。 Origin：与简单的请求相同。 Access-Control-Request-Method：请求自身使用的方法。 Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。 123Origin: urlAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: NCZ 发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。 1234Access-Control-Allow-Origin: urlAccess-Control-Allow-Method: POST,GETAccess-Control-Allow-Headers: NCZAccess-Control-Max-Age: 1728000 Preflight请求结束后，结果将按照响应中指定的时间缓存起来。 带凭据的请求默认情况下，跨源请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。如果服务器接收带凭据的请求，会用下面的HTTP头部来响应。 Access-Control-Allow-Credentials: true 跨浏览器的CORS12345678910111213141516171819202122function createCORSRequest(method,url)&#123; var xhr = new XMLHttpRequest(); if(&quot;withCredentials&quot; in xhr)&#123; xhr.open(method,url,true); &#125; if(typeof XDomainRequest != &quot;undefined&quot;)&#123; vxhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; xhr = null; &#125; return xhr;&#125;var request = createCORSRequest(&quot;get&quot;,url);if(request)&#123; request.onload = function () &#123; // 对request.responseText进行处理 &#125; request.send();&#125; XMLHttpRequest对象与XDomainRequest对象共同的属性/方法如下： abort(): 用于停止正在进行的请求。 onerror: 用于替代onreadystatechange检测错误。 onload: 用于替代onreadystatechange检测成功。 responseText: 用于取得响应内容。 send(): 用于发送请求。 以上成员都包含在createCORSRequest()函数返回的对象中。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript JSON]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-JSON%2F</url>
    <content type="text"><![CDATA[JSON语法JSON语言可以表示一下三种类型的值： 简单值，使用与JavaScript相同的语法，可以在JSON中表示字符串，数值，布尔值，和null，但JSON不支持JavaScript中的特殊值undefined; 对象：对象作为一种复杂数据类型，表示是一组有序的键值对。而每个键值对中的值可以是简单之，也可以是复杂数据类型的值； 数组：数组也是一种复杂数据类型，表示一组有序的值得列表。可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。 简单值最简单的JSON数据形式就是简单值 12345&quot;Hello world&quot;truenull JavaScript字符串与JSON字符串的最大区别在于，JSON字符串必须使用双引号(单引号会导致语法错误)。 对象JSON中的对象与JavaScript字面量稍微有一些不同。 1234var person = &#123; name: &quot;张飒&quot;, age: 18&#125; JSON表示上述对象方式 1234&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18&#125; 数组JSON中的第二种复杂数据类型是数组。JSON数组采用的就是Javascript中数组字面量形式。 var value = [25, 10, &quot;张三&quot;] JSON中，可以采用同样语法表示同一个数组 12345678910[ &#123; &quot;title&quot;:&quot;张三&quot;, &quot;age&quot;: 18 &#125;, &#123; &quot;title&quot;:&quot;李四&quot;, &quot;age&quot;: 18 &#125;,] 解析与序列化1doc.getElementsByTagName(&quot;book&quot;)[2].getAttribute(&quot;title&quot;) JSON 对象123456789101112131415var book = &#123; title: &quot;张三&quot;, authors: [ &quot;李四&quot; ], edition: 3, year: 2019,&#125;;var jsonText = JSON.stringfy(book);// stringfy对象序列化为一个JSON字符串var bookCopy = JSON.parse(jsonText)// 如果传给JSON.parse()的字符串不是有效的JSON，该方法会抛出错误 序列化选项 过滤结果 12345678910var book = &#123; &quot;title&quot;: &quot;标题&quot;, &quot;authors&quot;: [ &quot;作者君&quot; ], edition: 1, year: 2019&#125;var jsonText = JSON.stringfy(book,[&quot;title&quot;,&quot;edition&quot;]); JSON.stringfy()的第二个参数是一个数组，其中包含两个字符串：”title” “edition”。这两个属性与将要序列化的对象中的属性是对应的，因此在返回的结果字符中，就只会包含着两个属性： {&quot;title&quot;: &quot;标题&quot;, &quot;edition&quot;: 1} 如果第二个参数是函数，行为会稍有不同。传入的函数接收两个参数，属性和属性值。根据属性可以知道应该如何处理要序列化的对象中的属性。 123456789101112var jsonText = JSON.stringify(book, function(key, value)&#123; switch(key)&#123; case &quot;authors&quot;: return value.join(&quot;,&quot;) case &quot;year&quot;: return 2000; case &quot;edition&quot;: return undefined; default: return value &#125;&#125;) 字符串缩进 JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的每个级别缩进的空格数。 var jsonText = JSON.stringify(book, null, 4); console.log(jsonText)返回结果： 123&#123; &quot;title&quot;: &quot;张三&quot;&#125; toJSON()方法 12345678var book = &#123; &quot;title&quot;: &quot;标题&quot; toJSON: function () &#123; return this.title; &#125;&#125;var jsonText = JSON.stringify(book); 解析选项JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。 123456789var bookCopy = JSON.parse(jsonText, function (key, value)&#123; if(key === &quot;releaseDate&quot;)&#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);alert(bookCopy.releaseDate.getFullYear()); ECMAScript 5定义了一个原生的JSON对象，可以用来将对象序列化为JSON字符串或者将JSON数据解析为JavaScript对象。JSON.stringify()和JSON.parse()方法分别用来实现上述两项功能。这两个方法都有一些选项，通过他们可以改变过滤的方式，或者改变序列化的过程。 JSON对象转化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;script&gt;//json字符串、json对象、数组 三者之间的转换let jsonStr = &apos;[ &#123;&quot;id&quot;:&quot;01&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;01&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;011&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;01&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;03&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;04&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;05&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;06&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;]&apos;;let jsonObj = $.parseJSON(jsonStr);//json字符串转化成json对象(jq方法)//let jsonObj = JSON.parse(jsonStr)//json字符串转化成json对象（原生方法）let jsonStr1 = JSON.stringify(jsonObj)//json对象转化成json字符串//console.log(jsonStr1+&quot;jsonStr1&quot;)//json对象转化成json数组对象let arr1=[];for(let i in jsonObj)&#123; //let o=&#123;&#125;; //o[i]=jsonObj[i]; arr1.push(jsonObj[i]); &#125;//console.log(arr1);//console.log(typeof(arr));let jsonStr11 = JSON.stringify(arr1)//json数组转化成json字符串//console.log(jsonStr11);let jsonArr = [];for(let i in jsonObj)&#123; jsonArr[i] = jsonObj[i];&#125;//console.log(jsonArr);//console.log(typeof(jsonArr));&lt;/script&gt;&lt;script&gt;//将对象转化为数组let obj=&#123;&apos;未完成&apos;:5,&apos;已完成&apos;:8,&apos;待确认&apos;:4,&apos;已取消&apos;:6&#125;;let arr = [];for (let i in obj) &#123; //arr.push(obj[i]); //属性 //arr.push(obj[i]); //值 let o=&#123;&#125;; o[i]=obj[i]; arr.push(o);&#125;function objToArray(array) &#123; let arr = []; for (let i in array) &#123; let o=&#123;&#125;; o[i]=array[i]; arr.push(o); &#125; console.log(arr); //return arr;&#125;// console.log(arr)objToArray(obj);&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 错误与调试]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[浏览器的报错try-catch语句12345try &#123; // 可能会导致出错的代码&#125; catch(error) &#123; // 在错误发生时怎么处理&#125; 错误类型 Error:基类，其它错误类型都继承自该类型。 EvalError：如果没将eval当成函数调用就会抛出此类型错误。 RangeError:超出范围就会抛出此错误类型。例如：在初始化数组时传入了不支持的项数，比如-20。 ReferenceError:访问不存在的变量时会抛出此类型的错误。 SyntaxError: 当语法错误时会抛出此类型的错误。例如：在js中运行 ’a 这样的错误语句。 TypeError:当发生类型错误时抛出此类型的错误。例如：运行不存在的方法，在undefined中取值 URIError:在使用encodeURI或decodeURI时url格式不正确会抛出此类错误。我尝试传入对象，数值都没抛出错误。例:%abcd。会报错 浏览器的调试 error(message)：将错误消息记录到控制台 info(message)：将信息性消息记录到控制台 log(message)：将一般消息记录到控制台 warn(message)：将警告消息记录到控制台]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript DOM]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-DOM%2F</url>
    <content type="text"><![CDATA[HTML DOM (文档对象模型) DOM0级处理事件就是将一个函数赋值给一个事件处理属性。 123456789101112131415161718// 改变 HTML 输出流 在 JavaScript 中，document.write() 可用于直接向 HTML 输出流写内容。// 改变 HTML 内容 document.getElementById(id).innerHTML=新的 HTML// 改变 HTML 属性 document.getElementById(id).attribute=新属性值// 改变 HTML 样式 document.getElementById(id).style.property=新样式// 使用时间 onclick=&quot;document.getElementById(&apos;id1&apos;).style.color=&apos;red&apos;&quot;// 1. 当用户点击鼠标时onclick// 2. 当网页已加载时onload 和 onunload 事件会在用户进入或离开页面时被触发。onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。onload 和 onunload 事件可用于处理 cookie。// 3. 当图像已加载时// 4. 当鼠标移动到元素上时onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。// 5. 当输入字段被改变时onchange 事件常结合对输入字段的验证来使用。// 6. 当提交 HTML 表单时// 7. 当用户触发按键时 DOM2级事件在DOM0级时间段额基础上弥补了一个处理处理程序，无法同时绑定多个处理函数的缺点。允许给一个程序添加多个处理函数。 1234567891011121314151617181920211. addEventListener() 方法addEventListener() 方法用于向指定元素添加事件句柄。addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。你可以向一个元素添加多个事件句柄。你可以向同个元素添加多个同类型的事件句柄，如：两个 &quot;click&quot; 事件。你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。你可以使用 removeEventListener() 方法来移除事件的监听。2. removeEventListener() 方法removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄 DOM3级事件是在DOM2级事件的基础上添加很多事件类型。 123456789UI事件，当用户与页面上的元素交互时触发，如：load、scroll焦点事件，当元素获得或失去焦点时触发，如：blur、focus鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel文本事件，当在文档中输入文本时触发，如：textInput键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified同时DOM3级事件也允许使用者自定义一些事件。 DOM0级 使用赋值方式绑定事件； 只能在冒泡阶段触发； 只能绑定一个事件函数； 通过置空onclick属性解绑事件； 事件函数this属性引用当前函数对象。 DOM2级 非IE方式 使用addEventListeren绑定事件； 事件名无on前缀； 使用addEventListeren第三个参数控制事件触发阶段； 可绑定多个事件函数； 多个事件函数的书法顺序和绑定顺序一样； 事件函数this属性引用当前函数对象； IE方式和非IE不同的是以下几点： 事件名带on前缀； 事件函数this属性引用全局对象； 多个事件函数的书法顺序和绑定顺序相反；]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript BOM]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-BOM%2F</url>
    <content type="text"><![CDATA[浏览器对象模型 (BOM)所有浏览器都支持 window 对象。它表示浏览器窗口。 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 Window 对象是BOM中所有对象的核心，除了是BOM中所有对象的父对象外，还包含一些窗口控制函数。 Window的子对象主要有如下几个： JavaScript document 对象 JavaScript frames 对象：可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框。 JavaScript history 对象：window.history 对象包含浏览器的历史。 history.back() - 与在浏览器点击后退按钮相同 history.forward() - 与在浏览器中点击向前按钮向前相同 JavaScript location 对象：window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。 location.hostname 返回 web 主机的域名 location.pathname 返回当前页面的路径和文件名 location.port 返回 web 主机的端口 （80 或 443） location.protocol 返回所使用的 web 协议（http:// 或 https://） JavaScript navigator 对象：window.navigator 对象包含有关访问者浏览器的信息。 123456789101112131415&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script&gt;txt = &quot;&lt;p&gt;Browser CodeName: &quot; + navigator.appCodeName + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;Browser Name: &quot; + navigator.appName + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;Browser Version: &quot; + navigator.appVersion + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;Cookies Enabled: &quot; + navigator.cookieEnabled + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;Platform: &quot; + navigator.platform + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;User-agent header: &quot; + navigator.userAgent + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;User-agent language: &quot; + navigator.systemLanguage + &quot;&lt;/p&gt;&quot;;document.getElementById(&quot;example&quot;).innerHTML=txt;&lt;/script&gt; JavaScript screen 对象：window.screen 对象包含有关用户屏幕的信息。 screen.availWidth - 可用的屏幕宽度 screen.availHeight - 可用的屏幕高度 Cookies1234567891011121314151617181920212223242526272829303132// 写入function setCookie(cname,cvalue,exdays)&#123; var d = new Date(); d.setTime(d.getTime()+(exdays*24*60*60*1000)); var expires = &quot;expires=&quot;+d.toGMTString(); document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires;&#125;// 读取function getCookie(cname)&#123; var name = cname + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;); for(var i=0; i&lt;ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name)==0) return c.substring(name.length,c.length); &#125; return &quot;&quot;;&#125;// 检测function checkCookie()&#123; var user=getCookie(&quot;username&quot;); if (user!=&quot;&quot;)&#123; alert(&quot;Welcome again &quot; + user); &#125; else &#123; user = prompt(&quot;Please enter your name:&quot;,&quot;&quot;); if (user!=&quot;&quot; &amp;&amp; user!=null) &#123; setCookie(&quot;username&quot;,user,365); &#125; &#125;&#125; 客户端检测 能力检测：识别浏览器的能力 怪癖检测：识别浏览器的特殊行为 用户代理检测： 不能直接准确地使用能力监测或怪癖检测。 同一款浏览器在不同平台下具备不同的能力。 为了跟踪分析等目的需要知道确切的浏览器。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 函数表达式]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数定义1234// 函数声明 关键字function 函数名 参数function functionName (arg0, arg1, arg2) &#123; // 函数体&#125;; 函数声明，特性：函数声明提升，就是说执行代码之前会先读取函数声明。举个例子 123456// 调用函数sayHi();// 定义函数function sayHi()&#123;&#125;; 12// 函数表达式var functuinName = function(arg0, arg1, arg2) &#123;&#125; 递归递归函数是在函数通过名字调用自身的情况下构成的。 1234567function factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num - 1); &#125;&#125; 闭包JavaScript 变量可以是局部变量或全局变量。私有变量可以用到闭包。 123456function createFunction (name)&#123; return function(object1) &#123; var value1 = object1(name) alert(value1) &#125;&#125; this对象this对象是运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。 123456789101112var name = &quot;The Window&quot;;var object = &#123; name: &quot;My object&quot;, getNameFunc: function() &#123; var that = this; // 将getNameFunc()的this保存在that变量中 var age = 15; return function() &#123; return that.name; &#125;; &#125;&#125;alert(object.getNameFunc()()); // &quot;My object&quot; 内存泄漏 闭包中引用变量消除循环引用 把element变量设置为null，这样能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。 模仿块级作用域1234567(function()&#123; for (var i = 0; i &lt; count; i++) &#123; alert(i) &#125; var i; alert(i)&#125;)(); 私有变量特权方法，有权访问私有变量和私有函数的公有方法称为特权方法。 1234567891011121314function MyObject()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction () &#123; return false; &#125; // 特权方法 this.publicMethod = function () &#123; privateVariable++; return privateFunction(); &#125;&#125; 静态私有变量1234567891011121314(function()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction () &#123; return false; &#125; // 特权方法 this.publicMethod = function () &#123; privateVariable++; return privateFunction(); &#125;&#125;)() 模块模式123456789101112131415161718var singleton = function () &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123;&#125; var object = new CustomType() // 添加特权方法/公有属性和方法 object.publicProperty = true; object.publicMethod = function () &#123; privateVariable++; return privateFunction(); &#125; return object&#125;();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 面向对象]]></title>
    <url>%2F2019%2F09%2F05%2FJavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象面向队形的语言有一个标志，那就是他们都有类的概念，而通过类可以创建多个具有相同属性和方法的对象。 1234567var person = new Object();person.name = &quot;闪电侠&quot;person.age = 18person.job = function () &#123; return this.name&#125; 属性类型分为访问器属性，数据属性 数据属性四个特性 12345678910111213var persoon = &#123; name: &apos;张三&apos;&#125;// 全局对象的属性// window.Object// 修改对象属性特性Object.defineProperty(persoon,&quot;name&quot;,&#123; // 具体特性 configurable: false, // 删除属性从而重新定义属性，能否修改属性的特性 enumerable: false, // 能否通过for-in循环返回属性 writable: true, // 能够修改属性值 value: &apos;李四&apos; // 属性数据值&#125;) 访问器属性四个特性 12345678910111213141516171819202122232425262728293031 // 定义对象var send = &#123; name: 1, // 访问器属性写法》？？ _符号 _getName: &apos;张飒&apos;, setName: &apos;李四&apos;&#125;;// 修改对象特性Object.defineProperty(send, &quot;getName&quot;,&#123; configurable: false, // 删除属性从而重新定义属性，能否修改属性的特性 enumerable: false, // 能否通过for-in循环返回属性 get: function () &#123; return this._getName // 之前this声明并没有拿到正确的函数返回值，现在试试 &#125;, //定义函数 set: function (number1) &#123; if(number1 &gt; 0)&#123; alert(this.setName) &#125; else &#123; return this.name &#125; &#125;&#125;)// 如何调用上面声明的对象特性 set写入 写入后应该是李四send.getName = 10// get读取console.log(send.getName)// 说明写入 和 读取是分开进行的 并且写入不修改原对象属性值 defineProperties() 定义多个属性特性1234567891011121314151617181920212223242526Object.defineProperties(person, &#123; // 这个时候就很明确了 name: &#123; value: &apos;张三&apos; &#125;, _job: &#123; value: 10 &#125;, job: &#123; get: function () &#123; return this._job &#125;, set: function (num) &#123; if (num &gt; 0) &#123; console.log(this.name) &#125; else &#123; return this._job &#125; &#125; &#125;&#125;);// 首先我们先看下这个对象其中一个属性的值console.log(person.name);person.job = 11;console.log(person.job); getOwnPropertyDescriptor() 读取属性特性12345678910111213141516171819202122232425262728293031var person = &#123;&#125;;Object.defineProperties(person, &#123; // 这个时候就很明确了 name: &#123; value: &apos;张三&apos; &#125;, _job: &#123; value: 10 &#125;, job: &#123; get: function () &#123; return this._job &#125;, set: function (num) &#123; if (num &gt; 0) &#123; console.log(this.name) &#125; else &#123; return this._job &#125; &#125; &#125;&#125;);// 从字面上看这个方法是获取特性// 这个方法的使用方式(对象,&quot;属性名&quot;)var getList = Object.getOwnPropertyDescriptor(person, &quot;job&quot;)// 我们来看看获取的是什么数据值console.log(getList) 工程模式与构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 工厂模型// 定义一个全局函数进行多次调用可以创建多个相同属性的对象，对象名不同，属性相同。function functionName(arg1, arg2, arg3) &#123; var list = new Object(); // 赋值 list.arg1 = arg1; list.arg2 = arg2; // 对象属性中包含函数时为什么没有直接执行？ 函数作用域 list.pushNum = function (arg3) &#123; if(arg3 === 1)&#123; return arg3; &#125; &#125; return list;&#125;var getList = functionName(&quot;张飒&quot;,&quot;李四&quot;, 1)console.log(getList)// 工厂模式解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)// 构造函数模型// 构造函数名始终以大写字母开头function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = function()&#123; return sex; &#125;&#125;var person = new Person(&quot;张三&quot;,18,&quot;2&quot;);console.log(person)// 工厂模型和构造函数模型之间的不同// 没有显式的创建对象// 直接将属性和方法赋值给this对象// 没有return语句// 1. 将构造函数当作函数// 任何函数，只要通过New操作符来调用，那它就可以构造函数，而任何函数，如果不通过New调用，那就是普通函数// 2. 构造函数问题// 构造函数的缺点，每个方法都要在实例上重新创建一遍 原型模型我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以有特定类型的所有实例共享的属性和方法。 prototype就是通过调用构造函数而创建的那个对象实例的原型对象。 优点：原型对象可以让所有对象实例共享它包含的属性和方法。 12345678910function Person() &#123;&#125;Person.prototype.name = &apos;张飒&apos;Person.prototype.age = function () &#123; return this.name&#125;// isPrototypeOf() 确认属性是否跟原型对象存在关系// hasOwnProperty() 检测一个属性是否存在于实例中// for-in操作符 组合使用构造函数和原型模式123456789101112131415161718192021// 构造函数function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;张飒&quot;, &quot;李四&quot;];&#125;// 原型模型Persoon.prototype = &#123; constructor : persoon, sayName : function()&#123; alert(this.name) &#125;&#125;var person1 = new Person(&quot;张三&quot;,10,&quot;soga&quot;);var person2 = new Person(&quot;李四&quot;,10,&quot;dou);// 数组的操作person1.friends.push(&quot;王五&quot;) 在这个代码中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的。而修改person.friends，并不影响person2.friends，因为他们分别引用不同的数组。 这种构造函数与原型混成的模式，是目前ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 动态原型模式1234567891011121314funtion Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job if(typeof this.sayName != &quot;function&quot;) &#123; Person.prototype.sayName = function () &#123; alert(this.name); &#125; &#125;&#125;var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); 寄生构造函数模式稳妥构造函数模式继承原型链ECMAScript中描述了原型链的概念，并将原型链座位实现继承的主要方法。其中思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 1234567891011121314151617181920212223242526// 函数function SuperType()&#123; this.property = true;&#125;// 函数添加一个属性SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;// 函数function SubType()&#123; this.subproperty = false;&#125;// 继承了SuperTypeSubType.prototype = new SuperType(); // true// 添加Subtype.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;var instance = new SubType();alert(instance.getSuperValue()); 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而赋值得到的副本还可以得到进一步改造。 123456789101112131415function createAnother(original)&#123; var clone = object(original); clone.sayHi = function()&#123; alert(&apos;hi&apos;); &#125;; return clone;&#125;var person = &#123; name: &quot;张飒&quot;, friends: [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。 12345678910111213141516171819function SuperType(name)&#123; this.name = name; this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;function SubType(name,age)&#123; SuperType.call(this.name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function () &#123; alert(this.age);&#125; 寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript语法]]></title>
    <url>%2F2019%2F09%2F02%2FJavaScript%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ECMAScriptECMA-262定义的ECMAScript与Web浏览器没有依赖关系。实际上，这门语言本身并不包含输入和输出定义。ECMA-262定义的只是这门语言的基础，而在此基础智商可以构建更完善的脚本语言。 ECMA-262规定了这门语言的组成部分： 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript 就是对实现该标准规定的各个方面内容的语言的描述。 文档对象模型(DOM)Document Object Model，是针对XML但经过扩展用于HTML的应用程序编程接口（API，Application Programming Interface）。 DOM级别 DOM1由两个模块组成：DOM核心（DOM Core）和 DOM HTML DOM2引入： DOM视图：定义了跟踪不同文档 DOM事件：定义了事件和事件处理的接口 DOM样式：定义了基于CSS为元素应用样式的接口 DOM遍历和范围：定义了遍历和操作文档树的接口 DOM3引入： 以统一方式加载和保存文档的方法：在DOM加载和保存模块中定义； 新增了验证文档的方法：在DOM验证模块中定义。 浏览器对象模型（BOM）支持可以访问和操作浏览器窗口的浏览器对象模型（BOM，Browser Object MOdel） JavaScriptJavaScript是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成： ECMAScript，由 ECMA-262定义，提供核心语言功能； 文档对象模型(DOM)，提供访问和操作网页内容的方法和接口； 浏览器对象模型(BOM),提供与浏览器交互的方法和接口。 &lt;script&gt;元素 &lt;script&gt;定义了6个属性： async：可选，表示应该立即下载脚本； charset：可选，表示通过src属性指定的代码的字符集； defer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行； language：可废弃； src：可选，表示包含要执行代码的外部文件； type：可选，可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型（也成为MIME类型）。 注：anync的脚本加载时并不能保证他们的先后执行顺序！ 外部文件优点： 可维护性； 可缓存； 适应未来。 语法 标识符 所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。 第一个字符必须是一个字母、下划线（_）或者一个美元符号（$）; 其他字符可以是字母、下划线、美元符号或数字。 ECMAScript标识符采用驼峰大小写格式。 严格模式 ECMAScript 5引入了严格模式的概念。严格模式是为JavaScript定义了一种不同的解析和执行模型。在严格模式下，ECMAScript3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。 use strict 关键字和保留字 关键字和保留字不能用作标识符。 数据类型5种基本数据类型：Null、Undefined、Boolean、Number、String1种复杂数据类型：Object 数值类型转换：Number()、parseInt()、parseFloat() 字符类型转换：toString()、String() 对象：Object() typeof 操作符检测给定变量的数据类型。 操作符 一元操作符 递增和递减操作符（++、–） 一元加和减操作符，正负（+、-） 位操作符 按位非~，执行按或非的结果就是返回数值的反码 按位与&amp;，按位与操作就是将两个数值的每一位对齐（具体参考真值表） 按位或|，同样也有两个操作数，按位或操作遵循（真值表） 按位异或^，也有两个操作数，按位异或操作遵循（真值表） 左移&lt;&lt;，这个操作符会将数值的所有位向左移动指定的位数 有符号的右移&gt;&gt;，这个操作符会将数值向右移动，但保留符号位（即正负号标记） 无符号右移&gt;&gt;&gt;，这个操作符会将数值的所有32位都向右移动 布尔操作符 逻辑非!，返回一个布尔值 逻辑与&amp;&amp;，返回一个布尔值 逻辑或||，返回一个布尔值 乘性操作符 乘法* 除法/ 求模(余数)% 加性操作符 加法+ 减法- 关系操作符 小于&lt; 大于&gt; 小于等于&lt;= 大于等于&gt;= 相等操作符 相等==和不相等!= 全等===和不全等!== 条件操作符 a &gt; b ? a : b 赋值操作符 = 算术操作符：（乘/赋值*=）、（除/赋值/=）、（模/赋值%=）、（加/赋值+=）、（减/赋值-=）、（左移/赋值&lt;&lt;=）、（右移/赋值&gt;&gt;=）、（无符号右移/赋值&gt;&gt;&gt;=） 逗号操作符 逗号操作多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。 语句 if语句 1234567if(条件)&#123; &#125;else if(条件)&#123;&#125;else&#123;&#125; do-while语句 123do&#123;&#125;while(条件) while语句 123while(条件)&#123;&#125; for语句 123for(var i;i&lt;length;i++)&#123;&#125; for-in语句 123for(属性 in 对象)&#123;&#125; label语句可以在代码中添加标签 加标签的语句一般都要与for语句等循环语句配合使用 break和continue语句 break立即退出循环，强制继续执行后面的语句 continue退出循环后从循环顶部继续执行 with语句 with语句的作用是将代码的作用域设置到一个特定的对象中。 switch语句 12345678910switch(表达式)&#123; case 值: 声明 break; case 值: 声明 break; default: 声明&#125; 函数123function (参数)&#123;&#125; 函数对于任何语言来说都是一个核心的概念，通过函数可以封装任意多条语句，而且可以在任何地方，任何时候调用执行。ECMAScript函数不能像传统意义上那样实现重载。 执行环境执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。 延长作用域链执行环境的类型总共只有两种-全局和局部(函数)，但还是有其他办法来延长作用域链。 try-catch语句的catch块 with语句 垃圾收集JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。 标记清除 引用计数 手工解除引用 变量 = null,解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。 引用类型 Object类型 Array类型 Date类型 RegExp类型：支持正则表达式 Function类型，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。 基本包装类型 Boolean类型 Number类型 String类型 单体内置对象 Global对象在某种意义上市座位一个终极的“兜底儿对象”来定义的。不属于任何其他对象的属性和方法，最终都是他的属性和方法。 Math对象提供了辅助完成这些计算的属性和方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP报文]]></title>
    <url>%2F2019%2F08%2F30%2FHTTP%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[HTTP 报文请求报文 HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。 规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。 123&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; HTTP 定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。 URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。 Get &amp; Post GET 用于信息获取，而且应该是安全的和幂等的。 安全的：意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 幂等的：意味着对同一 URL 的多个请求应该返回同样的结果。 GET 请求报文示例： 12345GET /books/?sex=man&amp;name=Professional HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive POST 表示可能修改变服务器上的资源的请求。 12345678POST / HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivesex=man&amp;name=Professional 注意: GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制； 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制； 参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里。 POST 提交数据的方式HTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端可以根据 Content-Type 和 Content-Encoding解析成功才有意义。 一般服务端语言都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据，包含了 Content-Type 和消息主体编码方式两部分： application/x-www-form-urlencoded 这是最常见的 POST 数据提交方式。浏览器的原生&lt;form&gt;表单，如果不设置 enctype属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。上个小节当中的例子便是使用了这种提交方式。可以看到 body 当中的内容和 GET 请求是完全相同的。 multipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 &lt;form&gt; 表单的 enctype 等于 multipart/form-data。 举个例子： 12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 &lt;form&gt;表单也只支持这两种方式（通过 &lt;form&gt;元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。 随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，例如 application/json，text/xml，乃至 application/x-protobuf 这种二进制格式。 响应报文HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 响应正文 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。 下面是一个HTTP响应的例子： 1234567HTTP/1.1 200 OKServer:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:23:42 GMTContent-Length:112&lt;html&gt;... 条件 GETHTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。 HTTP 条件 GET 使用的时机？客户端之前已经访问过某网站，并打算再次访问该网站。 HTTP 条件 GET 使用的方法？客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。 下面是一个具体的发送接受报文示例： 客户端发送请求： 1234GET / HTTP/1.1 Host: www.sina.com.cn:80 If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT Connection: Close 第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。 12345678HTTP/1.0 304 Not Modified Date: Thu, 04 Feb 2010 12:38:41 GMT Content-Type: text/html Expires: Thu, 04 Feb 2010 12:39:41 GMT Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT Age: 28 X-Cache: HIT from sy32-21.sina.com.cn Connection: close 如果服务器端资源已经更新的话，就返回正常的响应。 会话跟踪 什么是会话？ 客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。 什么是会话跟踪？ 会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。 为什么需要会话跟踪？ 浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。 会话跟踪常用的方法: URL 重写：URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。 隐藏表单域：将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示 Cookie：Cookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,客户端可以采用两种方式来保存这个 Cookie 对象，以便下次使用。一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。（Cookie 是可以被客户端禁用的。） Session：每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。 跨站攻击 CSRF（Cross-site request forgery，跨站请求伪造）CSRF(XSRF) 顾名思义，是伪造请求，冒充用户在站内的正常操作。 例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：http://example.com/bbs/create_post.php?title=标题&amp;content=内容那么，我们只需要在论坛中发一帖，包含一链接：http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。 如何防范 CSRF 攻击？可以注意以下几点： 关键操作只接受 POST 请求 验证码 CSRF 攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。 但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。 检测 Referer 常见的互联网页面与页面之间是存在联系的，比如你在www.baidu.com 应该是找不到通往www.google.com的链接的，再比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 Referer 中。通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。 Token 目前主流的做法是使用 Token 抵御 CSRF 攻击。下面通过分析 CSRF 攻击来理解为什么 Token 能够有效CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击。 另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的。这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击。 Token 使用原则： Token 要足够随机————只有这样才算不可预测 Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度 Token 要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中 注意：过滤用户输入的内容不能阻挡 csrf，我们需要做的是过滤请求的来源。 XSS（Cross Site Scripting，跨站脚本攻击）XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。 运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口： 123while (true) &#123; alert(&quot;你关不掉我~&quot;);&#125; 也可以是盗号或者其他未授权的操作。 XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。 如何防御 XSS 攻击？理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于 script。防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。 如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML escape 。下面一小段脚本： &lt;script&gt;window.location.href=”http://www.baidu.com”;&lt;/script&gt; 经过 escape 之后就成了： &amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.baidu.com&amp;quot;&amp;lt;/script&amp;gt; 它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。 当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。更好的方法可能是，将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。 参考资料： https://hit-alibaba.github.io/interview/basic/network/HTTP.html]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP/HTTPS协议]]></title>
    <url>%2F2019%2F08%2F30%2FHTTP-HTTPS%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP状态码 1xx（临时响应） 2xx（成功）：表示成功处理了请求的状态码。 3xx（重定向）：要完成请求，需要进一步操作。通常，这些状态码用来重定向。建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。 4xx（请求错误）：这些状态码表示请求可能出错，妨碍了服务器的处理。 5xx（服务器错误）：这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 状态码列表 状态码 描述 100（继续） 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 200（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对robots.txt文件显示此状态码，则表示已成功检索到该文件。 201（已创建） 请求成功并且服务器创建了新的资源。 202（已接受） 服务器已接受请求，但尚未处理。 203（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容） 服务器成功处理了请求，但没有返回任何内容。 205（重置内容） 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 206（部分内容） 服务器成功处理了部分 GET 请求。 300（多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 302（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 303（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304（未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 &lt;a href=answer.py?answer=&gt;301&lt;/a&gt; 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 400（错误请求） 服务器不理解请求的语法。 401（未授权） 请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止） 服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到） 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。 405（方法禁用） 禁用请求中指定的方法。 406（不接受） 无法使用请求的内容特性响应请求的网页。 407（需要代理授权） 此状态码与 &lt;a href=answer.py?answer=35128&gt;401（未授权）&lt;/a&gt;类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时） 服务器等候请求时发生超时。 409（冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除） 如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 411（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型） 请求的格式不受请求页面的支持。 416（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态码。 417（未满足期望值） 服务器未满足”期望”请求标头字段的要求。 500（服务器内部错误） 服务器遇到错误，无法完成请求。 501（尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 作用域访问对象 对象名称 描述 PageScope 与页面作用域page中的属性相关的Map类 requestScope 与请求作用域request中的属性相关的Map类 sessionScope 与会话作用域session中的属性相关的Map类 applicationScope 与应用程序作用域application中的属性相关的Map类 参数访问的对象 对象名称 描述 Param 按照参数名称访问单一请求的Map对象 paramValues 按照参数名称访问数组请求的Map对象 Jsp隐式对象 对象名称 描述 PageContext 提供页面信息的内置对象的访问]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议]]></title>
    <url>%2F2019%2F08%2F30%2FTCP-IP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。 TCP/IP协议的优点 TCP/IP协议不依赖于任何特定的计算机硬件或操作系统，提供开放的协议标准，即使不考虑Internet，TCP/IP协议也获得了广泛的支持。所以TCP/IP协议成为一种联合各种硬件和软件的实用系统。 TCP/IP协议并不依赖于特定的网络传输硬件，所以TCP/IP协议能够集成各种各样的网络。用户能够使用以太网（Ethernet）、令牌环网（Token Ring Network）、拨号线路（Dial-up line）、X.25网以及所有的网络传输硬件。 统一的网络地址分配方案，使得整个TCP/IP设备在网中都具有惟一的地址 标准化的高层协议，可以提供多种可靠的用户服务。 TCP/IP协议的缺点 在服务、接口与协议的区别上就不是很清楚。一个好的软件工程应该将功能与实现方法区分开来，TCP/IP恰恰没有很好地做到这点，就使得TCP/IP参考模型对于使用新的技术的指导意义是不够的。TCP/IP参考模型不适合于其他非TCP/IP协议簇。 主机-网络层（网络接口层）本身并不是实际的一层，它定义了网络层与数据链路层的接口。物理层与数据链路层的划分是必要和合理的，一个好的参考模型应该将它们区分开，而TCP/IP参考模型却没有做到这点。 TCP传输的三次握手为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。 用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。 握手过程中使用了TCP的标志：SYN和ACK。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 PS：若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 断开TCP连接的四次挥手 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 为什么连接的时候是三次握手，关闭的时候却是四次挥手？因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP]]></title>
    <url>%2F2019%2F08%2F30%2FTCP-IP%2F</url>
    <content type="text"><![CDATA[应用层（Application Layer）应用层(Application Layer)包含所有的高层协议。 应用层是所有用户所面向的应用程序的统称。ICP/IP协议族在这一层面有着很多协议来支持不同的应用，如我们进行万维网（WWW）访问用到了HTTP协议、DNS用于把主机名映射到网络地址、文件传输用FTP协议、电子邮件发送用SMTP、域名的解析用DNS协议、 远程登录用Telnet协议等等，都是属于TCP/IP应用层的. NNTP用于新闻的发布、检索和获取； 包括：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。 简单说来：应用层是应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。 TCP/IP 是用于因特网 (Internet) 的通信协议。通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。 TCP/IP 是供已连接因特网的计算机进行通信的通信协议。 TCP/IP 指传输控制协议/网际协议 (Transmission Control Protocol / Internet Protocol)。 TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。 TCP/IP 中包含一系列用于处理数据通信的协议： TCP (传输控制协议) - 应用程序之间通信 UDP (用户数据包协议) - 应用程序之间的简单通信 IP (网际协议) - 计算机之间的通信 ICMP (因特网消息控制协议) - 针对错误和状态 DHCP (动态主机配置协议) - 针对动态寻址 TCP 用于应用程序之间的通信。当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。 这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。 UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。 IP 用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。 通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。 IP 负责将每个包路由至它的目的地。 TCP/IPTCP/IP 意味着 TCP 和 IP 在一起协同工作。 TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。 IP 负责计算机之间的通信。 TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。 IP 负责将包发送至接受者。 HTTP - 超文本传输协议HTTP 负责 web 服务器与 web 浏览器之间的通信。 HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。 HTTPS - 安全的 HTTPHTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。 作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。 SSL - 安全套接字层SSL 协议用于为安全数据传输加密数据。 SMTP - 简易邮件传输协议SMTP 用于电子邮件的传输。 SMTP 协议用于传输电子邮件。SMTP 负责把邮件发送到另一台计算机。 通常情况下，邮件会被送到一台邮件服务器（SMTP 服务器），然后被送到另一台（或几台）服务器，然后最终被送到它的目的地。 SMTP 也可以传送纯文本，但是无法传输诸如图片、声音或者电影之类的二进制数据。 SMTP 使用 MIME 协议通过 TCP/IP 网络来发送二进制数据。MIME 协议会将二进制数据转换为纯文本。 MIME - 多用途因特网邮件扩展MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。 IMAP - 因特网消息访问协议IMAP 用于存储和取回电子邮件。 与 POP 类似，IMAP 协议同样被邮件程序使用。 IMAP 协议与 POP 协议之间的主要差异是：如果 IMAP 连上了邮件服务器，它不会自动地将邮件下载到邮件程序之中。 IMAP 使你有能力在下载邮件之前先通过邮件服务器端查看他们。通过 IMAP，你可以选择下载这些邮件或者仅仅是删除它们。比方说你需要从不同的位置访问邮件服务器，但是仅仅希望回到办公室的时候再下载邮件，IMAP 在这种情况下会很有用。 POP - 邮局协议POP 用于从电子邮件服务器向个人电脑下载电子邮件。 POP 协议被邮件程序用来取回邮件服务器上面的邮件。 假如你的邮件程序使用 POP，那么一旦它连接上邮件服务器，你的所有的邮件都会被下载到邮件程序中（或者称之为邮件客户端）。 FTP - 文件传输协议FTP 负责计算机之间的文件传输。 NTP - 网络时间协议NTP 用于在计算机之间同步时间（钟）。 DHCP - 动态主机配置协议DHCP 用于向网络中的计算机分配动态 IP 地址。 SNMP - 简单网络管理协议SNMP 用于计算机网络的管理。 LDAP - 轻量级的目录访问协议LDAP 用于从因特网搜集关于用户和电子邮件地址的信息。 ICMP - 因特网消息控制协议ICMP 负责网络中的错误处理。 ARP - Address Resolution ProtocolARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。 RARP - Reverse Address Resolution ProtocolRARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。 BOOTP - Boot ProtocolBOOTP 用于从网络启动计算机。 PPTP - 点对点隧道协议PPTP 用于私人网络之间的连接（隧道）。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS @media媒体查询]]></title>
    <url>%2F2019%2F08%2F30%2FCSS-media%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[语法1234//语法：@media mediatype and | not | only (media feature) &#123; css-code; &#125;//也可以针对不同的媒体使用不同的stylesheets: &lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet.css&quot;&gt; 标签&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 标签中引入（CSS2 media）123&lt;link rel=&quot;stylesheet&quot; href=&quot;styleA.css&quot; media=&quot;screen&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styleB.css&quot; media=&quot;screen and (max-width: 800px)&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styleC.css&quot; media=&quot;screen and (max-width: 600px)&quot;&gt; 但是上面这个方法，最大的弊端是他会增加页面http的请求次数，增加了页面负担，我们用CSS3把样式都写在一个文件里面才是最佳的方法。 CSS3 @media1234567891011121314// 等于960px尺寸的代码，以下代码需要写在style标签或者css文件中：@media screen and (max-device-width:960px)&#123; body&#123;background:red;&#125;&#125;// 当浏览器尺寸大于960px时候的代码了：@media screen and (min-width:960px)&#123; body&#123;background:orange;&#125;&#125;// 混合使用上面的用法：@media screen and (min-width:960px) and (max-width:1200px)&#123; body&#123;background:yellow;&#125;&#125; Media所有参数汇总以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释： width:浏览器可视宽度。 height:浏览器可视高度。 device-width:设备屏幕的宽度。 device-height:设备屏幕的高度。 orientation:检测设备目前处于横向还是纵向状态。 aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio:检测设备的宽度和高度的比例。 color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色） color-index:检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid:检测输出的设备是网格的还是位图设备。 媒体类型 all 所有媒体 braille 盲文触觉设备 embossed 盲文打印机 print 手持设备 projection 打印预览 screen 彩屏设备 speech ‘听觉’类似的媒体类型 tty 不适用像素的设备 tv 电视 关键字 and not not关键字是用来排除某种制定的媒体类型 only only用来定某种特定的媒体类型 -很多时候是用来对那些不支持媒体特性但却支持媒体类型的设备 常用的几种屏幕宽度设定：123456789101112131415@media screen and (min-width: 1200px) &#123; css-code;&#125;@media screen and(min-width: 960px) and (max-width: 1199px) &#123; css-code;&#125;@media screen and(min-width: 768px) and (max-width: 959px) &#123; css-code;&#125;@media screen and(min-width: 480px) and (max-width: 767px) &#123; css-code;&#125;@media screen and (max-width: 479px) &#123; css-code;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 渐变]]></title>
    <url>%2F2019%2F08%2F30%2FCSS3-%E6%B8%90%E5%8F%98%2F</url>
    <content type="text"><![CDATA[CSS3 线性渐变CSS3 Gradient 分为 linear-gradient（线性渐变）和 radial-gradient（径向渐变）。 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向 径向渐变（Radial Gradients）- 由它们的中心定义 语法 background: linear-gradient(direction, color-stop1, color-stop2, ...); 线性渐变 - 从上到下（默认情况下） 123456#grad &#123; background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, blue); /* 标准的语法 */&#125; 线性渐变 - 从左到右 123456#grad &#123; background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to right, red , blue); /* 标准的语法 */&#125; 线性渐变 - 对角 123456#grad &#123; background: -webkit-linear-gradient(left top, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(bottom right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to bottom right, red , blue); /* 标准的语法 */&#125; 使用角度 background: linear-gradient(angle, color-stop1, color-stop2); 123456#grad &#123; background: -webkit-linear-gradient(180deg, red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(180deg, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(180deg, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(180deg, red, blue); /* 标准的语法 */&#125; 使用多个颜色结点 123456#grad &#123; background: -webkit-linear-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, green, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, green, blue); /* 标准的语法 */&#125; 使用透明度（transparent） 123456#grad &#123; background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); /* Safari 5.1 - 6 */ background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Opera 11.1 - 12*/ background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Firefox 3.6 - 15*/ background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法 */&#125; 重复的线性渐变 repeating-linear-gradient() 函数用于重复线性渐变： 12345678910#grad &#123; /* Safari 5.1 - 6.0 */ background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%); /* Opera 11.1 - 12.0 */ background: -o-repeating-linear-gradient(red, yellow 10%, green 20%); /* Firefox 3.6 - 15 */ background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%); /* 标准的语法 */ background: repeating-linear-gradient(red, yellow 10%, green 20%);&#125; CSS3 径向渐变为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。 background: radial-gradient(center, shape size, start-color, ..., last-color); 径向渐变 - 颜色结点均匀分布（默认情况下） 123456#grad &#123; background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: radial-gradient(red, green, blue); /* 标准的语法 */&#125; 径向渐变 - 颜色结点不均匀分布 123456#grad &#123; background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */ background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */&#125; 设置形状 shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。 不同尺寸大小关键字的使用 size 参数定义了渐变的大小。它可以是以下四个值： closest-side farthest-side closest-corner farthest-corner 重复的径向渐变 repeating-radial-gradient() 函数用于重复径向渐变]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 动画原理]]></title>
    <url>%2F2019%2F08%2F29%2FCSS3-%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[2D/3D 旋转动画的概念：https://zhuanlan.zhihu.com/p/19855108 1234567891011121314151617181920212223242526272829div &#123; /* background-image: -webkit-linear-gradient(92deg,#f35626,#feab3a); */ width: 10px; height: 100px; margin: 0 auto; text-align: center; color: rgba(0, 0, 0, 0); background-color: #f35626; background-clip: text; /* -webkit-text-fill-color:transparent; */&#125;div:hover &#123; height: 300px; width: 600px; text-align: center; background-color: wheat; color: rgb(66, 66, 66); /* transition: 2s height ease, 2s background-color linear, 2s 2s width ease-in, 4s 4s color; */ /** 只对block级元素生效 */ /** 动画持续时长 */ transition-duration: 2s,2s,2s,4s; /** 动画渐变的属性 */ transition-property: height, background-color, width, color; /** 延迟播放动画 */ transition-delay: 0s,0s,2s,4s; /** 动画过渡函数 */ transition-timing-function: ease,linear,ease-in,normal;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html &#123; font-size: 14px; &#125; .flex &#123; position: fixed; width: 100%; height: 100%; display: flex; flex-direction: row; flex-wrap: wrap; align-items: center; align-content: center; justify-content: center; overflow: hidden; &#125; .box &#123; width: 100px; height: 100px; border: 1px solid black; background-color: #fff; /* 2D属性 translate移动(x,y) scale缩放(x,y) rotate角度(deg) skew倾斜转换(deg,deg)*/ transform: translate(20px,20px) scale(1.1,1.2) rotate(20deg) skew(20deg,40deg); -webkit-transform: translate(20px,20px) scale(1.1,1.2) rotate(20deg) skew(20deg,40deg); /* 设置旋转元素的基点位置 */ transform-origin: 10% 20%; -webkit-transform-origin: 10% 20%; /* 效果开始时间 */ transition-delay: 1s; /* 效果持续时间 */ transition-duration: 3s; /* 持续时间效果 */ transition-timing-function: cubic-bezier(0.075, 0.82, 0.165, 1); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 弹性盒子 --&gt; &lt;div class=&quot;flex&quot;&gt; &lt;!-- 绝对居中 --&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3D效果直接在属性后面添加3d，属性值相对性变成(x,y,z)三维坐标 3D加速 适用情况 通过-webkit-transform:transition3d/translateZ开启GPU硬件加速的适用范围： 使用很多大尺寸图片(尤其是PNG24图)进行动画的页面。 页面有很多大尺寸图片并且进行了css缩放处理，页面可以滚动时。 使用background-size:cover设置大尺寸背景图，并且页面可以滚动时。 编写大量DOM元素进行CSS3动画时(transition/transform/keyframes/absTop&amp;Left) 使用很多PNG图片拼接成CSS Sprite时 CSS3动画与关键帧 Animation &amp; @keyframes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html &#123; font-size: 14px; &#125; .flex &#123; position: fixed; width: 100%; height: 100%; display: flex; flex-direction: row; flex-wrap: wrap; align-items: center; align-content: center; justify-content: center; overflow: hidden; &#125; .box &#123; position: relative; width: 100px; height: 100px; border: 1px solid transparent; background-color: #000; /* 开启3D加速 */ transform: translate3d(0, 0, 0); /* 动画名称 */ animation-name: do; /* 动画持续时间 */ animation-duration: 5s; /* 动画开始时间 */ /* animation-delay: 1s; */ /* 动画播放次数 */ animation-iteration-count: infinite; /* 动画播放速率 */ animation-timing-function:cubic-bezier(0.755, 0.05, 0.855, 0.06); /* 动画是否保留属性值 */ animation-fill-mode: forwards; &#125; /* 关键帧 */ @keyframes do &#123; 10% &#123; border-radius: 10%; &#125; 20% &#123; border-radius: 20%; transform: rotate(30deg); &#125; 30% &#123; border-radius: 30%; transform: rotate(90deg); &#125; 40% &#123; border-radius: 40%; transform: rotate(180deg); &#125; 50% &#123; border-radius: 50%; &#125; 60% &#123; border-radius: 40%; transform: rotate(180deg); &#125; 70% &#123; border-radius: 30%; transform: rotate(90deg); &#125; 80% &#123; border-radius: 20%; transform: rotate(30deg); &#125; 90% &#123; border-radius: 10%; &#125; 100% &#123; border-radius: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 弹性盒子 --&gt; &lt;div class=&quot;flex&quot;&gt; &lt;!-- 绝对居中 --&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;turn&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116* &#123; padding: 0; margin: 0;&#125;body&#123; background: rgb(17, 75, 122); color: #fff;&#125;.box&#123; text-align: center;&#125;.title&#123; position: relative; top: -45px; animation-name: title; animation-delay: 1s; animation-duration: 3s; animation-timing-function: ease-in-out; animation-fill-mode: forwards;&#125;@keyframes title&#123; 0%&#123; top: -45px; &#125; 100%&#123; top: 200px; &#125;&#125;.content&#123; max-width: 960px; margin: auto; padding: 30px; position: relative; top: 200px; left: -100%; text-align: left; font-size: 14px; line-height: 2; text-indent: 24px; animation-name: content; animation-delay: 2s; animation-duration: 3s; animation-timing-function: linear; animation-fill-mode: forwards;&#125;@keyframes content&#123; 0% &#123; left: -100%; &#125; 100% &#123; left: 0; &#125;&#125;.btn&#123; position: relative; top: 220px; display: inline-block; font-size: 14px; text-indent: 0; line-height: 2; padding: 0.5rem 1rem; border: 1px solid #fff; text-decoration: none; color: #fff; opacity: 0; animation-name: btn; animation-delay: 5s; animation-duration: 2s; animation-timing-function: linear; animation-fill-mode: forwards; transition-property: transform; transition-duration: 2s; transition-timing-function: linear;&#125;.btn:hover&#123; transform: rotateY(180deg);&#125;@keyframes btn&#123; 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;&#125;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/transitions.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;h1 id=&quot;title&quot; class=&quot;title&quot;&gt;Welcome to page&lt;/h1&gt; &lt;div id=&quot;content&quot; class=&quot;content&quot;&gt; 《哈姆雷特》（英语：Hamlet）又名《王子复仇记》，是莎士比亚于1599年至1602年间的一部悲剧作品，是他最负盛名和被人引用最多的剧本。习惯上将本剧与《麦克白》、《李尔王》和《奥赛罗》一起，并称为莎士比亚的“四大悲剧”。 戏剧中叔叔克劳迪谋害了哈姆雷特国王，篡了王位，并娶了国王的遗孀葛簇特；王子哈姆雷特因此为父王之死向叔叔复仇。剧本细致入微地刻画了伪装的、真实的疯癫 —— 从悲痛欲绝到假装愤怒 —— 探索了背叛、复仇、乱伦、堕落等主题。 &lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;btn&quot;&gt;Read More&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 盒模型]]></title>
    <url>%2F2019%2F08%2F29%2FCSS3-%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[CSS盒模型所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。 CSS盒模型本质上是一个盒子，它包括：边距，边框，填充，和实际内容。 盒子模型(Box Model)： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;!-- Margin(外边距) - 清除边框外的区域，外边距是透明的。（margin的长度是允许出现负值的）注意：当以百分比来设置长度时，不管是宽度还是高度，都是按照父元素的宽度百分比计算的（即便是计算上下外边距也是按照父元素的宽度百分比计算的） --&gt; &lt;div class=&quot;margin&quot;&gt; &lt;!-- Border(边框) - 围绕在内边距和内容外的边框。 --&gt; &lt;div class=&quot;border&quot;&gt; &lt;!-- Padding(内边距) - 清除内容周围的区域，内边距是透明的。（padding的长度是不允许出现负值的）和margin一样，当以百分比来设置长度时，不管是宽度还是高度，都是按照父元素的宽度百分比计算的。 --&gt; &lt;div class=&quot;padding&quot;&gt; &lt;!-- Content(内容) - 盒子的内容，显示文本和图像。 --&gt; &lt;div class=&quot;content&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局圣杯布局和双飞翼布局达到的效果基本相同，都是侧边两栏宽度固定，中间栏宽度自适应。 主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样，圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现，而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。 双飞翼布局要求 header和footer各自占领屏幕所有宽度，高度固定。 中间的container是一个三栏布局。 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。 布局实现 left、center、right三种都设置左浮动 设置center宽度为100% 设置负边距，left设置负边距为100%，right设置负边距为自身宽度 设置content的margin值为左右两个侧栏留出空间，margin值大小为left和right宽度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;style&gt; body &#123; min-width: 550px; font-weight: bold; font-size: 20px; &#125; #header, #footer &#123; background: rgba(29, 27, 27, 0.726); text-align: center; height: 60px; line-height: 60px; &#125; #container &#123; overflow: hidden; &#125; .column &#123; text-align: center; height: 300px; line-height: 300px; &#125; #left, #right, #center &#123; float: left; &#125; #center &#123; width: 100%; background: rgb(206, 201, 201); &#125; #left &#123; width: 200px; margin-left: -100%; background: rgba(95, 179, 235, 0.972); &#125; #right &#123; width: 150px; margin-left: -150px; background: rgb(231, 105, 2); &#125; .content &#123; margin: 0 150px 0 200px; &#125;&lt;/style&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt;#header&lt;/div&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt; &lt;div class=&quot;content&quot;&gt;#center&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt;&lt;/body&gt; CSS3 弹性盒子模型(Flex Box Model)弹性盒子是 CSS3 的一种新的布局模式。 CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。 引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。 属性 描述 flex-direction 指定弹性容器中子元素排列方式 flex-wrap 设置弹性盒子的子元素超出父容器时是否换行 flex-flow flex-direction 和 flex-wrap 的简写 align-items 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式 align-content 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 justify-content 设置弹性盒子元素在主轴（横轴）方向上的对齐方式 flex-direction 属性： 决定项目的方向。注意：如果元素不是弹性盒对象的元素，则 flex-direction 属性不起作用。 row 默认值。元素将水平显示，正如一个行一样。 row-reverse 与 row 相同，但是以相反的顺序。 column 元素将垂直显示，正如一个列一样。 column-reverse 与 column 相同，但是以相反的顺序。 flex-wrap 属性： flex-wrap 属性规定flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。 nowrap 默认值。规定元素不拆行或不拆列。 wrap 规定元素在必要的时候拆行或拆列。 wrap-reverse 规定元素在必要的时候拆行或拆列，但是以相反的顺序。 flex-flow 属性： flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; display: flex; height: 100px; background-color: black; flex-direction: row; flex-wrap: wrap; align-items: center; justify-content: space-between; &#125; .item &#123; background-color: blanchedalmond; color: blueviolet; font-size: 14px; width: 40px; height: 40px; text-align: center; line-height: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot; style=&quot;order: 10&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex-grow: 0.3&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex-shrink: 8&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex-basis: 20px&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex:0.3 1 10px&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;align-self:flex-start&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;7&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; align-items属性： align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。 stretch 默认值。项目被拉伸以适应容器。 center 项目位于容器的中心。 flex-start 项目位于容器的开头。 flex-end 项目位于容器的结尾。 baseline 项目位于容器的基线上。 justify-content属性 justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。 flex-start 默认值。项目位于容器的开头。 flex-end 项目位于容器的结尾。 center 项目位于容器的中心。 space-between 项目位于各行之间留有空白的容器内。 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 弹性子元素属性 order 设置弹性盒子的子元素排列顺序。 flex-grow 设置或检索弹性盒子元素的扩展比率。 flex-shrink 指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。 flex-basis 用于设置或检索弹性盒伸缩基准值。 flex 设置弹性盒子的子元素如何分配空间。 align-self 在弹性子元素上使用。覆盖容器的 align-items 属性。 FCFC的全称是：Formatting Contexts，是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 BFC(Block Formatting Contexts)意为“块级格式化上下文”。就是页面上的一个渲染区域，容器内的子元素不会对外面的元素布局产生影响，反之亦然。 BFC的布局规则: 内部的盒子会在垂直方向，一个个地放置 盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此 BFC的区域不会与float重叠 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此 计算BFC的高度时，浮动元素也参与计算 如何生成BFC： 根元素或其它包含它的元素 float的值不为none overflow的值不为visible position的值不为relative和static display的值为table-cell,table-caption和inline-block中的任何一个 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 块格式化上下文对于定位与清除浮动很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 IFC(Inline Formatting Contexts)意为“内联格式化上下文”,IFC中，盒子依次水平放置，从包含块的顶部开始 FFC(Flex Formatting Contexts)意为“自适应格式化上下文”,display值为flex或者inline-flex的元素将会生成自适应容器。flex box由伸缩容器和伸缩子元素组成。通过设置元素display:flex/inline-flex可以得到伸缩容器，前者为块级元素，后者为行内元素。伸缩容器外元素不受影响。 GFC(GridLayout Formatting Contexts)意为“网格布局格式化上下文”当一个元素设置为display:grid的时候，此元素将获得一个独立的渲染区域，可以在网格容器上定义网格行和列，为每一个网格定义位置和空间。GFC和table的区别在于GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础]]></title>
    <url>%2F2019%2F08%2F28%2FCSS-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[CSS基础知识CSS 指层叠样式表 (Cascading Style Sheets)，是一种用来表现 HTML 文档样式的语言，样式定义如何显示 HTML 元素，是能够真正做到网页表现与结构分离的一种样式设计语言。 外部样式表可以极大提高工作效率 外部样式表通常存储在CSS文件中 多个样式定义可层叠为一 层叠次序 浏览器缺省设置 外部样式表 内部样式表(位于&lt;head&gt;标签内部) 内联样式表(在HTML元素内部) 选择器优先级 内联样式的权重为1000 ID选择器的权重为100 类选择器的权重为10 元素选择器的权重为1 权重计算永不进位 CSS语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器的分组，用都好将需要分组的选择器分开 集成及其问题，子元素从父元素继承属性有些浏览器不支持其继承，可以用组选择器 !important定义和用法提升指定样式规则的应用优先权。 div{color:#f00!important;color:#000;} comment定义和用法/* 这里是注释内容 */ @import定义和用法指定导入的外部样式表及目标媒体。 &lt;url&gt;：使用绝对或相对地址指定导入的外部样式表文件。可以是url(url)或者直接是一个url &lt;media_query_list&gt;：指定媒体类型和查询条件。 123@import url(example.css) screen and (min-width:800px);@import url(example.css) screen and (width:800px),(color);@import url(example.css) screen and (min-device-width:500px) and (max-device-width:1024px); @charset定义和用法在外部样式表文件内使用。指定该样式表使用的字符编码。 &lt;charset&gt;：字符编码。如：@charset “utf-8”; @media定义和用法指定样式表规则用于指定的媒体类型和查询条件 媒体类型 描述 all 所有浏览器-用于所有媒体设备类型 aural Opera-用于语音和音乐合成器 braille Opera-用于触觉反馈设备 handheld Chrome,Safari,Opera-用于小型或手持设备 print 所有浏览器-用于打印机 projection Opera-用于投影图像，如幻灯片 screen 所有浏览器-用于计算机显示器 tty Opera-用于使用固定间距字符格的设备。如电传打字机和终端 tv Opera-用于电视类设备 embossed Opera-用于凸点字符（盲文）印刷设备 123456789@media all and (width:1024px)&#123; body&#123;color:#f00;&#125;&#125;@media all and (device-height:800px)&#123; … &#125;@media all and (orientation:landscape)&#123; … &#125;@media all and (device-aspect-ratio:16/10)&#123; … &#125;@media all and (min-color:1)&#123; … &#125;@media all and (monochrome:0)&#123; … &#125;@media all and (grid:0)&#123; … &#125; @font-face定义和用法设置嵌入HTML文档的字体。 &lt;identifier&gt;：字体名称 &lt;url&gt;：此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径 &lt;string&gt;：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype, opentype，embedded-opentype, svg等 &lt;font&gt;：定义字体相关样式 12345678@font-face &#123; font-family: &apos;diyfont&apos;; src: url(&apos;diyfont.eot&apos;); /* IE9+ */ src: url(&apos;diyfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;diyfont.woff&apos;) format(&apos;woff&apos;), /* chrome、firefox */ url(&apos;diyfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url(&apos;diyfont.svg#fontname&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125; @page定义和用法设置页面容器的版式，方向，边空等。 &lt;label&gt;：页面标识符 &lt;pseudo-class&gt;：打印伪类:first, :left, :right @page:first{margin:300px;} @keyframes定义和用法指定动画名称和动画效果。@keyframes定义的动画名称用来被animation-name所使用。定义动画时，简单的动画可以直接使用关键字from和to，即从一种状态过渡到另一种状态： 12345678@keyframes testanimations&#123; 0%&#123;transform:translate(0,0);&#125; 20%&#123;transform:translate(20,20);&#125; 40%&#123;transform:translate(40,0);&#125; 60%&#123;transform:translate(60,20);&#125; 80%&#123;transform:translate(80,0);&#125; 100%&#123;transform:translate(100,20);&#125;&#125; CSS 函数 名称 描述 counter() 插入计数器，counter()只能被使用在content属性上。li:before{counter-increment:item;content:counter(item)&quot;.&quot;;color:#f00;} attr() 插入元素的属性值。div{width:attr(width, px, auto);} calc() 用于动态计算长度值。任何长度值都可以使用calc()函数进行计算。calc()函数支持+, -, *, /, mod运算，以后还可能加入对min()/max()等运算。.test{width:-moz-calc(100% - 50px);width:calc(100% - 50px);background:#eee;} min() 用于比较数值的大小并取出最小的那个。div{width:min(10% + 20px, 300px);} max() 用于比较数值的大小并取出最大的那个。div{width:max(10% + 20px, 300px);} cycle() 允许子孙元素使用取值序列中的值循环替换继承而来的值。li &gt; ul{list-style-type:toggle(disk,circle,square,box);} Image 属性 描述 linear-gradient() 用线性渐变创建图像。 radial-gradient() 用径向渐变创建图像。 repeating-linear-gradient() 用重复的线性渐变创建图像。 repeating-radial-gradient() 用重复的径向渐变创建图像。 CSS单位CSS 的单位对于 CSS 的值有是一个直接影响的。因为 CSS 的单位直接对 CSS 的值的计算是有直接影响的，在 CSS 中单位的之间有一个关系如下所示： 单位 描述 角度单位&lt;angle&gt; deg：度grad：梯度rad：弧度turn：圈 字体单位&lt;length&gt; em：相对于父元素rem：相对于根元素ch：数字“0”的宽度ex：相对长度单位。相对于字符“x”的高度。通常为字体高度的一半。 频率单位&lt;frequency&gt; Hz：赫兹KHz：千赫兹 整数单位&lt;length&gt; px：相对长度单位，像素 长度单位&lt;length&gt; cm：厘米（Centimeters）。绝对长度单位。mm：毫米（Millimeters）。绝对长度单位。in：英寸（Inches）。绝对长度单位。pt：点（Points）。绝对长度单位。pc：派卡（Picas）。绝对长度单位。相当于我国新四号铅字的尺寸。px：相对长度单位。像素（Pixels）。 百分比单位 %：百分比 分辨率单位&lt;resolution&gt; dpi：每英寸包含点的数量（dots per inch）普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx），打印时一般会需要更大的dpi；dpcm：每厘米包含点的数量（dots per centimeter）dppx：每像素包含点的数量（dots per pixel） 时间单位&lt;time&gt; s:秒ms:毫秒 视窗单位&lt;length&gt; vw：相对于视口的宽度。视口被均分为100单位的vwvh：相对于视口的高度。视口被均分为100单位的vhvmax：相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmaxvmin：相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin 单位 描述 相对单位 字体相对单位：em、rem、ch、ex视窗相对单位：vw、vh、vmax、vmin 绝对单位 px、pt、pc、cm、mm、in 角度单位 deg、grad、rad、turn 时间单位 s、ms 分辨率单位 dpi、dpcm、dppx 频率单位 Hz、KHz 绝对单位不受任何屏幕大小或字体的影响。这些单位的显示可能会根据不同的屏幕分辨率而有所不同，因为它们取决于屏幕的DPI（每英寸上的点数）。绝对单位常用于一些物理测量上。在环境输出已知的情形下非常有用。 分辨率术语 术语 描述 720P 1280*720-称为：HD，中文译为“高清” 1080P 1920*1080-称为：FULL HD，中文称为“全高清” 1440P 2560*1440-称为：QHD或Quad HD,即4倍的HD 2160P 3840*2160-称为：4K 4320P 7680*4320-称为：8K 参考地址：https://www.w3cplus.com/css/css-values-and-units.html 颜色值 属性 描述 HEX 颜色值十六进制(HEX)表示,语法如：#rrggbb或#rgb RGB RGB表示方式，语法如：rgb(128,128,128) RGBA 颜色值RGBA表示方式，语法如：rgba(128,128,128,0.5) HSL 颜色值HSL表示方式，HSL(Hue-色调,Saturation-饱和度,Lightness-亮度) HSLA 颜色值HSLA表示方式，HSL(Hue-色调,Saturation-饱和度,Lightness-亮度,Alpha-透明度)语法如：hsla(360,50%,50%,0.5) Transparent 颜色值透明(Transparent)表示方式(RGBA) 元素选择符 选择符 描述 通配选择符* 选定所有对象。 类型选择符E 以文档语言对象类型作为选择符。 ID选择符E#ID 以唯一标识符id属性等于myid的E对象作为选择符。 类选择符E.Class 以class属性包含myclass的E对象作为选择符。 关系选择符 选择符 描述 包含选择符E F 选择所有被E元素包含的F元素。 子选择符E&gt;F 选择所有作为E元素的子元素F。 相邻选择符E+F 选择紧贴在E元素之后F元素。 兄弟选择符E~F 选择E元素后面的所有兄弟元素F。 属性选择符 选择符 描述 E[att] 选择具有att属性的E元素。 E[att=&quot;val&quot;] 选择具有att属性且属性值等于val的E元素。 E[att~=&quot;val&quot;] 选择具有att属性且属性值为一用空格分隔的字词列表，其中一个等于val的E元素。 E[att^=&quot;val&quot;] 选择具有att属性且属性值为以val开头的字符串的E元素。 E[att$=&quot;val&quot;] 选择具有att属性且属性值为以val结尾的字符串的E元素。 E[att*=&quot;val&quot;] 选择具有att属性且属性值为包含val的字符串的E元素。 ```E[att =”val”]``` 伪类选择符 选择符 描述 E:link 设置超链接a在未被访问前的样式。 E:visited 设置超链接a在其链接地址已被访问过时的样式。 E:hover 设置元素在其鼠标悬停时的样式。 E:active 设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 E:focus 设置元素在成为输入焦点（该元素的onfocus事件发生）时的样式。 E:lang(fr) 匹配使用特殊语言的E元素。 E:not(s) 匹配不含有s选择符的元素E。 E:root 匹配E元素在文档的根元素。 E:first-child 匹配父元素的第一个子元素E。 E:last-child 匹配父元素的最后一个子元素E。 E:only-child 匹配父元素仅有的一个子元素E。 E:nth-child(n) 匹配父元素的第n个子元素E。 E:nth-last-child(n) 匹配父元素的倒数第n个子元素E。 E:first-of-type 匹配同类型中的第一个同级兄弟元素E。 E:last-of-type 匹配同类型中的最后一个同级兄弟元素E。 E:only-of-type 匹配同类型中的唯一的一个同级兄弟元素E。 E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E。 E:nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E。 E:empty 匹配没有任何子元素（包括text节点）的元素E。 E:checked 匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时) E:enabled 匹配用户界面上处于可用状态的元素E。 E:disabled 匹配用户界面上处于禁用状态的元素E。 E:target 匹配相关URL指向的E元素。 @page:first 设置页面容器第一页使用的样式。仅用于@page规则 @page:left 设置页面容器位于装订线左边的所有页面使用的样式。仅用于@page规则 @page:right 设置页面容器位于装订线右边的所有页面使用的样式。仅用于@page规则 伪对象选择符 选择符 描述 E:first-letter/:first-letter 设置对象内的第一个字符的样式。 E:first-line/:first-line 设置对象内的第一行的样式。 E:before/:before 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E:after/:after 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E::placeholder 设置对象文字占位符的样式。 E::selection 设置对象被选择时的颜色。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5地理定位]]></title>
    <url>%2F2019%2F08%2F27%2FHTML5%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[位置定位地理位置（Geolocation）是 HTML5 的重要特性之一，提供了确定用户位置的功能，借助这个特性能够开发基于位置信息的应用。 检测浏览器是否支持123456if (navigator.geolocation) &#123;//console.log(&quot;浏览器支持!&quot;);&#125;else &#123;// console.log(&quot;浏览器不支持!&quot;);&#125; navigator.geolocation用于获取基于浏览器的当前用户地理位置123456789// 1、获取用户当前位置void getCurrentPosition(onSuccess,onError,options);// 2、持续获取当前用户位置int watchCurrentPosition(onSuccess,onError,options);// 3、watchId 为watchCurrentPosition返回的值void clearWatch(watchId);// 取消监控 示例代码PS：也可以调用百度地图、谷歌地图、高德地图等，只需要将HTML5 Geolocation API获取到的值传入到相应的地图接口中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;/&gt;&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no&quot;&gt;&lt;title&gt;基于浏览器的HTML5地理定位&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;div id=&quot;info&quot;&gt;&lt;/div&gt; &lt;script src=&quot;http://map.qq.com/api/js?v=2.exp&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script&gt; var clientWidth = document.documentElement.clientWidth, clientHeight = document.documentElement.clientHeight; var container = document.getElementById(&apos;container&apos;); container.style.width = clientWidth + &apos;px&apos;; container.style.height = clientHeight + &apos;px&apos;; function getLocation()&#123; var options=&#123; enableHighAccuracy:true, //boolean 是否要求高精度的地理信息，默认为false maximumAge:1000 //应用程序的缓存时间 &#125; if(navigator.geolocation)&#123; //浏览器支持geolocation navigator.geolocation.getCurrentPosition(onSuccess,onError,options); &#125;else&#123; //浏览器不支持geolocation console.log(&quot;浏览器不支持!&quot;); &#125; &#125; //成功时 function onSuccess(position)&#123; //返回用户位置 //经度 var longitude =position.coords.longitude; //纬度 var latitude = position.coords.latitude; //腾讯地图的中心地理坐标 var center = new qq.maps.LatLng(latitude, longitude); //使用腾讯地图API var map = new qq.maps.Map(document.getElementById(&quot;container&quot;), &#123; //地图的中心地理坐标 center: center, //初始化地图缩放级别 zoom: 16 &#125;); //在地图中创建信息提示窗口 var infoWin = new qq.maps.InfoWindow(&#123; map: map &#125;); //打开信息窗口 infoWin.open(); //设置信息窗口显示区的内容 infoWin.setContent(&apos;&lt;div style=&quot;width:200px;padding:10px;&quot;&gt;&apos;+ &apos;您在这里&lt;br/&gt;纬度：&apos;+ latitude+ &apos;&lt;br/&gt;经度：&apos;+longitude); //设置信息窗口的位置 infoWin.setPosition(center); &#125; //失败时 function onError(error)&#123; switch(error.code)&#123; case error.PERMISSION_DENIED: alert(&quot;用户拒绝对获取地理位置的请求&quot;); break; case error.POSITION_UNAVAILABLE: alert(&quot;位置信息是不可用的&quot;); break; case error.TIMEOUT: alert(&quot;请求用户地理位置超时&quot;); break; case error.UNKNOWN_ERROR: alert(&quot;未知错误&quot;); break; &#125; &#125; window.onload=getLocation; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 服务器发送事件]]></title>
    <url>%2F2019%2F08%2F27%2FHTML5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Server-Sent EventsServer-Sent Events(SSE)用于网页自动获取服务器上更新的数据，它是一个实时性的机制 实时性获取数据 Polling(轮询)：在客户端重复的向服务端发送新请求。如果服务器没有新的数据更动，关闭本次连接。然后客户端在稍等一段时间之后，再次发起新请求，一直重复这样的步骤。 Long-polling(长轮询)：在长轮询中，客户端发送一个请求到服务端。如果服务端没有新的数据更动，那么本次连接将会被保持，直到等待到更新后的数据，返回给客户端并关闭这个连接。 Server-Sent Events：SSE类似于长轮询的机制，但是它在每一次的连接中，不只等待一次数据的更动。客户端发送一个请求到服务端 ，服务端保持这个请求直到一个新的消息准备好，将消息返回至客户端，此时不关闭连接，仍然保持它，供其它消息使用。SSE的一大特色就是重复利用一个连接来处理每一个消息（又称event）。 WebSocker：WebSocket不同于以上的这些技术，因为它提供了一个真正意义上的双向连接。WebSocket是HTML5中非常强大的新特性，已经得到广泛应用。 Server-Sent Events实现在后台获取时间，不断发送给前台。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;获得服务器更新&lt;/h1&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt; if(typeof(EventSource)!==&quot;undefined&quot;)&#123; var source=new EventSource(&quot;/example/html5/demo_sse.php&quot;); source.onmessage=function(event)&#123; document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;; alert(&quot;提示有新的内容&quot;); this.location.reload(); &#125;; &#125; else &#123; document.getElementById(&quot;result&quot;).innerHTML=&quot;抱歉，您的浏览器不支持 server-sent 事件 ...&quot;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端代码12345678&lt;?php header(&apos;Content-Type: text/event-stream&apos;); header(&apos;Cache-Control: no-cache&apos;); $time = date(&apos;r&apos;); echo &quot;data: The server time is: &#123;$time&#125;\n\n&quot;; flush();?&gt; EventSource对象 属性 描述 onopen 当通信服务器连接被打开 onmessage 当接收到消息 onerror 当发生错误 其他自动刷新方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 1.页面自动刷新：把如下代码加入&lt;head&gt;区域中 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt;,其中20指每隔20秒刷新一次页面. // 2.页面自动跳转：把如下代码加入&lt;head&gt;区域中 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;20;url=http://www.jb51.net&quot;&gt;// 其中20指隔20秒后跳转到http://www.jb51.net页面 // 3.页面自动刷新js版 &lt;script language=&quot;javascript&quot;&gt; function myrefresh()&#123; window.location.reload(); &#125; setTimeout(&apos;myrefresh()&apos;,1000); //指定1秒刷新一次 &lt;/script&gt; // 4.websocker&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;websocket&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function WebSocketTest() &#123; if (&quot;WebSocket&quot; in window) &#123; alert(&quot;您的浏览器支持 WebSocket!&quot;); // 打开一个 web socket var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(&quot;发送数据&quot;); alert(&quot;数据发送中...&quot;); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(&quot;数据已接收...&quot;); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(&quot;连接已关闭...&quot;); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(&quot;您的浏览器不支持 WebSocket!&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sse&quot;&gt; &lt;a href=&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 Web Worker用法]]></title>
    <url>%2F2019%2F08%2F26%2FHTML5-Web-Worker%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Web Worker的用法简单来说，其实就是在Javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后再回到主线程上，在这个过程中并不影响主线程的执行过程。 判断当前浏览器是否支持web worker1234567891011121314151617if (typeof (Worker) != &quot;undefined&quot;) &#123; //浏览器支持web worker if (typeof (w) == &quot;undefined&quot;) &#123; //w是未定义的,还没有开始计数 w = new Worker(&quot;webworker.js&quot;); //创建一个Worker对象,利用Worker的构造函数 &#125; //onmessage是Worker对象的properties w.onmessage = function (event) &#123; //事件处理函数,用来处理后端的web worker传递过来的消息 // do something &#125;;&#125; else &#123; // 浏览器不支持web worker // do something&#125; API 创建新的Worker var worker = new Worker(&quot;worker.js&quot;) 传递参数 worker.postMessage() 接收消息 worker.onMessage = function(msg){} 异常处理 worker.onerror = function(err){} 结束worker worker.terminate() 载入工具类函数 importScripts() 作用域创建一个新的worker时，该代码会运行在一个全新的javascript的环境中（WorkerGlobalScope）运行,是完全和创建worker的脚本隔离，这时我们可以把创建新worker的脚本叫做主线程，而被创建的新的worker叫做子线程。 WorkerGlobalScope是worker的全局对象，所以它包含所有核心javascript全局对象拥有的属性如JSON等，window的一些属性，也拥有类似于XMLHttpRequest()等。 但是我们所开启的新的worker也就是子线程，并不支持操作页面的DOM。 共享线程（SharedWorker）共享线程是为了避免线程的重复创建和销毁过程，降低了系统性能的消耗，共享线程SharedWorker可以同时有多个页面的线程链接。 var worker = new SharedWorker(&quot;sharedworker.js&quot;); 共享线程也使用了message事件监听线程消息，但使用SharedWorker对象的port属性与线程通信如下: worker.port.onmessage = function(msg){}; 同时我们也可以使用SharedWorker对象的port属性向共享线程发送消息如下： worker.port.postMessage(msg); 应用 可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信 可以在worker中通过importScripts(url)加载另外的脚本文件 可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval() 可以使用XMLHttpRequest来发送请求 可以访问navigator的部分属性 注意事项 不能跨域加载JS worker内代码不能访问DOM 各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行 不是每个浏览器都支持这个新特性]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5本地存储]]></title>
    <url>%2F2019%2F08%2F26%2FHTML5%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[localStroage &amp; sessionStroageHTML5 提供了本地存储对象 window.localStroage - 存储没有截止日期的数据（localStorage 生命周期是永久，除非主动清除 localStorage 信息，否则这些信息将永远存在。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。） window.sessionStroage - 针对一个 Session 的数据存储（仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。） 两者区别就是一个作为临时保存，一个长期保存。 之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 localStroage123456789// 1、保存数据到本地// 第一个参数是保存的变量名，第二个是赋给变量的值localStorage.setItem(&apos;Author&apos;, &apos;local&apos;);// 2、从本地存储获取数据localStorage.getItem(&apos;Author&apos;);// 3、从本地存储删除某个已保存的数据localStorage.removeItem(&apos;Author&apos;);// 4、清除所有保存的数据localStorage.clear(); 应用场景实际工作中对 localstorage 的使用一般有以下需求： 缓存一般信息，如搜索页的出发城市，达到城市，非实时定位信息 缓存城市列表数据，这个数据往往比较大 每条缓存信息需要可追踪，比如服务器通知城市数据更新，这个时候在最近一次访问的时候要自动设置过期 每条信息具有过期日期状态，在过期外时间需要由服务器拉取数据 ………… sessionStroage123456789// 1、保存数据到本地// 第一个参数是保存的变量名，第二个是赋给变量的值sessionStorage.setItem(&apos;Author&apos;, &apos;session&apos;);// 2、从本地存储获取数据sessionStorage.getItem(&apos;Author&apos;);// 3、从本地存储删除某个已保存的数据sessionStorage.removeItem(&apos;Author&apos;);// 4、清除所有保存的数据sessionStorage.clear(); 其他隐私模式下可以采用 window.name 模拟 sessionStorage 的方式处理，因为 window.name 是可做保存的，这个也是其解决跨域方案的原因。 postMessage 发送：调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象 otherWindow.postMessage(message, targetOrigin, [transfer]); 监听：message 事件 window.addEventListener( &quot;message&quot;, function(event) {alert(event.data);}) 假设在 a.html 里嵌套个&lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;,在这两个页面里互相通信 a.com/a.html1234567window.onload = function() &#123; window.addEventListener(&quot;message&quot;, function(event) &#123; alert(event.data); &#125;); //window.frames[0].postMessage(&quot;b data&quot;, &quot;http://www.b.com/b.html&quot;); //调用postMessage方法的window对象是指要接收消息的那一个window对象&#125; b.com/b.html123456window.onload = function() &#123; //window.addEventListener(&quot;message&quot;, function(event) &#123; // alert(event.data); //&#125;); window.parent.postMessage(&quot;a需要的数据&quot;, &quot;http://www.a.com/a.html&quot;);&#125; postMessage是从a窗口发送信息到b窗口，b窗口监听到消息后做出回应； localStorage是在a窗口改变某一个存储值，b窗口监听到了存储值的变化，然后获取该值，进而完成通信的同样的效果。 HTML5 应用缓存在 Html5 中，提供了一种叫 Application Cache 应用程序缓存的技术，通俗解释就是，通过一个文本文件可以告诉浏览器，我这个网页中的资源，哪些本地有就直接用本地，哪些必须要去网络拉取。 其实就是离线资源使用，本地缓存，如果有缓存，就能提升页面访问速度，节省流量，也能减少服务端负载，进而节省带宽费用。 如何实现 HTML5 应用程序缓存？ 创建一个 cache.manifest 文件，并确保文件具有正确的内容 在服务器上设置内容类型 所有的 HTML 文件都指向 cache.manifest cache.manifest1234567891011121314151617CACHE MANIFEST# version1CACHE:index.html404.htmlfavicon.icorobots.txthumans.txtapple-touch-icon.pngcss/main.cssimg/pho-cat.jpgFALLBACK:online.js local.jsNETWORK:* 注意事项： 第一行必须是”CACHE DMANIFEST”文字，以把本文件的作用告知浏览器，即对本地缓存中的资源文件进行具体设置。 在 manifest 文件中，可以加上注释来进行一些必要说明或解释。注释行以”#”文字开头。 在 CACHE 之后的部分为列出我们需要缓存的文件。 在 FALLBACK 之后的部分每一行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时使用的备用资源文件。 在 NETWORK 之后可以指定在线白名单，即列出我们不希望离线存储的文件，因为通常它们的内容需要互联网访问才有意义。 另外，在此部分我们可以使用快捷方式：通配符* 这将告诉浏览器，应用服务器中获取没有在显示部分中提到的任何文件或 URL。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F08%2F25%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML 基础 HTML 文档元信息 &lt;meta/&gt; 的重要性&lt;meta/&gt; 可分为两大部分：[ http-equiv ] 和 [ name ] 变量 [ http-equiv ]http-equiv相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助浏览器正确地显示网页内容。 值 描述 content-type 设定页面使用的字符集&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html; charset=&quot;utf-8&quot;&gt;UTF-8：世界通用的语言编码GB2312：编码是简体中文ISO-8859-1：编码是英文 X-UA-Compatible IE8的专用标记，用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式，以此来解决部分兼容问题&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot;&gt;以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8/9都会以IE7引擎来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot;&gt;以上代码告诉IE浏览器，IE8/9都会以IE8引擎来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame expires 设定网页的过期时间&lt;meta http-equiv=&quot;expires&quot;content=&quot;Fri,12Jan200118:18:18GMT&quot;&gt;必须使用GMT的时间格式 refresh 自动刷新并指向新页面&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2;URL=https://www.baidu.com&quot;&gt; set-cookie 如果网页过期，那么自动删除本地cookie&lt;meta http-equiv=&quot;Set-Cookie&quot;content=&quot;cookie value=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt;必须使用GMT的时间格式 windows-target 强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;&gt; cache-control 缓存机制&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;Public：指示响应可被任何缓存区缓存。Private：指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。no-cache：指示请求或响应消息不能缓存。no-store：用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。max-age：指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。min-fresh：指示客户机可以接收响应时间小于当前时间加上指定时间的响应。max-stale：指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 [ name ]name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 值 描述 author 标注网页的作者&lt;meta name=&quot;author&quot; content=&quot;value&quot; /&gt; keywords 页面关键词，用于被搜索引擎收录&lt;meta name=&quot;keywords&quot; content=&quot;value1,value2&quot;&gt; description 页面描述，用于搜索引擎收录&lt;meta name=&quot;description&quot; content=&quot;value&quot;&gt; viewport 用于控制页面缩放&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt; renderer 指定双核浏览器默认以何种方式渲染页面&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;webkit：默认webkit内核ie-comp：默认IE兼容模式ie-stand：默认IE标准模式 generator 说明网站的采用的什么软件制作&lt;meta name=&quot;generator&quot; content=&quot;Microsoft&quot;/&gt; revised 网页文档的修改时间&lt;meta name=&quot;revised&quot; content=&quot;WebName, MM/DD/YYYY&quot;/&gt; robots 用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引&lt;meta name=&quot;robots&quot; content=&quot;all&quot;/&gt;all：文件将被检索，且页面上的链接可以被查询none：文件将不被检索，且页面上的链接不可以被查询index：文件将被检索noindex：页面上的链接可以被查询follow：文件将不被检索，但页面上的链接可以被查询nofollow：文件将不被检索，页面上的链接可以被查询 copyright 网站版权信息&lt;meta name=&quot;copyright&quot; content=&quot;本页版权XXX所有。All Rights Reserved&quot; /&gt; HTML 块级元素 &amp; 内联元素 &amp; 置换元素 类型 描述 块级元素 div、header、nav、article、aside、section、footer、p、h1~h6、ul、ol… 块级元素特点： 独占一行 行高和边距可变 可以容纳块级元素和内联元素 display: block / table; 类型 描述 内联元素 span、img、label、input、button…. 内联元素特点： 与其他元素在同一行上 行高和边距不可变 只可容纳内联元素 display: inline / inline-block; 置换元素一个内容不受 CSS 视觉格式化模型控制，CSS 渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，浏览器会根据置换元素的标签和属性，来决定元素的具体显示内容。 置换元素与一般行内元素的区别在于：置换元素拥有内在尺寸，可以设置宽高，其性质等同于设置了 display: inline-block; 的元素。 常见的有 &lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;等 HTML 语义化 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 标签 语义 &lt;article&gt; 定义文档内的文章 &lt;aside&gt; 定义页面内容之外的内容 &lt;details&gt; 定义用户可查看或隐藏的额外细节 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题 &lt;figure&gt; 定义自包含内容，比如图示、图表、照片、代码清单等等 &lt;footer&gt; 定义文档或节的页脚 &lt;header&gt; 定义文档或节的页眉 &lt;main&gt; 定义文档的主内容 &lt;mark&gt; 定义重要或强调的内容 &lt;nav&gt; 定义文档内的导航链接 &lt;section&gt; 定义文档中的节 &lt;summary&gt; 定义 &lt;details&gt;元素的可见标题 &lt;time&gt; 定义日期/时间 例如下面这段代码:12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--页眉--&gt; &lt;header&gt;&lt;/header&gt; &lt;!--导航--&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!--主内容--&gt; &lt;main&gt; &lt;!--文章--&gt; &lt;article&gt; &lt;!--节--&gt; &lt;section&gt; &lt;!-- 表单 --&gt; &lt;form&gt; &lt;!-- 围绕表单的边框 --&gt; &lt;fieldset&gt; &lt;!-- fieldset 元素的标题 --&gt; &lt;legend&gt;Personalia:&lt;/legend&gt; &lt;!-- input标注 --&gt; &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt; &lt;!-- 重置按钮 --&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/fieldset&gt;&gt; &lt;/form&gt; &lt;/section&gt; &lt;/article&gt; &lt;!-- 页面内容之外的内容 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;!--页脚--&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; Canvas 图形绘制1234&lt;script&gt; var c = document.getElementById(&apos;myCanvas&apos;); var ctx = c.getContext(&apos;2d&apos;)&lt;/script&gt; 绘制基本图形 图形 方法 直线 moveTo(x,y) lineTo(x,y) 闭环 closePath() 矩形 rect(x,y,w,h) 曲线 二次贝塞尔曲线：context.quadraticCurveTo(cpx,cpy,x,y)三次方贝塞尔曲线：bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y) 圆形 arc(x,y,r,sAngle,eAngle,counterclockwise) 线性渐变 createLinearGradient(x0,y0,x1,y1) addColorStop(stop,color) 平移图形 translate(x,y) 缩放效果 scale(scalewidth,scaleheight) 旋转效果 rotate(angle) 颜色 &amp; 阴影 属性 描述 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 图像的应用复制图像：drawImage(img,sx,sy,swidth,sheight,x,y,width,height)裁剪图像：clip()平铺图像：createPattern(image,”repeat|repeat-x|repeat-y|no-repeat”) 属性 描述 img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度。（伸展或缩小图像） height 可选。要使用的图像的高度。（伸展或缩小图像） 文字的应用“被填充的”文本：fillText(text,x,y,maxWidth)绘制文本（无填充）：strokeText(text,x,y,maxWidth) HTML5 代码规范 请使用正确的文档类型&lt;!DOCTYPE html&gt; 使用小写元素名混合大小写名称并不好开发者习惯使用小写名（比如在 XHTML 中）小写更起来更纯净小写更易书写 关闭所有HTML元素 关闭空的HTML元素 使用小写属性名混合属性名并不好开发者习惯于使用小写属性名（比如在 XHTML 中）小写属性名看情况更纯净小写属性名更易书写 属性值加引号如果属性值包含值，则必须使用引号混合样式绝对不好加引号的值更易阅读 必要的属性请始终对图像使用 alt 属性。当图像无法显示时该属性很重要。 空格和等号，精简空格更易阅读。 避免长代码行(80个字符以内) 空格和缩进，请勿毫无理由地增加空行。 不能省略&lt;html&gt;&lt;/html&gt;和&lt;body&gt;&lt;/body&gt;、&lt;head&gt;&lt;/head&gt; 元数据，文档中对语言和字符编码的定义越早越好。 HTML注释短注释应该在单行中书写，并在 &lt;!-- 之后增加一个空格，在 &lt;!--之前增加一个空格 样式表开括号与选择器位于同一行在开括号之前用一个空格使用两个字符的缩进在每个属性与其值之间使用冒号加一个空格在每个逗号或分号之后使用空格在每个属性值对（包括最后一个）之后使用分号只在值包含空格时使用引号来包围值把闭括号放在新的一行，之前不用空格避免每行超过 80 个字符注释：在逗号或分号之后添加空格，是所有书写类型的通用规则。 在HTML中加载JavaScript 通过JavaScript访问HTML元素 使用小写文件名 文件扩展名.html]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
