<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript 自测题]]></title>
    <url>%2F2019%2F09%2F23%2FJavaScript-%E8%87%AA%E6%B5%8B%E9%A2%98%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 自测题1]]></title>
    <url>%2F2019%2F09%2F23%2FJavaScript-%E8%87%AA%E6%B5%8B%E9%A2%981%2F</url>
    <content type="text"><![CDATA[什么是作用域：浏览器给js的生存环境叫作用域。 什么是变量提升： Js代码执行前，浏览器会给一个全局作用域window Window分两个模块一个是存储模块一个是执行模块 存储模块找到所有的var和function 关键字给这些变量添加内存地址 执行模块，代码从上到下执行，遇到变量就会去存储模块查找，有和没有 有就看你赋值没有，赋值了就是后面的值没有赋值就是undefined。 没有结果就是xxx is not defined 什么是原型链？函数内部的变量被使用时，首先会在自己的私有作用域下查找是否有这个变量，有就直接使用，没有就向他的上一级查找，父级有就使用父级的，父级没有就以此继续向上查找直到查找带window有就使用没有就是is not defined。这种查找机制我们叫原型链。 例题： 12345678910alert(a);a();var a = 3;function a() &#123; /* body... */ alert(10);&#125; alert(a);a = 6;a(); 分析图：]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6]]></title>
    <url>%2F2019%2F09%2F20%2FES6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;ECMAScript6 入门&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 1.let命令 基本用法，ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块有效。 上面代码在代码块之中，分别用let和var声明了两个变量。然后再代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明let声明的变量只在它所在的代码块有效。 for循环的计数器，就很适合使用let命令。 2.不存在变量提升 var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该再声明语句之后才可以使用，为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 3.暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死去”(temporal dead zone,简称 TDZ)。 “暂时性死区“也意味着typeof不再是一个百分之百安全的操作。 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的”死区“，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 4.不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。 2.块级作用域 为什么需要块级作用域？ ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 3.ES6的块级作用域 let实际上为JavaScript新增了块级作用域。 上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。 ES6 允许块级作用域的任意嵌套。 内层作用域可以定义外层作用不的同名变量。 窥觊作用域的出现，实际上是的获得广泛应用的匿名立即执行函数表达式（匿名IIFE）不再必要了。 4.块级作用域和函数声明 ES5固定，函数智能在顶层作用域和函数作用域之中声明，不能再块级作用域声明。 ES6引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 - 允许在块级作用域内声明函数 - 函数声明类似于var，即会提升到全局作用域或函数作用域的头部 - 同时，函数声明还会提升到所在的块级作用域的头部。 注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当做let处理。 根据这三条规则，浏览器的ES6环境中，块级作用域内声明的函数，行为类似于var声明的变量。 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式而不是函数声明语句。 另外，还有一个需要注意的地方。ES6的块级作用域必须有大括号如果没有大括号，JavaScript引擎就认为不存在块级作用域。 3.const命令 基本用法，const声明一个只读的常量，一旦声明，常量的值就不能改变。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const的作用域与let命令相同；挚爱声明所在的块级作用域内有效。 const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 const声明的常量，也与let一样不可重复声明。 本质，const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const智能保证这个指针是固定的（即总是指向一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明未常量必须非常小心。 ES6声明变量的六种方法 ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。 4.顶层对象的属性 顶处对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样额设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；顶层对象的属性是到处可以读写的，这非常不利于模块化变成，另一个方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面固定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令，const命令、class命令声明的全局变量，不属于顶层对象的属性，也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 5.gobalThis对象 JavaScript语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。 - 浏览器里面，顶层对象是window，单Node和WebWorker没有window。 - 浏览器和WbeWorker里面，self也指向顶层对象，但是Node没有self。 - Node里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 - 全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。 - 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 - 不管是严格模式，还是普通模式，new Function(&apos;return this&apos;)(), 总是会返回全局对象。但是，如果浏览器用了CSP(Content Security Policy,内容安全策略)，那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。 &lt;script type=&quot;text/javascript&quot;&gt; // &#123; // let a = 10; // var b = 1; // &#125; // console.log(b); // console.log(a); // for(let i = 0; i &lt; 10; i++) &#123; // ... // &#125; // console.log(i); // var tmp = 123; // if(true)&#123; // tmp = &apos;abc&apos;; // let tmp; // &#125; // typeof x; // let x; // typeof undeclared_variable; // function func () &#123; // // body... // let a = 10; // var a = 1; // &#125; // function func () &#123; // let a = 10; // let a = 1; // &#125; // function func(arg)&#123; // let arg; // &#125; // func(); // 报错 // function func(arg)&#123; // &#123; // let arg; // &#125; // &#125; // func() // 不报错 // var tmp = new Date(); // function f() &#123; // console.log(tmp); // if(false)&#123; // var tmp = &apos;hello world&apos;; // &#125; // &#125; // f(); // function f1() &#123; // let n = 5; // if(true)&#123; // let n = 10; // &#125; // console.log(n); // &#125; // f1(); // 情况一 // if(true)&#123; // function f() &#123;&#125; // &#125; // // 情况二 // try &#123; // function f() &#123; // &#125; // &#125; catch(e) &#123; // // statements // console.log(e); // &#125; // 上面两种函数声明，根据ES5的规定都是非法的。 // 浏览器的ES6环境 // function f() &#123; console.log(&apos;I am outside!&apos;);&#125; // (function()&#123; // var f = undefined; // if(false)&#123; // function f() &#123;console.log(&apos;I am inside!&apos;);&#125; // &#125; // f(); // &#125;)(); // Uncaught TYpeError: f is not a function // const foo = &#123;&#125;; // 为 foor添加一个属性，可以成功 // foo.prop = 123; // foo.prop // 将foo指向另一个对象，就会报错 // foo = &#123;&#125;; // 方法一 // (typeof window !== &apos;undefined&apos; // ? window // : (typeof process === &apos;object&apos; &amp;&amp; // typeof require === &apos;function&apos; &amp;&amp; // typeof global === &apos;object&apos;) // ? global // : this); // 方法二 // var getGlobal = function () &#123; // if (typeof self !== &apos;undefined&apos;) &#123; return self; &#125; // if (typeof window !== &apos;undefined&apos;) &#123; return window; &#125; // if (typeof global !== &apos;undefined&apos;) &#123; return global; &#125; // throw new Error(&apos;unable to locate global object&apos;); // &#125;; &lt;/script&gt; 变量的解构赋值 1.数组的解构赋值 基本用法，ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，智能直接指定值 let a = 1; let b = 2; let c = 3; ES6允许写成下面这样 let [a,b,c] = [1,2,3]; 本质上，这种写法属于”模式匹配“，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 如果解构不成功，变量的值就等于undefined. 2.默认值 解构赋值允许指定默认值。注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 3.对象的解构赋值 解构不仅可以用于数组，还可以用于对象。 对象的解析与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 4.默认值 对象的解构也可以指定默认值。 5.注意点 - 如果要将一个已经声明的变量用于解构赋值，必须非常小心。 - 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 - 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 6.字符串的解构赋值 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 7.数值和布尔值的解构赋值 解构赋值时，如果等号左边是数值和布尔值，则会先转为对象。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对他们进行解构赋值，都会报错。 8.函数参数的解构赋值，函数的参数也可以使用解构赋值。 9.圆括号问题 解构赋值虽然很方面吧，但是解析起来并不容易，对于编译器来说某一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 10.不能使用圆括号的情况 - 变量声明语句 - 函数参数 - 赋值语句的模式 11.可以使用圆括号的情况 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 12.用途 变量的解构赋值用途很多 - 交换变量的值 - 从函数返回多个值 - 函数参数的定义 - 提取JSON数据 - 函数参数的默认值 - 遍历Map结构 - 输入模块的指定方法 &lt;!-- 字符串的扩展 --&gt; 1.字符的Unicode表示法 ES6加强了对Unicode的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点。但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 ES6对这一点做出改进，只要将码点放入大括号，就能正确解读该字符。 大括号标识符与四字节的UTF-16编码是等价的。有了这种表示法之后，JavaScript共有6中方法可以表示一个字符。 &apos;\z&apos; === &apos;z&apos; // true &apos;\172&apos; === &apos;z&apos; // true &apos;\x7A&apos; === &apos;z&apos; // true &apos;\u007A&apos; === &apos;z&apos; // true &apos;\u&#123;7A&#125;&apos; === &apos;z&apos; // true 2.字符串的遍历接口 ES6为字符串添加了遍历器接口，是的字符串可以被for...of循环遍历。 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 3.直接输入U+2028盒U+2029 4.JSON.stringify()的改造 根据标准，JOSN数据必须是UTF-8编码。但是，现在的JSON.stringify()方法有可能返回不符合UTF-8标准的字符串。 5.模板字符串 ES6引入了模板字符串解决这个问题。模板字符串是增强版的字符串，用反引号(`)表示。 6.实例：模板编译 7.标签模板 模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用了爱处理这个模板字符串。这个被称为&quot;标签模板&quot;功能。 8.模板字符串的限制 前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。 &lt;!-- 字符串的新增方法 --&gt; 1.String.fromCodePoint() ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。 2.String.raw() ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。 3.codePointAt() ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 4.normalize() ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 5.ES6 又提供了三种新方法。 - includes()：返回布尔值，表示是否找到了参数字符串。 - startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 - endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 6.repeat() repeat方法返回一个新字符串，表示将原字符串重复n次。 7.padStart()，padEnd() ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 8.trimStart()，trimEnd() ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。 9.matchAll() matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。 &lt;!-- 正则的扩展 --&gt; 1.RegExp 构造函数 - 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 - 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 2.字符串的正则方法 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 3.u 修饰符 ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 - 点字符 - Unicode 字符表示法 - 量词 - 预定义模式 - i 修饰符 - 转义 4.RegExp.prototype.unicode 属性 正则实例对象新增unicode属性，表示是否设置了u修饰符。 5.y 修饰符 除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。 6.RegExp.prototype.sticky 属性 与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。 7.RegExp.prototype.flags 属性 ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 8.s 修饰符：dotAll 模式 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。 - U+000A 换行符（\n） - U+000D 回车符（\r） - U+2028 行分隔符（line separator） - U+2029 段分隔符（paragraph separator） 9.后行断言 JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。 10.Unicode 属性类 ES2018 引入了一种新的类的写法\p&#123;...&#125;和\P&#123;...&#125;，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 11.具名组匹配 正则表达式使用圆括号进行组匹配。ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 - 解构赋值和替换，有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 - 引用，如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。 12.String.prototype.matchAll 如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。目前有一个提案，增加了String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 &lt;!-- 数值的扩展 --&gt; 1.二进制和八进制表示法 2.Number.isFinite(), Number.isNaN() 3.Number.parseInt(), Number.parseFloat() 4.Number.isInteger() 5.Number.EPSILON 6.安全整数和 Number.isSafeInteger() 7.Math 对象的扩展 8.指数运算符 &lt;!-- 函数的扩展 --&gt; 1.函数参数的默认值 2.rest 参数 3.严格模式 4.name 属性 5.箭头函数 6.尾调用优化 7.函数参数的尾逗号 8.Function.prototype.toString() 9.catch 命令的参数省略 &lt;!-- 数组的扩展 --&gt; 1.扩展运算符 2.Array.from() 3.Array.of() 4.数组实例的 copyWithin() 5.数组实例的 find() 和 findIndex() 6.数组实例的 fill() 7.数组实例的 entries()，keys() 和 values() 8.数组实例的 includes() 9.数组实例的 flat()，flatMap() 10.数组的空位 &lt;!-- 对象的扩展 --&gt; 1.属性的简洁表示法 2.属性名表达式 3.方法的 name 属性 4.属性的可枚举性和遍历 5.super 关键字 6.对象的扩展运算符 &lt;!-- 对象的新增方法 --&gt; 1.Object.is() 2.Object.assign() 3.Object.getOwnPropertyDescriptors() 4.__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf() 5.Object.keys()，Object.values()，Object.entries() 6.Object.fromEntries() &lt;!-- Symbol --&gt; 1.概述 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 2.Symbol.prototype.description 3.作为属性名的 Symbol 4.实例：消除魔术字符串 5.属性名的遍历 6.Symbol.for()，Symbol.keyFor() 7.实例：模块的 Singleton 模式 8.内置的 Symbol 值 &lt;!-- Set 和 Map 数据结构 --&gt; 1.Set ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成 Set 数据结构。 Set 结构的实例有以下属性。 - Set.prototype.constructor：构造函数，默认就是Set函数。 - Set.prototype.size：返回Set实例的成员总数。 Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 - Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 - Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 - Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 - Set.prototype.clear()：清除所有成员，没有返回值。 Set 结构的实例有四个遍历方法，可以用于遍历成员。 - Set.prototype.keys()：返回键名的遍历器 - Set.prototype.values()：返回键值的遍历器 - Set.prototype.entries()：返回键值对的遍历器 - Set.prototype.forEach()：使用回调函数遍历每个成员 2.WeakSet WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。 WeakSet 结构有以下三个方法。 - WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。 - WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。 - WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。 3.Map ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。 Map 结构原生提供三个遍历器生成函数和一个遍历方法。 - Map.prototype.keys()：返回键名的遍历器。 - Map.prototype.values()：返回键值的遍历器。 - Map.prototype.entries()：返回所有成员的遍历器。 - Map.prototype.forEach()：遍历 Map 的所有成员。 4.WeakMap WeakMap结构与Map结构类似，也是用于生成键值对的集合。 WeakMap与Map的区别有两点。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。 WeakMap只有四个方法可用：get()、set()、has()、delete()。 &lt;!-- ECMAScript 6 Iterator和for...of循环 --&gt; 1.Iterator（遍历器）的概念 Iterator的遍历过程是这样的。 （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。 2.数据结构的默认Iterator接口 Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环（详见下文）。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。 在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。 3.调用Iterator接口的场合 - 解构赋值，对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。 - 扩展运算符，扩展运算符（...）也会调用默认的iterator接口。 - yield*，yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 - 其他场合，由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。 for...of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[&apos;a&apos;,1],[&apos;b&apos;,2]])） Promise.all() Promise.race() 4.字符串的Iterator接口 5.Iterator接口与Generator函数 6.遍历器对象的return()，throw() 7.for...of循环 &lt;!-- ECMAScript 6 Generator 函数 --&gt; 1.简介 Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。 2.next方法的参数 yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。 3.for...of循环 for...of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。 4.Generator.prototype.throw() Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。 5.Generator.prototype.return() Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。 6.yield*语句 如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。 7.作为对象属性的Generator函数 8.Generator函数的this Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。 9.含义 Generator与状态机 - Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。 Generator与协程 - 协程与子例程的差异 - 协程与普通线程的差异 10.应用 Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。 - 异步操作的同步化表达 - 控制流管理 - 部署Iterator接口 - 作为数据结构 &lt;!-- ECMAScript 6 Promise对象 --&gt; 1.Promise的含义 Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 - 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 - 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 2.基本用法 ES6规定，Promise对象是一个构造函数，用来生成Promise实例。 3.Promise.prototype.then() 4.Promise.prototype.catch() 5.Promise.all() 6.Promise.race() 7.Promise.resolve() 8.Promise.reject() 9.两个有用的附加方法 10.应用 &lt;!-- ECMAScript 6 异步操作和Async函数 --&gt; 1.基本概念 ES6诞生以前，异步编程的方法，大概有下面四种。 - 回调函数 - 事件监听 - 发布/订阅 - Promise 对象 ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。 2.Generator函数 3.Thunk函数 4.co模块 5.async函数 &lt;!-- ECMAScript 6 Class --&gt; 1.Class基本语法 2.Class的继承 3.原生构造函数的继承 4.Class的取值函数（getter）和存值函数（setter） 5.Class的Generator方法 6.Class的静态方法 7.Class的静态属性和实例属性 8.new.target属性 9.Mixin模式的实现 &lt;!-- ECMAScript 6 修饰器（Decorator） --&gt; 1.类的修饰 2.方法的修饰 3.为什么修饰器不能用于函数？ 4.core-decorators.js 5.使用修饰器实现自动发布事件 6.Mixin 7.Trait 8.Babel转码器的支持 &lt;!-- ECMAScript 6 Module --&gt; 1.严格模式 2.export命令 3.import命令 4.模块的整体加载 5.export default命令 6.模块的继承 7.ES6模块加载的实质 8.循环加载 9.跨模块常量 10.ES6模块的转码 &lt;!-- ECMAScript 6 编程风格 --&gt; 1.块级作用域 2.字符串 3.解构赋值 4.对象 5.数组 6.函数 7.Map结构 8.Class 9.模块 10.ESLint的使用&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 语言入门教程]]></title>
    <url>%2F2019%2F09%2F19%2FJavaScript-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;JavaScript 语言入门教程&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;./assets/index.js&quot;&gt;&lt;/script&gt; --&gt; &lt;!-- JavaScript 的基本语法 --&gt; 1.语句 JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。 2.变量 - 概念 变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。 - 变量提升 JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。 3.标识符 - 标识符（identifier）指的是用来识别各种值的合法名称。 4.注释 - 源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。 5.区块 - JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。 6.条件语句 JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。 - if结构 - if...else结构 - switch结构 - 三元运算符 (条件) ? 表达式1 : 表达式2 JavaScript 还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。 7.循环语句 循环语句用于重复执行某个操作，它有多种形式。 - while 循环 While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。 - for 循环 for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。 - do...while循环 do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。 - break 语句和 continue 语句 break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。 - 标签（label） JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 &lt;!-- 数据类型 --&gt; JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。 - 数值（number）：整数和小数（比如1和3.14） - 字符串（string）：文本（比如Hello World）。 - 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假） - undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值 - null：表示空值，即此处的值为空。 - 对象（object）：各种值组成的集合。 1.原始类型（primitive type） - 通常，数值、字符串、布尔值这三种类型，即它们是最基本的数据类型，不能再细分了。 2.合成类型（complex type） - 一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。 3.特殊值 - undefined和null 对象是最复杂的数据类型，又可以分成三个子类型。 - 狭义的对象（object） - 数组（array） - 函数（function） 4.typeof 运算符：检测数据类型 &lt;!-- null, undefined 和布尔值 --&gt; null与undefined都可以表示“没有”，含义非常相似。 1.用法和含义 - null表示空值，即该处的值现在为空。 - undefined表示“未定义”。 2.布尔值 - 布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。 下列运算符会返回布尔值： - 前置逻辑运算符： ! (Not) - 相等运算符：===，!==，==，!= - 比较运算符：&gt;，&gt;=，&lt;，&lt;= &lt;!-- 数值 --&gt; 1.整数和浮点数 JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。 - 数值精度 - 数值范围 2.数值的表示法 3.数值的进制 JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。 4.特殊数值 - 正零和负零 - NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。 - Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小。 5.与数值相关的全局方法 - parseInt()方法用于将字符串转为整数。 - parseFloat方法用于将一个字符串转为浮点数。 - isNaN方法可以用来判断一个值是否为NaN。 - isFinite方法返回一个布尔值，表示某个值是否为正常的数值。 &lt;!-- 字符串 --&gt; 字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。 1.转义 - 反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 \0 ：null \b ：后退键 \f ：换页符 \n ：换行符 \r ：回车键 \t ：制表符 \v ：垂直制表符 \&apos; ：单引号 \&quot; ：双引号 \\ ：反斜杠 - 字符串与数组 字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。 - length 属性 length属性返回字符串的长度，该属性也是无法改变的。 2.字符集 JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 3.Base64 转码 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 - btoa()：任意值转为 Base64 编码 - atob()：Base64 编码转为原来的值 &lt;!-- 对象 --&gt; 1.对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。 - 键名，对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。 - 对象的引用，如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。 - JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。 2.属性的操作 - 读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。 - 点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。 - 查看一个对象本身的所有属性，可以使用Object.keys方法。 - delete命令用于删除对象的属性，删除成功后返回true。 - in 运算符，用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。 - for...in 循环，for...in循环用来遍历一个对象的全部属性。 3.with 语句 with (对象) &#123; 语句; &#125; &lt;!-- 函数 --&gt; 1.函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。 - function 命令，function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。 - 函数表达式，除了用function命令声明函数，还可以采用变量赋值的写法。 - Function 构造函数，第三种声明函数的方式是Function构造函数。 - 函数的重复声明，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。 - 圆括号运算符，return 语句和递归 - JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。 - JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。 2.函数的属性和方法 - name属性，函数的name属性返回函数的名字。 - length属性，函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 - toString()，函数的toString方法返回一个字符串，内容是函数的源码。 3.函数作用域 - 作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。 - 函数内部的变量提升，与全局作用域一样，函数作用域内部也会产生“变量提升”现象。 - 函数本身的作用域，函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 4.参数 - 函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。 - 函数参数不是必需的，JavaScript 允许省略参数。 - 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。 - 如果有同名的参数，则取最后出现的那个值。 - arguments 对象，由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。 - 与数组的关系，需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。 - callee 属性，arguments对象带有一个callee属性，返回它所对应的原函数。 5.函数的其他知识点 - 闭包，闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。 - 闭包的另一个用处，是封装对象的私有属性和私有方法。 - 立即调用的函数表达式（IIFE） 6.eval 命令 - eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。 - eval 的别名调用 &lt;!-- 数组 --&gt; 1.数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。 2.数组的本质，本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 3.length 属性，数组的length属性，返回数组的成员数量。 4.in 运算符，检查某个键名是否存在的运算符in，适用于对象，也适用于数组。 5.for...in 循环和数组的遍历，for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。 6.数组的空位，当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。 7.类似数组的对象，如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。 &lt;!-- 运算符 --&gt; 1.算术运算符 - 加法运算符：x + y - 减法运算符： x - y - 乘法运算符： x * y - 除法运算符：x / y - 指数运算符：x ** y - 余数运算符：x % y - 自增运算符：++x 或者 x++ - 自减运算符：--x 或者 x-- - 数值运算符： +x - 负数值运算符：-x 2.比较运算符 - 大于运算符：&gt; - 小于运算符：&lt; - 小于或等于运算符：&lt;= - 大于或等于运算符：&gt;= - 相等运算符：== - 严格相等运算符：=== - 不相等运算符：!= - 严格不相等运算符：!== 3.布尔运算符 - 取反运算符：! - 且运算符：&amp;&amp; - 或运算符：|| - 三元运算符：?: 4.二进制位运算符 - 二进制或运算符（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。 - 二进制与运算符（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为0。 - 二进制否运算符（not）：符号为~，表示对一个二进制位取反。 - 异或运算符（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0。 - 左移运算符（left shift）：符号为&lt;&lt;，详见下文解释。 - 右移运算符（right shift）：符号为&gt;&gt;，详见下文解释。 - 头部补零的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt;，详见下文解释。 5.其他运算符，运算顺序 - void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。 - 逗号运算符用于对两个表达式求值，并返回后一个表达式的值。 - 运算顺序 &lt;!-- 数据类型的转换 --&gt; 1.JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。 2.强制转换 - Number()，使用Number函数，可以将任意类型的值转化成数值。 - String()，String函数可以将任意类型的值转化成字符串。 - Boolean()函数可以将任意类型的值转为布尔值。 3.自动转换 - 第一种情况，不同类型的数据互相运算。 - 第二种情况，对非布尔值类型的数据求布尔值。 - 第三种情况，对非数值类型的值使用一元运算符（即+和-）。 &lt;!-- 错误处理机制 --&gt; 1.Error 实例对象 - JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。 2.原生错误类型 - SyntaxError对象是解析代码时发生的语法错误。 - ReferenceError对象是引用一个不存在的变量时发生的错误。 - RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。 - TypeError对象是变量或参数不是预期类型时发生的错误。 - URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 - EvalError 对象，eval函数没有被正确执行时，会抛出EvalError错误。 总结，以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。 3.自定义错误，除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。 4.throw语句的作用是手动中断程序执行，抛出一个错误。 5.try...catch 结构，一旦发生错误，程序就中止执行了。 6.finally 代码块，try...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。 &lt;!-- 编程风格 --&gt; 1.“编程风格”（programming style）指的是编写代码的样式规则。 2.缩进，行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。 3.区块，如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。 4.圆括号（parentheses），在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。 5.行尾的分号，分号表示一条语句的结束。JavaScript 允许省略行尾的分号。 6.全局变量，JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。 7.变量声明，JavaScript 会自动将变量声明“提升”（hoist）到代码块（block）的头部。 8.with 语句，with可以减少代码的书写，但是会造成混淆。 9.相等和严格相等，JavaScript 有两个表示相等的运算符：“相等”（==）和“严格相等”（===）。 10.语句的合并，有些程序员追求简洁，喜欢合并不同目的的语句。 11.自增（++）和自减（--）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。 12.switch...case 结构，switch...case结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。 &lt;!-- console 对象与控制台 --&gt; 1.console.log()，console.info()，console.debug() - 方法用于在控制台输出信息。 2.console.warn()，console.error() - 方法用于在控制台输出警告信息。 3.console.table() - 对于某些复合类型的数据，console.table方法可以将其转为表格显示。 4.console.count() - count方法用于计数，输出它被调用了多少次。 5.console.dir()，console.dirxml() - dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。 6.console.assert() - console.assert方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。 7.console.time()，console.timeEnd() - 这两个方法用于计时，可以算出一个操作所花费的准确时间。 8.console.group()，console.groupEnd()，console.groupCollapsed() - console.group和console.groupEnd这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。 9.console.trace()，console.clear() - console.trace方法显示当前执行的代码在堆栈中的调用路径。 - console.clear方法用于清除当前控制台的所有输出，将光标回置到第一行。 10.控制台命令行 API - $_属性返回上一个表达式的值。 - $0 - $4，控制台保存了最近5个在 Elements 面板选中的 DOM 元素，$0代表倒数第一个（最近一个），$1代表倒数第二个，以此类推直到$4。 - $(selector)返回第一个匹配的元素，等同于document.querySelector()。 - $$(selector)返回选中的 DOM 对象，等同于document.querySelectorAll。 - $x(path)方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。 - inspect(object)方法打开相关面板，并选中相应的元素，显示它的细节。 - getEventListeners(object)方法返回一个对象，该对象的成员为object登记了回调函数的各种事件（比如click或keydown），每个事件对应一个数组，数组的成员为该事件的回调函数。 - keys(object)方法返回一个数组，包含object的所有键名。 - values(object)方法返回一个数组，包含object的所有键值。 - monitorEvents(object[, events])方法监听特定对象上发生的特定事件。事件发生时，会返回一个Event对象，包含该事件的相关信息。 - unmonitorEvents方法用于停止监听。 - monitorEvents允许监听同一大类的事件。所有事件可以分成四个大类。 mouse：&quot;mousedown&quot;, &quot;mouseup&quot;, &quot;click&quot;, &quot;dblclick&quot;, &quot;mousemove&quot;, &quot;mouseover&quot;, &quot;mouseout&quot;, &quot;mousewheel&quot; key：&quot;keydown&quot;, &quot;keyup&quot;, &quot;keypress&quot;, &quot;textInput&quot; touch：&quot;touchstart&quot;, &quot;touchmove&quot;, &quot;touchend&quot;, &quot;touchcancel&quot; control：&quot;resize&quot;, &quot;scroll&quot;, &quot;zoom&quot;, &quot;focus&quot;, &quot;blur&quot;, &quot;select&quot;, &quot;change&quot;, &quot;submit&quot;, &quot;reset&quot; 11.其他方法 - clear()：清除控制台的历史。 - copy(object)：复制特定 DOM 元素到剪贴板。 - dir(object)：显示特定对象的所有属性，是console.dir方法的别名。 - dirxml(object)：显示特定对象的 XML 形式，是console.dirxml方法的别名。 12.debugger 语句 - debugger语句主要用于除错，作用是设置断点。 &lt;!-- Object 对象 --&gt; 1.Object() - Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。 2.Object 构造函数 - Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。 3.Object 的静态方法 - Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。 - Object.getOwnPropertyNames方法与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。 4.对象属性模型的相关方法 - Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。 - Object.defineProperty()：通过描述对象，定义某个属性。 - Object.defineProperties()：通过描述对象，定义多个属性。 5.控制对象状态的方法 - Object.preventExtensions()：防止对象扩展。 - Object.isExtensible()：判断对象是否可扩展。 - Object.seal()：禁止对象配置。 - Object.isSealed()：判断一个对象是否可配置。 - Object.freeze()：冻结一个对象。 - Object.isFrozen()：判断一个对象是否被冻结。 6.原型链相关方法 - Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。 - Object.getPrototypeOf()：获取对象的Prototype对象。 7.Object 的实例方法 - Object.prototype.valueOf()：返回当前对象对应的值。 - Object.prototype.toString()：返回当前对象对应的字符串形式。 - Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。 - Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 - Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。 - Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。 &lt;!-- 属性描述对象 --&gt; JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。 属性描述对象提供6个元属性。 - value是该属性的属性值，默认为undefined。 - writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。 - enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。 - configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。 - get是一个函数，表示该属性的取值函数（getter），默认为undefined。 - set是一个函数，表示该属性的存值函数（setter），默认为undefined。 1.Object.getOwnPropertyDescriptor()方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。 2.Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。 3.Object.defineProperty()方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象。 4.propertyIsEnumerable()方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回false。 5.原属性，属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。 - value属性是目标属性的值。 - writable属性是一个布尔值，决定了目标属性的值（value）是否可以被改变。 - enumerable（可遍历性）返回一个布尔值，表示目标属性是否可遍历。 - configurable(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。 6.存取器 - 除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。 7.对象的拷贝 - 为了解决这个问题，我们可以通过Object.defineProperty方法来拷贝属性。 8.控制对象状态 - Object.preventExtensions方法可以使得一个对象无法再添加新的属性。 - Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。 - Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。 - Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。 - Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。 - Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。 - 局限性，上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。 &lt;!-- Array 对象 --&gt; 1.Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。 2.Array.isArray()，方法返回一个布尔值，表示参数是否为数组。 3.valueOf()，方法是一个所有对象都拥有的方法，表示对该对象求值。 4.toString()，方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。 5.push()，push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。 6.pop()，pop方法用于删除数组的最后一个元素，并返回该元素。 7.shift()，shift()方法用于删除数组的第一个元素，并返回该元素。 8.unshift()，unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。 9.join()，join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。 10.concat()，concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。 11.reverse()，reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。 12.slice()，slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。 13.splice()，splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。 14.sort()，sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。 15.map()，map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。 15.forEach()，forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。 16.filter()，filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。 17.some()，some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。 18.every()，every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。 19.reduce()，reduce是从左到右处理（从第一个成员到最后一个成员）。 20.reduceRight()，reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。 21.indexOf()，indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。 22.lastIndexOf()，lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 23.链式使用 &lt;!-- 包装对象 --&gt; 1.valueOf() - valueOf()方法返回包装对象实例对应的原始类型的值。 2.toString() - toString()方法返回对应的字符串形式。 3.原始类型与实例对象的自动转换 - 原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。 4.自定义方法 - 除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。 &lt;!-- Boolean 对象 --&gt; 1.Boolean对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。 2.Boolean 函数的类型转换作用 - Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。 &lt;!-- Number 对象 --&gt; 1.Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。 2.静态属性 - Number.POSITIVE_INFINITY：正的无限，指向Infinity。 - Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 - Number.NaN：表示非数值，指向NaN。 - Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 - Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 - Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 3.实例方法 - Number.prototype.toString()，Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。 - Number.prototype.toFixed()，toFixed()方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。 - Number.prototype.toExponential()，toExponential方法用于将一个数转为科学计数法形式。 - Number.prototype.toPrecision()，toPrecision方法用于将一个数转为指定位数的有效数字。 4.自定义方法 - 与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。 &lt;!-- String 对象 --&gt; 1.String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。 2.静态方法 - String.fromCharCode()，该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。 3.实例属性 - String.prototype.length，字符串实例的length属性返回字符串的长度。 4.实例方法 - String.prototype.charAt()，charAt方法返回指定位置的字符，参数是从0开始编号的位置。 - String.prototype.charCodeAt()，charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。 - String.prototype.concat()，concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。 - String.prototype.slice()，slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。 - String.prototype.substring()，substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。 - String.prototype.substr()，substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。 - String.prototype.indexOf()，indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。 - String.prototype.lastIndexOf()，lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。 - String.prototype.trim()，trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。 - String.prototype.toLowerCase()，toLowerCase方法用于将一个字符串全部转为小写，返回一个新字符串，不改变原字符串。 - String.prototype.toUpperCase()，toUpperCase则是全部转为大写，返回一个新字符串，不改变原字符串。 - String.prototype.match()，match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 - String.prototype.search()，search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 - String.prototype.replace()，replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。 - String.prototype.split()，split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。 - String.prototype.localeCompare()，localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 &lt;!-- Math 对象 --&gt; 1.Math是 JavaScript 的原生对象，提供各种数学功能。 2.静态方法 - Math.abs()：绝对值 - Math.ceil()：向上取整 - Math.floor()：向下取整 - Math.max()：最大值 - Math.min()：最小值 - Math.pow()：指数运算 - Math.sqrt()：平方根 - Math.log()：自然对数 - Math.exp()：e的指数 - Math.round()：四舍五入 - Math.random()：随机数 3.三角函数方法 - Math.sin()：返回参数的正弦（参数为弧度值） - Math.cos()：返回参数的余弦（参数为弧度值） - Math.tan()：返回参数的正切（参数为弧度值） - Math.asin()：返回参数的反正弦（返回值为弧度值） - Math.acos()：返回参数的反余弦（返回值为弧度值） - Math.atan()：返回参数的反正切（返回值为弧度值） &lt;!-- Date 对象 --&gt; 1.Date对象是 JavaScript 原生的时间库。Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。 2.构造函数的用法，Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。 3.日期的运算 4.静态方法 - Date.now()，返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。 - Date.parse()，用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。 - Date.UTC()，接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。 - Date.prototype.valueOf()，返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法。 5.实例方法，Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。 - to类：从Date对象返回一个字符串，表示指定的时间。 - get类：获取Date对象的日期和时间。 - set类：设置Date对象的日期和时间。 6.to 类方法 - Date.prototype.toString()，toString方法返回一个完整的日期字符串。 - Date.prototype.toUTCString()，toUTCString方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。 - Date.prototype.toISOString()，toISOString方法返回对应时间的 ISO8601 写法。 - Date.prototype.toJSON()，toJSON方法返回一个符合 JSON 格式的 ISO 日期字符串，与toISOString方法的返回结果完全相同。 - Date.prototype.toDateString()，toDateString方法返回日期字符串（不含小时、分和秒）。 - Date.prototype.toTimeString()，toTimeString方法返回时间字符串（不含年月日）。 - 本地时间 Date.prototype.toLocaleString()：完整的本地时间。 Date.prototype.toLocaleDateString()：本地日期（不含小时、分和秒）。 Date.prototype.toLocaleTimeString()：本地时间（不含年月日）。 7.get 类方法 - getTime()：返回实例距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。 - getDate()：返回实例对象对应每个月的几号（从1开始）。 - getDay()：返回星期几，星期日为0，星期一为1，以此类推。 - getFullYear()：返回四位的年份。 - getMonth()：返回月份（0表示1月，11表示12月）。 - getHours()：返回小时（0-23）。 - getMilliseconds()：返回毫秒（0-999）。 - getMinutes()：返回分钟（0-59）。 - getSeconds()：返回秒（0-59）。 - getTimezoneOffset()：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。 8.set 类方法 - setDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。 - setFullYear(year [, month, date])：设置四位年份。 - setHours(hour [, min, sec, ms])：设置小时（0-23）。 - setMilliseconds()：设置毫秒（0-999）。 - setMinutes(min [, sec, ms])：设置分钟（0-59）。 - setMonth(month [, date])：设置月份（0-11）。 - setSeconds(sec [, ms])：设置秒（0-59）。 - setTime(milliseconds)：设置毫秒时间戳。 &lt;!-- RegExp 对象 --&gt; 1.实例属性 - RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。 - RegExp.prototype.global：返回一个布尔值，表示是否设置了g修饰符。 - RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符。 - RegExp.prototype.flags：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。 2.实例方法 - RegExp.prototype.test()，正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。 - RegExp.prototype.exec()，正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。 3.字符串的实例方法 - String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。 - String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。 - String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。 - String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。 4.匹配规则 - 字面量字符和元字符 * 点字符（.)，点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。 * 位置字符用来提示字符所处的位置，主要有两个字符。^ 表示字符串的开始位置，$ 表示字符串的结束位置。 * 选择符（|），竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。 - 转义符，正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。 - 特殊字符，正则表达式对一些不能打印的特殊字符，提供了表达方法： * \cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。 * [\b] 匹配退格键(U+0008)，不要与\b混淆。 * \n 匹配换行键。 * \r 匹配回车键。 * \t 匹配制表符 tab（U+0009）。 * \v 匹配垂直制表符（U+000B）。 * \f 匹配换页符（U+000C）。 * \0 匹配null字符（U+0000）。 * \xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。 * \uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。 - 字符类，字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。 * 脱字符（^），如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。 * 连字符（-），某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。 - 预定义模式： \d 匹配0-9之间的任一数字，相当于[0-9]。 \D 匹配所有0-9以外的字符，相当于[^0-9]。 \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。 \W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。 \s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。 \S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。 \b 匹配词的边界。 \B 匹配非词边界，即在词的内部。 - 重复类，模式的精确匹配次数，使用大括号（&#123;&#125;）表示。 - 量词符： ? 问号表示某个模式出现0次或1次，等同于&#123;0, 1&#125;。 * 星号表示某个模式出现0次或多次，等同于&#123;0,&#125;。 + 加号表示某个模式出现1次或多次，等同于&#123;1,&#125;。 - 贪婪模式，上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。 - 修饰符，修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。 * g 修饰符，g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。 * i 修饰符，默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignoreCase）。 * m 修饰符，m修饰符表示多行模式（multiline），会修改^和$的行为。 - 组匹配，正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。 - 非捕获组，(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。 - 先行断言，x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。 - 先行否定断言，x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。 &lt;!-- JSON 对象 --&gt; 1.JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式， - 规定： 复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。 原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。 字符串必须使用双引号表示，不能使用单引号。 对象的键名必须放在双引号里面。 数组或对象最后一个成员的后面，不能加逗号。 - JSON.stringify()，JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。 - JSON.parse()，JSON.parse方法用于将 JSON 字符串转换成对应的值。 &lt;!-- 实例对象与 new 命令 --&gt; 1.对象是什么？ - 对象是单个实物的抽象。 - 对象是一个容器，封装了属性（property）和方法（method）。 2.构造函数 - 函数体内部使用了this关键字，代表了所要生成的对象实例。 - 生成对象的时候，必须使用new命令。 3.new 命令 - new 命令的原理： 创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。 - new.target 函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。 4.Object.create() 创建实例对象 构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。 &lt;!-- this 关键字 --&gt; 1.this就是属性或方法“当前”所在的对象。 2.JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。 3.使用场合 - 全局环境，全局环境使用this，它指的就是顶层对象window。 - 构造函数，构造函数中的this，指的是实例对象。 - 对象的方法，如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。 4.使用注意点 - 避免多层 this，由于this的指向是不确定的，所以切勿在函数中包含多层的this。 - 避免数组处理方法中的 this，数组的map和foreach方法，允许提供一个函数作为参数。 - 避免回调函数中的 this，回调函数中的this往往会改变指向，最好避免使用。 5.绑定 this 的方法 - Function.prototype.call()，函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。 - Function.prototype.apply()，apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。一的区别就是，它接收一个数组作为函数执行时的参数。 - Function.prototype.bind()，bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。 &lt;!-- 对象的继承 --&gt; 1.构造函数的缺点，同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。 2.prototype 属性的作用，JavaScript 规定，每个函数都有一个prototype属性，指向一个对象。 3.原型链，JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型…… 4.constructor 属性，prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。 5.instanceof 运算符，instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。 6.构造函数的继承 // 第一步，子类继承父类的实例 function Rectangle() &#123; Shape.call(this); // 调用父类构造函数 &#125; // 另一种写法 function Rectangle() &#123; this.base = Shape; this.base(); &#125; // 第二步，子类继承父类的原型 Rectangle.prototype = Object.create(Shape.prototype); Rectangle.prototype.constructor = Rectangle; 7.多重继承 function M1() &#123; this.hello = &apos;hello&apos;; &#125; function M2() &#123; this.world = &apos;world&apos;; &#125; function S() &#123; M1.call(this); M2.call(this); &#125; // 继承 M1 S.prototype = Object.create(M1.prototype); // 继承链上加入 M2 Object.assign(S.prototype, M2.prototype); // 指定构造函数 S.prototype.constructor = S; var s = new S(); s.hello // &apos;hello&apos; s.world // &apos;world&apos; 8.模块 - 模块是实现特定功能的一组属性和方法的封装。 var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125; &#125;); - 封装私有变量：构造函数的写法 function StringBuilder() &#123; var buffer = []; this.add = function (str) &#123; buffer.push(str); &#125;; this.toString = function () &#123; return buffer.join(&apos;&apos;); &#125;; &#125; - 封装私有变量：立即执行函数的写法 var module1 = (function () &#123; var _count = 0; var m1 = function () &#123; //... &#125;; var m2 = function () &#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;; &#125;)(); 9.模块的放大模式 var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod; &#125;)(module1); 10.输入全局变量：独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。 var module1 = (function ($, YAHOO) &#123; //... &#125;)(jQuery, YAHOO); &lt;!-- Object 对象的相关方法 --&gt; 1.Object.getPrototypeOf()，Object.getPrototypeOf方法返回参数对象的原型。这是获取原型对象的标准方法。 2.Object.setPrototypeOf()，Object.setPrototypeOf方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。 3.Object.create()，生成实例对象的常用方法是，使用new命令让构造函数返回一个实例。 4.Object.prototype.isPrototypeOf()，实例对象的isPrototypeOf方法，用来判断该对象是否为参数对象的原型。 5.Object.prototype.__proto__，实例对象的__proto__属性（前后各两个下划线），返回该对象的原型。该属性可读写。 6.获取原型对象方法的比较，获取实例对象obj的原型对象，有三种方法。 - obj.__proto__ - obj.constructor.prototype - Object.getPrototypeOf(obj) 7.Object.getOwnPropertyNames()，Object.getOwnPropertyNames方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。 8.Object.prototype.hasOwnProperty()，对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。 9.in 运算符和 for...in 循环，in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。 10.对象的拷贝Object.getOwnPropertyDescriptors方法。 &lt;!-- 严格模式 --&gt; 1.设计目的 - 明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。 - 增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。 - 提高编译器效率，增加运行速度。 - 为未来新版本的 JavaScript 语法做好铺垫。 2.启用方法，进入严格模式的标志，是一行字符串use strict。 3.显式报错，严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。 - 只读属性不可写 - 只设置了取值器的属性不可写 - 禁止扩展的对象不可扩展 - eval、arguments 不可用作标识名 - 函数不能有重名的参数 - 禁止八进制的前缀0表示法 4.增强的安全措施 - 全局变量显式声明 - 禁止 this 关键字指向全局对象 - 禁止使用 fn.callee、fn.caller - 禁止使用 arguments.callee、arguments.caller - 禁止删除变量 5.静态绑定 - 禁止使用 with 语句 - 创设 eval 作用域 - arguments 不再追踪参数的变化 6.向下一个版本的 JavaScript 过渡 - 非函数代码块不得声明函数 - 保留字 &lt;!-- 异步操作概述 --&gt; 1.单线程模型，单线程模型指的是，JavaScript 只在一个线程上运行。 2.同步任务和异步任务，程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。 3.任务队列和事件循环，JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。 4.异步操作的模式 - 回调函数，回调函数是异步操作最基本的方法。 - 事件监听，另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 - 发布/订阅，事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。 5.异步操作的流程控制 - 串行执行，我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。 - 并行执行，流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。 - 并行与串行的结合，所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务，这样就避免了过分占用系统资源。 &lt;!-- 定时器 --&gt; JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。 1.setTimeout()，setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。 2.setInterval()，setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。 3.clearTimeout()，clearInterval()，setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。 4.实例：debounce 函数 5.运行机制，setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。 6.setTimeout(f, 0)，setTimeout(f, 0)会在下一轮事件循环一开始就执行。 7.应用，setTimeout(f, 0)有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。 &lt;!-- Promise 对象 --&gt; Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。 1.Promise 对象的状态，Promise 实例具有三种状态。 - 异步操作未完成（pending） - 异步操作成功（fulfilled） - 异步操作失败（rejected） 2.Promise 构造函数，JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。 3.Promise.prototype.then()，Promise 实例的then方法，用来添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。 4.then() 用法辨析 5.实例：图片加载 var preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;); &#125;; Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。 6.微任务，Promise 的回调函数属于异步任务，会在同步任务之后执行。 new Promise(function (resolve, reject) &#123; resolve(1); &#125;).then(console.log); console.log(2); // 2 // 1 &lt;!-- DOM 概述 --&gt; 1.DOM 的最小组成单位叫做节点（node）。节点的类型有七种。 - Document：整个文档树的顶层节点 - DocumentType：doctype标签（比如&lt;!DOCTYPE html&gt;） - Element：网页的各种HTML标签（比如&lt;body&gt;、&lt;a&gt;等） - Attribute：网页元素的属性（比如class=&quot;right&quot;） - Text：标签之间或标签包含的文本 - Comment：注释 - DocumentFragment：文档的片段 2.节点树 一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。除了根节点，其他节点都有三种层级关系。 - 父节点关系（parentNode）：直接的那个上级节点 - 子节点关系（childNodes）：直接的下级节点 - 同级节点关系（sibling）：拥有同一个父节点的节点 3.DOM 提供操作接口，用来获取这三种关系的节点。 - 子节点接口包括firstChild（第一个子节点）lastChild（最后一个子节点）等属性 - 同级节点接口包括nextSibling（紧邻在后的那个同级节点）previousSibling（紧邻在前的那个同级节点）属性。 &lt;!-- Node 接口 --&gt; 1.Node.prototype.nodeType，nodeType属性返回一个整数值，表示节点的类型。 2.Node.prototype.nodeName，nodeName属性返回节点的名称。 不同节点的nodeName属性值如下。 - 文档节点（document）：#document - 元素节点（element）：大写的标签名 - 属性节点（attr）：属性的名称 - 文本节点（text）：#text - 文档片断节点（DocumentFragment）：#document-fragment - 文档类型节点（DocumentType）：文档的类型 - 注释节点（Comment）：#comment 3.Node.prototype.nodeValue，nodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的nodeValue可以返回结果，其他类型的节点一律返回null。 4.Node.prototype.textContent，textContent属性返回当前节点和它的所有后代节点的文本内容。 5.Node.prototype.baseURI，baseURI属性返回一个字符串，表示当前网页的绝对路径。 6.Node.prototype.ownerDocument，Node.ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。 7.Node.prototype.nextSibling，Node.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。 8.Node.prototype.previousSibling，previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。 9.Node.prototype.parentNode，parentNode属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。 10.Node.prototype.parentElement，parentElement属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。 11.Node.prototype.firstChild，Node.prototype.lastChild，firstChild属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null。lastChild属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。用法与firstChild属性相同。 12.Node.prototype.childNodes，childNodes属性返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点。 13.Node.prototype.isConnected，isConnected属性返回一个布尔值，表示当前节点是否在文档之中。 14.Node.prototype.appendChild()，appendChild()方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。 15.Node.prototype.hasChildNodes()，hasChildNodes方法返回一个布尔值，表示当前节点是否有子节点。 - node.hasChildNodes() - node.firstChild !== null - node.childNodes &amp;&amp; node.childNodes.length &gt; 0 hasChildNodes方法结合firstChild属性和nextSibling属性，可以遍历当前节点的所有后代节点。 16.Node.prototype.cloneNode()，cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。 17.Node.prototype.insertBefore()，insertBefore方法用于将某个节点插入父节点内部的指定位置。 18.Node.prototype.removeChild()，removeChild方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。 19.Node.prototype.replaceChild()，replaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。 20.Node.prototype.contains()，contains方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。 - 参数节点为当前节点。 - 参数节点为当前节点的子节点。 - 参数节点为当前节点的后代节点。 21.Node.prototype.compareDocumentPosition()，compareDocumentPosition方法的用法，与contains方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。 22.Node.prototype.isEqualNode()，Node.prototype.isSameNode()，isEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。 23.Node.prototype.normalize()，normalize方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。 24.Node.prototype.getRootNode()，getRootNode()方法返回当前节点所在文档的根节点document，与ownerDocument属性的作用相同。 &lt;!-- NodeList 接口，HTMLCollection 接口 --&gt; 1.NodeList 接口，NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。 - Node.childNodes - document.querySelectorAll()等节点搜索方法 2.NodeList.prototype.length，length属性返回 NodeList 实例包含的节点数量。 3.NodeList.prototype.forEach()，forEach方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。 4.NodeList.prototype.item()，item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。 5.NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries() ，这三个方法都返回一个 ES6 的遍历器对象，可以通过for...of循环遍历获取每一个成员的信息。区别在于，keys()返回键名的遍历器，values()返回键值的遍历器，entries()返回的遍历器同时包含键名和键值的信息。 6.HTMLCollection 接口，HTMLCollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。 7.HTMLCollection.prototype.length，length属性返回HTMLCollection实例包含的成员数量。 8.HTMLCollection.prototype.item()，item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。 9.HTMLCollection.prototype.namedItem()，namedItem方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。 &lt;!-- ParentNode 接口，ChildNode 接口 --&gt; ParentNode接口表示当前节点是一个父节点，提供一些处理子节点的方法。ChildNode接口表示当前节点是一个子节点，提供一些相关方法。 1.ParentNode.children，children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。 2.ParentNode.firstElementChild，firstElementChild属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null。 3.ParentNode.lastElementChild，lastElementChild属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null。 4.ParentNode.childElementCount，childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。 5.ParentNode.append()，ParentNode.prepend() - append方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。该方法不仅可以添加元素子节点，还可以添加文本子节点。 - prepend方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与append方法完全一致，也是没有返回值。 6.ChildNode 接口 - ChildNode.remove()，remove方法用于从父节点移除当前节点。 - ChildNode.before()，ChildNode.after()，before方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。注意，该方法不仅可以插入元素节点，还可以插入文本节点。after方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与before方法完全相同。 - ChildNode.replaceWith()，replaceWith方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。 &lt;!-- Document 节点 --&gt; 1.document节点对象代表整个文档，每张网页都有自己的document对象。document对象有不同的办法可以获取。 - 正常的网页，直接使用document或window.document。 - iframe框架里面的网页，使用iframe节点的contentDocument属性。 - Ajax 操作返回的文档，使用XMLHttpRequest对象的responseXML属性。 - 内部节点的ownerDocument属性。 2.快捷方式属性 - document.defaultView，document.defaultView属性返回document对象所属的window对象。如果当前文档不属于window对象，该属性返回null。 - document.doctype，对于 HTML 文档来说，document对象一般有两个子节点。第一个子节点是document.doctype，指向&lt;DOCTYPE&gt;节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成&lt;!DOCTYPE html&gt;。如果网页没有声明 DTD，该属性返回null。 - document.documentElement，document.documentElement属性返回当前文档的根元素节点（root）。它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。HTML网页的该属性，一般是&lt;html&gt;节点。 - document.body，document.head，document.body属性指向&lt;body&gt;节点，document.head属性指向&lt;head&gt;节点。这两个属性总是存在的，如果网页源码里面省略了&lt;head&gt;或&lt;body&gt;，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。 - document.scrollingElement，document.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。标准模式下，这个属性返回的文档的根元素document.documentElement（即&lt;html&gt;）。兼容（quirk）模式下，返回的是&lt;body&gt;元素，如果该元素不存在，返回null。 - document.activeElement，document.activeElement属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;等表单元素，如果当前没有焦点元素，返回&lt;body&gt;元素或null。 - document.fullscreenElement，document.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。 3.节点集合属性 - document.links，document.links属性返回当前文档所有设定了href属性的&lt;a&gt;及&lt;area&gt;节点。 - document.forms，document.forms属性返回所有&lt;form&gt;表单节点。 - document.images，document.images属性返回页面所有&lt;img&gt;图片节点。 - document.embeds，document.plugins，document.embeds属性和document.plugins属性，都返回所有&lt;embed&gt;节点。 - document.scripts，document.scripts属性返回所有&lt;script&gt;节点。 - document.styleSheets，document.styleSheets属性返回文档内嵌或引入的样式表集合 document.links instanceof HTMLCollection // true document.images instanceof HTMLCollection // true document.forms instanceof HTMLCollection // true document.embeds instanceof HTMLCollection // true document.scripts instanceof HTMLCollection // true HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。 - 文档静态信息属性 - document.documentURI，document.URL，document.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；URL继承自HTMLDocument接口，只能用于 HTML 文档。 - document.domain，document.domain属性返回当前文档的域名，不包含协议和端口。比如，网页的网址是http://www.example.com:80/hello.html，那么document.domain属性就等于www.example.com。如果无法获取域名，该属性返回null。 - document.location，Location对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。 - document.lastModified，document.lastModified属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。 - document.title，document.title属性返回当前文档的标题。默认情况下，返回&lt;title&gt;节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。 - document.characterSet，document.characterSet属性返回当前文档的编码，比如UTF-8、ISO-8859-1等等。 - document.referrer，document.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。 - document.dir，document.dir返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。 - document.compatMode，compatMode属性返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）。 4.文档状态属性 - document.hidden，document.hidden属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。 - document.visibilityState，document.visibilityState返回文档的可见状态。 visible：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。 hidden：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。 prerender：页面处于正在渲染状态，对于用户来说，该页面不可见。 unloaded：页面从内存里面卸载了。 - document.readyState，document.readyState属性返回当前文档的状态，共有三种可能的值。 loading：加载 HTML 代码阶段（尚未完成解析） interactive：加载外部资源阶段 complete：加载完成 - document.cookie，document.cookie属性用来操作浏览器 Cookie - document.designMode，document.designMode属性控制当前文档是否可编辑。 - document.implementation，document.implementation属性返回一个DOMImplementation对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。 DOMImplementation.createDocument()：创建一个 XML 文档。 DOMImplementation.createHTMLDocument()：创建一个 HTML 文档。 DOMImplementation.createDocumentType()：创建一个 DocumentType 对象。 5.方法 - document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。 - document.close方法用来关闭document.open()打开的文档。 - document.write方法用于向当前文档写入内容。在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行document.close()），document.write写入的内容就会追加在已有内容的后面。 - document.querySelector()，document.querySelectorAll()，document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。 - document.getElementsByTagName()，document.getElementsByTagName方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（HTMLCollection实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。 - document.getElementsByClassName()，document.getElementsByClassName方法返回一个类似数组的对象（HTMLCollection实例），包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中。 - document.getElementsByName()，document.getElementsByName方法用于选择拥有name属性的 HTML 元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等），返回一个类似数组的的对象（NodeList实例），因为name属性相同的元素可能不止一个。 - document.getElementById()，document.getElementById方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。 - document.elementFromPoint()，document.elementsFromPoint()，document.elementFromPoint方法返回位于页面指定位置最上层的元素节点。document.elementsFromPoint()返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。 - document.createElement()，document.createElement方法用来生成元素节点，并返回该节点。 - document.createTextNode()，document.createTextNode方法用来生成文本节点（Text实例），并返回该节点。它的参数是文本节点的内容。 - document.createAttribute()，document.createAttribute方法生成一个新的属性节点（Attr实例），并返回它。 - document.createComment()，document.createComment方法生成一个新的注释节点，并返回该节点。 - document.createDocumentFragment()，document.createDocumentFragment方法生成一个空的文档片段对象（DocumentFragment实例）。 - document.createEvent()，document.createEvent方法生成一个事件对象（Event实例），该对象可以被element.dispatchEvent方法使用，触发指定事件。 - document.hasFocus()，document.hasFocus方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。 - document.adoptNode()，document.importNode()，document.adoptNode方法将某个节点及其子节点，从原来所在的文档或DocumentFragment里面移除，归属当前document对象，返回插入后的新节点。插入的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。 - document.createNodeIterator()，document.createNodeIterator方法返回一个子节点遍历器。 - document.createTreeWalker()，document.createTreeWalker方法返回一个 DOM 的子树遍历器。它与document.createNodeIterator方法基本是类似的，区别在于它返回的是TreeWalker实例，后者返回的是NodeIterator实例。另外，它的第一个节点不是根节点。document.createTreeWalker方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与document.createNodeIterator方法的第二个参数相同）。 - document.execCommand()，如果document.designMode属性设为on，那么整个文档用户可编辑；如果元素的contenteditable属性设为true，那么该元素可编辑。 - document.execCommand()的返回值是一个布尔值。如果为false，表示这个方法无法生效。 - document.execCommand()方法可以执行的样式改变有很多种，下面是其中的一些：bold、insertLineBreak、selectAll、createLink、insertOrderedList、subscript、delete、insertUnorderedList、superscript、formatBlock、insertParagraph、undo、forwardDelete、insertText、unlink、insertImage、italic、unselect、insertHTML、redo。 - document.queryCommandSupported()，document.queryCommandSupported()方法返回一个布尔值，表示浏览器是否支持document.execCommand()的某个命令。 - document.queryCommandEnabled()，document.queryCommandEnabled()方法返回一个布尔值，表示当前是否可用document.execCommand()的某个命令。 - document.getSelection() ，这个方法指向window.getSelection()。 // Element 节点 1.Element.id，Element.id属性返回指定元素的id属性，该属性可读写。 2.Element.tagName，Element.tagName属性返回指定元素的大写标签名，与nodeName属性的值相等。 3.Element.dir，Element.dir属性用于读写当前元素的文字方向，可能是从左到右（&quot;ltr&quot;），也可能是从右到左（&quot;rtl&quot;）。 4.Element.accessKey，Element.accessKey属性用于读写分配给当前元素的快捷键。 5.Element.draggable，Element.draggable属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。 6.Element.lang，Element.lang属性返回当前元素的语言设置。该属性可读写。 7.Element.tabIndex，Element.tabIndex属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。 8.Element.title，Element.title属性用来读写当前元素的 HTML 属性title。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。 9.Element.hidden，Element.hidden属性返回一个布尔值，表示当前元素的hidden属性，用来控制当前元素是否可见。 10.Element.contentEditable，Element.isContentEditable，Element.contentEditable属性返回一个字符串，表示是否设置了contenteditable属性，有三种可能的值。该属性可写。 &quot;true&quot;：元素内容可编辑 &quot;false&quot;：元素内容不可编辑 &quot;inherit&quot;：元素是否可编辑，继承了父元素的设置 Element.isContentEditable属性返回一个布尔值，同样表示是否设置了contenteditable属性。该属性只读。 11.Element.attributes，Element.attributes属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点。 12.Element.className，Element.classList，className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割。classList属性返回一个类似数组的对象，当前元素节点的每个class就是这个对象的一个成员。 classList对象有下列方法。 add()：增加一个 class。 remove()：移除一个 class。 contains()：检查当前元素是否包含某个 class。 toggle()：将某个 class 移入或移出当前元素。 item()：返回指定索引位置的 class。 toString()：将 class 的列表转为字符串。 13.Element.dataset，网页元素可以自定义data-属性，用来添加数据。 14.Element.innerHTML，Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括&lt;HTML&gt;和&lt;body&gt;元素。 15.Element.outerHTML，Element.outerHTML属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。 16.Element.clientHeight，Element.clientWidth 17.Element.clientLeft，Element.clientTop 18.Element.scrollHeight，Element.scrollWidth 19.Element.scrollLeft，Element.scrollTop 20.Element.offsetParent 21.Element.offsetHeight，Element.offsetWidth 22.Element.offsetLeft，Element.offsetTop 23.Element.style 24.Element.children，Element.childElementCount 25.Element.firstElementChild，Element.lastElementChild 26.Element.nextElementSibling，Element.previousElementSibling 27.属性相关方法，元素节点提供六个方法，用来操作属性。 - getAttribute()：读取某个属性的值 - getAttributeNames()：返回当前元素的所有属性名 - setAttribute()：写入属性值 - hasAttribute()：某个属性是否存在 - hasAttributes()：当前元素是否有属性 - removeAttribute()：删除属性 28.Element.querySelector()，Element.querySelector方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回null。 29.Element.querySelectorAll()，Element.querySelectorAll方法接受 CSS 选择器作为参数，返回一个NodeList实例，包含所有匹配的子元素。 30.Element.getElementsByClassName()，Element.getElementsByClassName方法返回一个HTMLCollection实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。 31.Element.getElementsByTagName()，Element.getElementsByTagName方法返回一个HTMLCollection实例，成员是当前节点的所有匹配指定标签名的子元素节点。 23.Element.closest() ，Element.closest方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回null。 24.Element.matches()，Element.matches方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。 25.事件相关方法，以下三个方法与Element节点的事件相关。这些方法都继承自EventTarget接口， - Element.addEventListener()：添加事件的回调函数 - Element.removeEventListener()：移除事件监听函数 - Element.dispatchEvent()：触发事件 26.Element.scrollIntoView()，Element.scrollIntoView方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。 27.Element.getBoundingClientRect()，Element.getBoundingClientRect方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。 - x：元素左上角相对于视口的横坐标 - y：元素左上角相对于视口的纵坐标 - height：元素高度 - width：元素宽度 - left：元素左上角相对于视口的横坐标，与x属性相等 - right：元素右边界相对于视口的横坐标（等于x + width） - top：元素顶部相对于视口的纵坐标，与y属性相等 - bottom：元素底部相对于视口的纵坐标（等于y + height） 28.Element.getClientRects()，Element.getClientRects方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的Rect用的是复数）。 29.Element.insertAdjacentElement()，Element.insertAdjacentElement方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回null。 30.Element.insertAdjacentHTML()，Element.insertAdjacentText() 31.Element.remove()，Element.remove方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。 32.Element.focus()，Element.blur()，Element.focus方法用于将当前页面的焦点，转移到指定元素上。 33.Element.click()，Element.click方法用于在当前元素上模拟一次鼠标点击，相当于触发了click事件。 // 属性的操作 Element.attributes 属性 元素的标准属性 属性操作的标准方法 概述 Element.getAttribute() Element.getAttributeNames() Element.setAttribute() Element.hasAttribute() Element.hasAttributes() Element.removeAttribute() dataset 属性 // Text 节点和 DocumentFragment 节点 Text 节点的属性 data wholeText length nextElementSibling，previousElementSibling Text 节点的方法 appendData()，deleteData()，insertData()，replaceData()，subStringData() remove() splitText() DocumentFragment 节点 // CSS 操作 HTML 元素的 style 属性 CSSStyleDeclaration 接口 简介 CSSStyleDeclaration 实例属性 CSSStyleDeclaration 实例方法 CSS 模块的侦测 CSS 对象 CSS.escape() CSS.supports() window.getComputedStyle() CSS 伪元素 StyleSheet 接口 概述 实例属性 实例方法 实例：添加样式表 CSSRuleList 接口 CSSRule 接口 概述 CSSRule 实例的属性 CSSStyleRule 接口 CSSMediaRule 接口 window.matchMedia() 基本用法 MediaQueryList 接口的实例属性 MediaQueryList 接口的实例方法 // Mutation Observer API MutationObserver 构造函数 MutationObserver 的实例方法 observe() disconnect()，takeRecords（） MutationRecord 对象 应用示例 子元素的变动 属性的变动 取代 DOMContentLoaded 事件 // EventTarget 接口 1.DOM 的事件操作（监听和触发），都定义在EventTarget接口。 - addEventListener：绑定事件的监听函数 - removeEventListener：移除事件的监听函数 - dispatchEvent：触发事件 2.EventTarget.addEventListener() - EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。 3.EventTarget.removeEventListener() - EventTarget.removeEventListener方法用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。 4.EventTarget.dispatchEvent() -EventTarget.dispatchEvent方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。 // 事件模型 1.监听函数 浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。 - HTML 的 on- 属性，HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。 - 元素节点的事件属性，元素节点对象的事件属性，同样可以指定监听函数。 - EventTarget.addEventListener()，所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。 2.this 的指向，监听函数内部的this指向触发事件的那个元素节点。 3.事件的传播，一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。 - 第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。 - 第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。 - 第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。 4.事件处理，由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。 // Event 对象 1.Event，事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。 2.实例属性 - Event.bubbles属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，Event构造函数生成的事件，默认是不冒泡的。 - Event.eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。 Event.eventPhase的返回值有四种可能。 0，事件目前没有发生。 1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。 2，事件到达目标节点，即Event.target属性指向的那个节点。 3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。 - Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。 - Event.cancelBubble属性是一个布尔值，如果设为true，相当于执行Event.stopPropagation()，可以阻止事件的传播。 - Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。 - Event.currentTarget属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。 - Event.target属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。 - Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候指定的。该属性只读。 - Event.timeStamp属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。 - Event.isTrusted属性返回一个布尔值，表示该事件是否由真实的用户行为产生。 - Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。 3.实例方法 - Event.preventDefault方法取消浏览器对当前事件的默认行为。 - Event.stopPropagation()，stopPropagation方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。 - Event.stopImmediatePropagation()，Event.stopImmediatePropagation方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。 - Event.composedPath()，Event.composedPath()返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。 // 鼠标事件 1.鼠标事件的种类 - click：按下鼠标（通常是按下主按钮）时触发。 - dblclick：在同一个元素上双击鼠标时触发。 - mousedown：按下鼠标键时触发。 - mouseup：释放按下的鼠标键时触发。 - mousemove：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。 - mouseenter：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。 - mouseover：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。 - mouseout：鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。 - mouseleave：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。 - contextmenu：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。 - wheel：滚动鼠标的滚轮时触发，该事件继承的是WheelEvent接口。 2.MouseEvent 接口概述，MouseEvent接口代表了鼠标相关的事件，单击（click）、双击（dblclick）、松开鼠标键（mouseup）、按下鼠标键（mousedown）等动作，所产生的事件对象都是MouseEvent实例。此外，滚轮事件和拖拉事件也是MouseEvent实例。该对象可以配置以下属性，所有属性都是可选的。 - screenX：数值，鼠标相对于屏幕的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。 - screenY：数值，鼠标相对于屏幕的垂直位置（单位像素），其他与screenX相同。 - clientX：数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。 - clientY：数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与clientX相同。 - ctrlKey：布尔值，是否同时按下了 Ctrl 键，默认值为false。 - shiftKey：布尔值，是否同时按下了 Shift 键，默认值为false。 - altKey：布尔值，是否同时按下 Alt 键，默认值为false。 - metaKey：布尔值，是否同时按下 Meta 键，默认值为false。 - button：数值，表示按下了哪一个鼠标按键，默认值为0，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；1表示按下辅助键（通常是鼠标的中间键），2表示按下次要键（通常是鼠标的右键）。 - buttons：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为0（没有按下任何键）。1（二进制001）表示按下主键（通常是左键），2（二进制010）表示按下次要键（通常是右键），4（二进制100）表示按下辅助键（通常是中间键）。因此，如果返回3（二进制011）就表示同时按下了左键和右键。 - relatedTarget：节点对象，表示事件的相关节点，默认为null。mouseenter和mouseover事件时，表示鼠标刚刚离开的那个元素节点；mouseout和mouseleave事件时，表示鼠标正在进入的那个元素节点。 3.MouseEvent 接口的实例属性 MouseEvent.altKey、MouseEvent.ctrlKey、MouseEvent.metaKey、MouseEvent.shiftKey这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是只读属性。 - altKey属性：Alt 键 - ctrlKey属性：Ctrl 键 - metaKey属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键） - shiftKey属性：Shift 键 MouseEvent.button属性返回一个数值，表示事件发生时按下了鼠标的哪个键。该属性只读。 - 0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如mousemove事件）。 - 1：按下辅助键（通常是中键或者滚轮键）。 - 2：按下次键（通常是右键）。 MouseEvent.buttons属性返回一个三个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况。该属性只读。 - 1：二进制为001（十进制的1），表示按下左键。 - 2：二进制为010（十进制的2），表示按下右键。 - 4：二进制为100（十进制的4），表示按下中键或滚轮键。 MouseEvent.clientX属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素），MouseEvent.clientY属性返回垂直坐标。这两个属性都是只读属性。 MouseEvent.movementX属性返回当前位置与上一个mousemove事件之间的水平距离（单位像素）。 MouseEvent.movementY属性返回当前位置与上一个mousemove事件之间的垂直距离（单位像素）。 MouseEvent.screenX属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），MouseEvent.screenY属性返回垂直坐标。这两个属性都是只读属性。 MouseEvent.offsetX属性返回鼠标位置与目标节点左侧的padding边缘的水平距离（单位像素），MouseEvent.offsetY属性返回与目标节点上方的padding边缘的垂直距离。这两个属性都是只读属性。 MouseEvent.pageX属性返回鼠标位置与文档左侧边缘的距离（单位像素），MouseEvent.pageY属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。这两个属性都是只读。 MouseEvent.relatedTarget属性返回事件的相关节点。对于那些没有相关节点的事件，该属性返回null。该属性只读。 事件名称 target 属性 relatedTarget 属性 focusin 接受焦点的节点 丧失焦点的节点 focusout 丧失焦点的节点 接受焦点的节点 mouseenter 将要进入的节点 将要离开的节点 mouseleave 将要离开的节点 将要进入的节点 mouseout 将要离开的节点 将要进入的节点 mouseover 将要进入的节点 将要离开的节点 dragenter 将要进入的节点 将要离开的节点 dragexit 将要离开的节点 将要进入的节点 4.MouseEvent 接口的实例方法 - MouseEvent.getModifierState方法返回一个布尔值，表示有没有按下特定的功能键。 5.WheelEvent 接口，WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象。该对象的属性除了Event、UIEvent的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。 - deltaX：数值，表示滚轮的水平滚动量，默认值是 0.0。 - deltaY：数值，表示滚轮的垂直滚动量，默认值是 0.0。 - deltaZ：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。 - deltaMode：数值，表示相关的滚动事件的单位，适用于上面三个属性。0表示滚动单位为像素，1表示单位为行，2表示单位为页，默认为0。 6.WheelEvent事件实例除了具有Event和MouseEvent的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。 下面的属性都是只读属性。 - WheelEvent.deltaX：数值，表示滚轮的水平滚动量。 - WheelEvent.deltaY：数值，表示滚轮的垂直滚动量。 - WheelEvent.deltaZ：数值，表示滚轮的 Z 轴滚动量。 - WheelEvent.deltaMode：数值，表示上面三个属性的单位，0是像素，1是行，2是页。 // 键盘事件 1.键盘事件的种类 - keydown：按下键盘时触发。 - keypress：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发keydown事件，再触发这个事件。 - keyup：松开键盘时触发该事件。 如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。 keydown keypress keydown keypress ...（重复以上过程） keyup 2.KeyboardEvent 接口概述，KeyboardEvent接口用来描述用户与键盘的互动。这个接口继承了Event接口，并且定义了自己的实例属性和实例方法。KeyboardEvent构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了Event接口提供的属性，还可以配置以下字段，它们都是可选。 - key：字符串，当前按下的键，默认为空字符串。 - code：字符串，表示当前按下的键的字符串形式，默认为空字符串。 - location：整数，当前按下的键的位置，默认为0。 - ctrlKey：布尔值，是否按下 Ctrl 键，默认为false。 - shiftKey：布尔值，是否按下 Shift 键，默认为false。 - altKey：布尔值，是否按下 Alt 键，默认为false。 - metaKey：布尔值，是否按下 Meta 键，默认为false。 - repeat：布尔值，是否重复按键，默认为false。 3.KeyboardEvent 的实例属性 - KeyboardEvent.altKey：是否按下 Alt 键 - KeyboardEvent.ctrlKey：是否按下 Ctrl 键 - KeyboardEvent.metaKey：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键） - KeyboardEvent.shiftKey：是否按下 Shift 键 - KeyboardEvent.code属性返回一个字符串，表示当前按下的键的字符串形式。该属性只读。 下面是一些常用键的字符串形式，其他键请查文档。 数字键0 - 9：返回digital0 - digital9 字母键A - z：返回KeyA - KeyZ 功能键F1 - F12：返回 F1 - F12 方向键：返回ArrowDown、ArrowUp、ArrowLeft、ArrowRight Alt 键：返回AltLeft或AltRight Shift 键：返回ShiftLeft或ShiftRight Ctrl 键：返回ControlLeft或ControlRight - KeyboardEvent.key属性返回一个字符串，表示按下的键名。该属性只读。 - KeyboardEvent.location属性返回一个整数，表示按下的键处在键盘的哪一个区域。它可能取以下值。 0：处在键盘的主区域，或者无法判断处于哪一个区域。 1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。 2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。 3：处在数字小键盘。 - KeyboardEvent.repeat返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发keydown和keypress事件，直到用户松开手为止。 - KeyboardEvent.getModifierState()方法返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。 Alt：Alt 键 CapsLock：大写锁定键 Control：Ctrl 键 Meta：Meta 键 NumLock：数字键盘开关键 Shift：Shift 键 // 进度事件 1.进度事件的种类，进度事件用来描述资源加载的进度，主要由 AJAX 请求、&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;等外部资源的加载触发，继承了ProgressEvent接口。它主要包含以下几种事件。 - abort：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。 - error：由于错误导致外部资源无法加载时触发。 - load：外部资源加载成功时触发。 - loadstart：外部资源开始加载时触发。 - loadend：外部资源停止加载时触发，发生顺序排在error、abort、load等事件的后面。 - progress：外部资源加载过程中不断触发。 - timeout：加载超时时触发。 注意，除了资源下载，文件上传也存在这些事件。 2.ProgressEvent 接口，ProgressEvent接口主要用来描述外部资源加载的进度，比如 AJAX 加载、&lt;img&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;等外部资源加载。进度相关的事件都继承了这个接口。 // 表单事件 1.表单事件的种类 - input事件当&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;的值发生变化时触发。上面代码中，改变下拉框选项时，会触发input事件，从而执行回调函数inputHandler。 - select事件当在&lt;input&gt;、&lt;textarea&gt;里面选中文本时触发。选中的文本可以通过event.target元素的selectionDirection、selectionEnd、selectionStart和value属性拿到。 - change事件当&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;的值发生变化时触发。它与input事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面input事件必然伴随change事件。具体来说，分成以下几种情况。 激活单选框（radio）或复选框（checkbox）时触发。 用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。 当文本框或&lt;textarea&gt;元素的值发生改变，并且丧失焦点时触发。 - invalid 事件，用户提交表单时，如果表单元素的值不满足校验条件，就会触发invalid事件。 - reset事件当表单重置（所有表单成员变回默认值）时触发。 - submit事件当表单数据向服务器提交时触发。 2.InputEvent 接口 - InputEvent接口主要用来描述input事件的实例。该接口继承了Event接口，还定义了一些自己的实例属性和实例方法。 - InputEvent.data属性返回一个字符串，表示变动的内容。 - InputEvent.inputType属性返回一个字符串，表示字符串发生变更的类型。 - InputEvent.dataTransfer属性返回一个 DataTransfer 实例。该属性只在文本框接受粘贴内容（insertFromPaste）或拖拽内容（insertFromDrop）时才有效。 // 触摸事件 1.浏览器的触摸 API 由三个部分组成。 - Touch：一个触摸点 - TouchList：多个触摸点的集合 - TouchEvent：触摸引发的事件实例 2.Touch 接口，Touch构造函数接受一个配置对象作为参数，它有以下属性。 - identifier：必需，类型为整数，表示触摸点的唯一 ID。 - target：必需，类型为元素节点，表示触摸点开始时所在的网页元素。 - clientX：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。 - clientY：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。 - screenX：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。 - screenY：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。 - pageX：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。 - pageY：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。 - radiusX：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。 - radiusY：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。 - rotationAngle：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。 - force：可选，类型为数值，范围在0到1之间，表示触摸压力。0代表没有压力，1代表硬件所能识别的最大压力，默认为0。 3.Touch 接口的实例属性 - Touch.identifier属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。 - Touch.screenX属性和Touch.screenY属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。 - Touch.clientX属性和Touch.clientY属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。 - Touch.pageX属性和Touch.pageY属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。 - Touch.radiusX属性和Touch.radiusY属性，分别返回触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度。 - Touch.rotationAngle属性表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间。 - Touch.force属性返回一个0到1之间的数值，表示触摸压力。0代表没有压力，1代表硬件所能识别的最大压力。 - Touch.target属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。 4.TouchList 接口 TouchList接口表示一族的解除点的集合。它的实例是一个类似数组的对象，成员是Touch的实例对象，表示所有触摸点。用户用三根手指触摸，产生的TouchList实例就会包含三个成员，每根手指的接触点对应一个Touch实例对象。 它的实例属性和实例方法只有两个。 TouchList.length：数值，表示成员数量（即触摸点的数量）。 TouchList.item()：返回指定位置的成员，它的参数是该成员的位置编号（从零开始） 5.TouchEvent接口继承了 Event 接口，表示由触摸引发的事件实例，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。除了Event接口的配置属性，该接口还有一些自己的配置属性。 - touches：TouchList实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组[]。 - targetTouches：TouchList实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组[]。 - changedTouches：TouchList实例，代表本次触摸事件的相关触摸点，默认值是一个空数组[]。 - ctrlKey：布尔值，表示 Ctrl 键是否同时按下，默认值为false。 - shiftKey：布尔值，表示 Shift 键是否同时按下，默认值为false。 - altKey：布尔值，表示 Alt 键是否同时按下，默认值为false。 - metaKey：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为false。 实例属性： - TouchEvent.altKey：布尔值，表示触摸时是否按下了 Alt 键。 - TouchEvent.ctrlKey：布尔值，表示触摸时是否按下了 Ctrl 键。 - TouchEvent.shiftKey：布尔值：表示触摸时是否按下了 Shift 键。 - TouchEvent.metaKey：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。 - TouchEvent.changedTouches属性返回一个TouchList实例，成员是一组Touch实例对象，表示本次触摸事件的相关触摸点。对于不同的时间，该属性的含义有所不同。 touchstart事件：被激活的触摸点 touchmove事件：发生变化的触摸点 touchend事件：消失的触摸点（即不再被触碰的点） - TouchEvent.touches属性返回一个TouchList实例，成员是所有仍然处于活动状态（即触摸中）的触摸点。一般来说，一个手指就是一个触摸点。 - TouchEvent.targetTouches属性返回一个TouchList实例，成员是触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点。 6.触摸事件的种类，可以通过TouchEvent.type属性，查看到底发生的是哪一种事件。 - touchstart：用户开始触摸时触发，它的target属性返回发生触摸的元素节点。 - touchend：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的target属性与touchstart事件一致的，就是开始触摸时所在的元素节点。它的changedTouches属性返回一个TouchList实例，包含所有不再触摸的触摸点（即Touch实例对象）。 - touchmove：用户移动触摸点时触发，它的target属性与touchstart事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。 - touchcancel：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。 // 拖拉事件 1.拖拉事件的种类，draggable属性可用于任何元素节点，但是图片（&lt;img&gt;）和链接（&lt;a&gt;）不加这个属性，就可以拖拉。 当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。 - drag：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。 - dragstart：用户开始拖拉时，在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。 - dragend：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。它与dragstart事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，dragend事件总是会触发的。 - dragenter：拖拉进入当前节点时，在当前节点上触发一次，该事件的target属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。 - dragover：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的target属性是当前节点。该事件与dragenter事件的区别是，dragenter事件在进入该节点时触发，然后只要没有离开这个节点，dragover事件会持续触发。 - dragleave：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的target属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。 - drop：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许drop，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。 2.DragEvent 接口 - 拖拉事件都继承了DragEvent接口，这个接口又继承了MouseEvent接口和Event接口。浏览器原生提供一个DragEvent()构造函数，用来生成拖拉事件的实例对象。 3.DataTransfer 接口概述 - 所有拖拉事件的实例都有一个DragEvent.dataTransfer属性，用来读写需要传递的数据。这个属性的值是一个DataTransfer接口的实例。 4.DataTransfer 的实例属性 - DataTransfer.dropEffect属性用来设置放下（drop）被拖拉节点时的效果，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。 copy：复制被拖拉的节点 move：移动被拖拉的节点 link：创建指向被拖拉的节点的链接 none：无法放下被拖拉的节点 - DataTransfer.effectAllowed属性设置本次拖拉中允许的效果。它可能取下面的值。 copy：复制被拖拉的节点 move：移动被拖拉的节点 link：创建指向被拖拉节点的链接 copyLink：允许copy或link copyMove：允许copy或move linkMove：允许link或move all：允许所有效果 none：无法放下被拖拉的节点 uninitialized：默认值，等同于all - DataTransfer.files属性是一个 FileList 对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象。 - DataTransfer.types属性是一个只读的数组，每个成员是一个字符串，里面是拖拉的数据格式（通常是 MIME 值）。 - DataTransfer.items属性返回一个类似数组的只读对象（DataTransferItemList 实例），每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。如果本次拖拉不包含对象，则返回一个空对象。 DataTransferItemList 实例具有以下的属性和方法。 - length：返回成员的数量 - add(data, type)：增加一个指定内容和类型（比如text/html和text/plain）的字符串作为成员 - add(file)：add方法的另一种用法，增加一个文件作为成员 - remove(index)：移除指定位置的成员 - clear()：移除所有的成员 DataTransferItem 实例具有以下的属性和方法。 - kind：返回成员的种类（string还是file）。 - type：返回成员的类型（通常是 MIME 值）。 - getAsFile()：如果被拖拉是文件，返回该文件，否则返回null。 - getAsString(callback)：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。 5.DataTransfer 的实例方法 - DataTransfer.setData()方法用来设置拖拉事件所带有的数据。该方法没有返回值。 - DataTransfer.getData()方法接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用setData方法添加的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有drop事件触发后，才能取出数据。 - DataTransfer.clearData()方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。 - DataTransfer.setDragImage()方法可以自定义这张图片。它接受三个参数。第一个是&lt;img&gt;节点或者&lt;canvas&gt;节点，如果省略或为null，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。 // 其他常见事件 资源事件 beforeunload 事件 unload 事件 load 事件，error 事件 session 历史事件 pageshow 事件，pagehide 事件 popstate 事件 hashchange 事件 网页状态事件 DOMContentLoaded 事件 readystatechange 事件 窗口事件 scroll 事件 resize 事件 fullscreenchange 事件，fullscreenerror 事件 剪贴板事件 焦点事件 CustomEvent 接口 // GlobalEventHandlers 接口 1.GlobalEventHandlers.onabort，某个对象的abort事件（停止加载）发生时，就会调用onabort属性指定的回调函数。 2.GlobalEventHandlers.onerror，error事件发生时，就会调用onerror属性指定的回调函数。 - window.onerror的处理函数共接受五个参数，含义如下。 message：错误信息字符串 source：报错脚本的 URL lineno：报错的行号，是一个整数 colno：报错的列号，是一个整数 error： 错误对象 3.GlobalEventHandlers.onload、GlobalEventHandlers.onloadstart，元素完成加载时，会触发load事件，执行onload()。 4.GlobalEventHandlers.onfocus，GlobalEventHandlers.onblur，当前元素获得焦点时，会触发element.onfocus；失去焦点时，会触发element.onblur。 5.GlobalEventHandlers.onscroll，页面或元素滚动时，会触发scroll事件，导致执行onscroll()。 6.GlobalEventHandlers.oncontextmenu，GlobalEventHandlers.onshow，用户在页面上按下鼠标的右键，会触发contextmenu事件，导致执行oncontextmenu()。如果该属性执行后返回false，就等于禁止了右键菜单。document.oncontextmenu与window.oncontextmenu效果一样。 7.其他的事件属性 鼠标的事件属性。 onclick ondblclick onmousedown onmouseenter onmouseleave onmousemove onmouseout onmouseover onmouseup onwheel 键盘的事件属性。 onkeydown onkeypress onkeyup 焦点的事件属性。 onblur onfocus 表单的事件属性。 oninput onchange onsubmit onreset oninvalid onselect 触摸的事件属性。 ontouchcancel ontouchend ontouchmove ontouchstart 拖动的事件属性分成两类：一类与被拖动元素相关，另一类与接收被拖动元素的容器元素相关。 被拖动元素的事件属性。 ondragstart：拖动开始 ondrag：拖动过程中，每隔几百毫秒触发一次 ondragend：拖动结束 接收被拖动元素的容器元素的事件属性。 ondragenter：被拖动元素进入容器元素。 ondragleave：被拖动元素离开容器元素。 ondragover：被拖动元素在容器元素上方，每隔几百毫秒触发一次。 ondrop：松开鼠标后，被拖动元素放入容器元素。 &lt;dialog&gt;对话框元素的事件属性。 oncancel onclose // 浏览器模型 window 对象 Navigator 对象，Screen 对象 Cookie XMLHttpRequest 对象 同源限制 CORS 通信 Storage 接口 History 对象 Location 对象，URL 对象，URLSearchParams 对象 ArrayBuffer 对象，Blob 对象 File 对象，FileList 对象，FileReader 对象 表单，FormData 对象 IndexedDB API Web Worker // 网页元素接口 &lt;a&gt; &lt;img&gt; &lt;form&gt; &lt;input&gt; &lt;button&gt; &lt;option&gt; &lt;video&gt;，&lt;audio&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECMAScript]]></title>
    <url>%2F2019%2F09%2F18%2FECMAScript%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;ECMAScript&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- ECMAScript语法 --&gt; 1.变量是弱类型的 2.每行结尾的分号可有可无 3.注释与 Java、C 和 PHP 语言的注释相同 4.括号表示代码块 &lt;!-- ECMAScript 变量 --&gt; 1.声明变量 2.命名变量 * 第一个字符必须是字母、下划线（_）或美元符号（$） * 余下的字符可以是下划线、美元符号或任何字母或数字字符 3.著名的变量命名规则 * Camel 标记法：首字母是小写的，接下来的字母都以大写字符开头。 * Pascal 标记法：首字母是大写的，接下来的字母都以大写字符开头。 * 匈牙利类型标记法：在以 Pascal 标记法命名的变量前附加一个小写字母（或小写字母序列），说明该变量的类型。 4.变量声明不是必须的 &lt;!-- 关键字 --&gt; 1.ECMAScript 关键字：关键字是保留的，不能用作变量名或函数名。 &lt;!-- 保留字 --&gt; 1.ECMAScript 保留字：保留字在某种意思上是为将来的关键字而保留的单词。因此保留字不能被用作变量名或函数名。 &lt;!-- ECMAScript 原始值和引用值 --&gt; 1.变量可以存在两种类型的值，即原始值和引用值。 * 原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。 * 引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。 2.原始类型 * ECMAScript有5种原始类型（primitive type），即Undefined、Null、Boolean、Number和String。 &lt;!-- ECMAScript 原始类型 --&gt; 1.typeof运算符，返回值： * undefined - 如果变量是Undefined类型的 * boolean - 如果变量是Boolean类型的 * number - 如果变量是Number类型的 * string - 如果变量是String类型的 * object - 如果变量是一种引用类型或Null类型的 &lt;!-- ECMAScript 引用类型 --&gt; 1.引用类型 * 引用类型通常叫做类（class），也就是说，遇到引用值，所处理的就是对象。 2.Object 对象 * Object 对象具有下列属性： - constructor，对创建对象的函数的引用（指针）。对于Object对象，该指针指向原始的Object()函数。 - Prototype，对该对象的对象原型的引用。对于所有的对象，它默认返回Object对象的一个实例。 * Object 对象还具有几个方法： - hasOwnProperty(property)，判断对象是否有某个特定的属性。必须用字符串指定该属性。 - IsPrototypeOf(object)，判断该对象是否为另一个对象的原型。 - PropertyIsEnumerable，判断给定的属性是否可以用for...in语句进行枚举。 - ToString()，返回对象的原始字符串表示。 - ValueOf()，返回最适合该对象的原始值。对于许多对象，该方法返回的值都与ToString()的返回值相同。 3.Boolean 对象 * Boolean对象是Boolean原始类型的引用类型。 4.Number 对象 * Number对象是Number原始类型的引用类型。 - toFixed() 方法，返回的是具有指定位数小数的数字的字符串表示。例如：alert(oNumberObject.toFixed(2)); //输出 &quot;68.00&quot; - toExponential() 方法，返回的是用科学计数法表示的数字的字符串形式。例如：alert(oNumberObject.toExponential(1)); //输出 &quot;6.8e+1&quot; - toPrecision() 方法，根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如：alert(oNumberObject.toPrecision(1)); //输出 &quot;7e+1&quot; 5.String 对象 * String对象是String原始类型的对象表示法 - valueOf()方法，返回String类型的原始值。 - toString()方法，返回String类型的原始值。例如：alert(oStringObject.valueOf() == oStringObject.toString()); //输出 &quot;true&quot; - charAt()方法，返回字符串中的单个字符。例如：alert(oStringObject.charAt(1)); //输出 &quot;e&quot; - charCodeAt()方法，返回字符串中的字符代码。例如：alert(oStringObject.charCodeAt(1)); //输出 &quot;101&quot; - concat() 方法，用于把一个或多个字符串连接到String对象的原始值上。该方法返回的是String原始值。例如：var sResult = oStringObject.concat(&quot;world&quot;); alert(sResult); //输出 &quot;hello world&quot; - indexOf()方法，从字符串的开头（位置0）开始检索字符串。例如：alert(oStringObject.indexOf(&quot;o&quot;)); 输出 &quot;4&quot; - lastIndexOf()方法，从字符串的结尾开始检索子串。例如：alert(oStringObject.lastIndexOf(&quot;o&quot;)); 输出 &quot;7&quot; - localeCompare()方法，对字符串进行排序。该方法有一个参数 - 要进行比较的字符串，返回的是下列三个值之一： 1). 如果String对象按照字母顺序排在参数中的字符串之前，返回负数。例如：alert(oStringObject.localeCompare(&quot;zoo&quot;)); //输出 &quot;-1&quot; 2). 如果String对象等于参数中的字符串，返回0。例如：alert(oStringObject.localeCompare(&quot;yellow&quot;)); //输出 &quot;0&quot; 3). 如果String对象按照字母顺序排在参数中的字符串之后，返回正数。例如：alert(oStringObject.localeCompare(&quot;brick&quot;)); //输出 &quot;1&quot; - slice()、substring()方法，返回要处理的字符串的子串，接受一个或两个参数。 - toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()方法，涉及大小写转换。 例如： var oStringObject = new String(&quot;Hello World&quot;); alert(oStringObject.toLocaleUpperCase()); //输出 &quot;HELLO WORLD&quot; alert(oStringObject.toUpperCase()); //输出 &quot;HELLO WORLD&quot; alert(oStringObject.toLocaleLowerCase()); //输出 &quot;hello world&quot; alert(oStringObject.toLowerCase()); //输出 &quot;hello world&quot; * String对象属性： - length 属性，返回字符串中的字符个数。例如：alert(oStringObject.length); //输出 &quot;11&quot; * instanceof 运算符，instanceof方法要求开发者明确地确认对象为某特定类型。例如：alert(oStringObject instanceof String); //输出 &quot;true&quot; &lt;!-- ECMAScript 位运算符 --&gt; * ECMAScript整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。 * 位运算 NOT：位运算NOT由否定号（~）表示，它是ECMAScript中为数不多的与二进制算术有关的运算符之一。 * 位运算 AND：位运算AND由和号（&amp;）表示，直接对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后用下面的规则对同一位置上的两个数位进行AND运算。 * 位运算 OR：位运算OR由符号（|）表示，也是直接对数字的二进制形式进行运算。 * 位运算 XOR：位运算XOR由符号（^）表示，当然，也是直接对二进制形式进行运算。 * 左移运算：左移运算由两个小于号表示（&lt;&lt;）。它把数字中的所有数位向左移动指定的数量。 * 有符号右移运算：有符号右移运算符由两个大于号表示（&gt;&gt;）。它把32位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。 * 无符号右移运算：无符号右移运算符由三个大于号（&gt;&gt;&gt;）表示，它将无符号32位数的所有数位整体右移。对于正数，无符号右移运算的结果与有符号右移运算一样。 &lt;!-- ECMAScript Boolean 运算符 --&gt; * 逻辑 NOT 运算符：由感叹号（!）表示。与逻辑OR和逻辑AND运算符不同的是，逻辑NOT运算符返回的一定是Boolean值。 * 逻辑 AND 运算符：在ECMAScript中，逻辑AND运算符用双和号（&amp;&amp;）表示。 * 逻辑 OR 运算符：ECMAScript中的逻辑OR运算符与Java中的相同，都由双竖线（||）表示。 &lt;!-- ECMAScript 乘性运算符 --&gt; * 乘法运算符，乘法运算符由星号（*）表示，用于两数相乘。 * 除法运算符，除法运算符由斜杠（/）表示，用第二个运算数除第一个运算数。 * 取模运算符，除法（余数）运算符由百分号（%）表示。 &lt;!-- ECMAScript 加性运算符 --&gt; * 加法运算符，加法运算符由加号（+）表示。 * 减法运算符，减法运算符（-），也是一个常用的运算符。 &lt;!-- ECMAScript 关系运算符 --&gt; * 关系运算符小于、大于、小于等于和大于等于执行的是两个数的比较运算，比较方式与算术比较运算相同。 &lt;!-- ECMAScript 等性运算符 --&gt; * ECMAScript 提供了两套等性运算符：等号和非等号用于处理原始值，全等号和非全等号用于处理对象。 1.等号和非等号 * 等号由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。非等号由感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回 true。 2.全等号和非全等号 * 等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。 - 全等号由三个等号表示（===），只有在无需类型转换运算数就相等的情况下，才返回 true。 - 非全等号由感叹号加两个等号（!==）表示，只有在无需类型转换运算数不相等的情况下，才返回 true。 &lt;!-- ECMAScript 条件运算符 --&gt; * 条件运算符，例如：variable = boolean_expression ? true_value : false_value。 &lt;!-- ECMAScript 赋值运算符 --&gt; * 赋值运算符：简单的赋值运算符由等号（=）实现，只是把等号右边的值赋予等号左边的变量。 &lt;!-- ECMAScript 逗号运算符 --&gt; * 逗号运算符：用逗号运算符可以在一条语句中执行多个运算。 &lt;!-- ECMAScript if 语句 --&gt; * if 语句是 ECMAScript 中最常用的语句之一。 &lt;!-- ECMAScript 迭代语句 --&gt; * 迭代语句又叫循环语句，声明一组要反复执行的命令，直到满足某些条件为止。循环通常用于迭代数组的值（因此而得名），或者执行重复的算术任务。 1.do-while 语句：do-while 语句是后测试循环，即退出条件在执行循环内部的代码之后计算。 2.while 语句：while 语句是前测试循环。这意味着退出条件是在执行循环内部的代码之前计算的。 3.for 语句：for 语句是前测试循环，而且在进入循环之前，能够初始化变量，并定义循环后要执行的代码。 4.for-in 语句：for-in 语句是严格的迭代语句，用于枚举对象的属性。 &lt;!-- ECMAScript 标签语句 --&gt; * 有标签的语句 &lt;!-- ECMAScript break 和 continue 语句 --&gt; * break 和 continue 语句对循环中的代码执行提供了更严格的控制。 * break 和 continue 语句的不同之处 - break 语句可以立即退出循环，阻止再次反复执行任何代码。 - continue 语句只是退出当前循环，根据控制表达式还允许继续进行下一次循环。 * 与有标签的语句一起使用 - break 语句和 continue 语句都可以与有标签的语句联合使用，返回代码中的特定位置。 - 例如： var iNum = 0; outermost: for (var i=0; i&lt;10; i++) &#123; for (var j=0; j&lt;10; j++) &#123; if (i == 5 &amp;&amp; j == 5) &#123; break outermost; &#125; iNum++; &#125; &#125; alert(iNum); //输出 &quot;55&quot; &lt;!-- ECMAScript with 语句 --&gt; * 有标签的语句：with 语句用于设置代码在特定对象中的作用域。 &lt;!-- ECMAScript switch 语句 --&gt; * switch 语句：switch 语句是 if 语句的兄弟语句。 * 语法： switch (expression) case value: statement; break; case value: statement; break; case value: statement; break; case value: statement; break; ... case value: statement; break; default: statement; * 每个情况（case）都是表示“如果 expression 等于 value，就执行 statement”。 &lt;!-- ECMAScript 函数概述 --&gt; * 什么是函数？函数是由这样的方式进行声明的：关键字 function、函数名、一组参数，以及置于括号中的待执行代码。 * 如何调用函数？函数可以通过其名字加上括号中的参数进行调用，如果有多个参数。 * 函数如何返回值？即使函数确实有值，也不必明确地声明它。该函数只需要使用 return 运算符后跟要返回的值即可。 &lt;!-- ECMAScript arguments 对象 --&gt; * 在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。 * 检测参数个数，还可以用 arguments 对象检测函数的参数个数，引用属性 arguments.length 即可。 * 模拟函数重载，用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载。 &lt;!-- ECMAScript Function 对象（类） --&gt; * ECMAScript 的函数实际上是功能完整的对象。 * Function 对象（类） - Function 对象的 length 属性 - Function 对象的方法，与所有对象共享的 valueOf() 方法和 toString() 方法。 &lt;!-- ECMAScript 闭包（closure） --&gt; * 在ECMAScript中 最容易让人误解的一点是——它支持闭包（closure）。闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。 &lt;!-- ECMAScript 面向对象技术 --&gt; * 一种面向对象语言需要向开发者提供四种基本能力： 封装 - 把相关的信息（无论数据或方法）存储在对象中的能力 聚集 - 把一个对象存储在另一个对象内的能力 继承 - 由另一个类（或多个类）得来类的属性和方法的能力 多态 - 编写能以多种方法运行的函数或方法的能力 &lt;!-- ECMAScript 对象应用 --&gt; * 对象的创建和销毁都在 JavaScript 执行过程中发生，理解这种范式的含义对理解整个语言至关重要。 1.声明和实例化 2.对象引用 3.对象废除 4.早绑定和晚绑定 - 早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。 - 晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。 &lt;!-- ECMAScript 对象类型 --&gt; * 在 ECMAScript 中，所有对象并非同等创建的。一般来说，可以创建并使用的对象有三种：本地对象、内置对象和宿主对象。 &lt;!-- ECMAScript 对象作用域 --&gt; * 作用域指的是变量的适用范围。 1.公用、私有和受保护作用域：ECMAScript 只有公用作用域。 2.静态作用域：ECMAScript 没有静态作用域 3.关键字 this：关键字 this 总是指向调用该方法的对象。 &lt;!-- ECMAScript 定义类或对象 --&gt; * 使用预定义对象只是面向对象语言的能力的一部分，它真正强大之处在于能够创建自己专用的类和对象。 1.工厂方式： function createCar() &#123; var oTempCar = new Object; oTempCar.color = &quot;blue&quot;; oTempCar.doors = 4; oTempCar.mpg = 25; oTempCar.showColor = function() &#123; alert(this.color); &#125;; return oTempCar; &#125; var oCar1 = createCar(); var oCar2 = createCar(); 2.构造函数方式： function Car(sColor,iDoors,iMpg) &#123; this.color = sColor; this.doors = iDoors; this.mpg = iMpg; this.showColor = function() &#123; alert(this.color); &#125;; &#125; var oCar1 = new Car(&quot;red&quot;,4,23); var oCar2 = new Car(&quot;blue&quot;,3,25); 3.原型方式： function Car() &#123; &#125; Car.prototype.color = &quot;blue&quot;; Car.prototype.doors = 4; Car.prototype.mpg = 25; Car.prototype.showColor = function() &#123; alert(this.color); &#125;; var oCar1 = new Car(); var oCar2 = new Car(); 4.混合的构造函数/原型方式： function Car(sColor,iDoors,iMpg) &#123; this.color = sColor; this.doors = iDoors; this.mpg = iMpg; this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;); &#125; Car.prototype.showColor = function() &#123; alert(this.color); &#125;; var oCar1 = new Car(&quot;red&quot;,4,23); var oCar2 = new Car(&quot;blue&quot;,3,25); oCar1.drivers.push(&quot;Bill&quot;); alert(oCar1.drivers); //输出 &quot;Mike,John,Bill&quot; alert(oCar2.drivers); //输出 &quot;Mike,John&quot; 5.动态原型方法： class Car &#123; public String color = &quot;blue&quot;; public int doors = 4; public int mpg = 25; public Car(String color, int doors, int mpg) &#123; this.color = color; this.doors = doors; this.mpg = mpg; &#125; public void showColor() &#123; System.out.println(color); &#125; &#125; 6.混合工厂方式： function Car() &#123; var oTempCar = new Object; oTempCar.color = &quot;blue&quot;; oTempCar.doors = 4; oTempCar.mpg = 25; oTempCar.showColor = function() &#123; alert(this.color); &#125;; return oTempCar; &#125; &lt;!-- ECMAScript 修改对象 --&gt; * prototype 属性不仅可以定义构造函数的属性和方法，还可以为本地对象添加属性和方法。 1.通过已有的方法创建新方法 2.重命名已有方法 3.添加与已有方法无关的方法 4.为本地对象添加新方法 5.重定义已有方法 6.极晚绑定（Very Late Binding） &lt;!-- ECMAScript 继承机制实例 --&gt; * 继承机制的实现：要用 ECMAScript 实现继承机制，您可以从要继承的基类入手。所有开发者定义的类都可作为基类。 * 继承的方式，所有的继承细节并非完全由解释程序处理。作为开发者，你有权决定最适用的继承方式： - 对象冒充，构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。例如： function ClassA(sColor) &#123; this.color = sColor; this.sayColor = function () &#123; alert(this.color); &#125;; &#125; function ClassB(sColor) &#123; &#125; - 对象冒充可以实现多重继承，也就是说，一个类可以继承多个超类。例如： function ClassZ() &#123; this.newMethod = ClassX; this.newMethod(); delete this.newMethod; this.newMethod = ClassY; this.newMethod(); delete this.newMethod; &#125; * call() 方法：call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。 - 例如： function sayColor(sPrefix,sSuffix) &#123; alert(sPrefix + this.color + sSuffix); &#125;; var obj = new Object(); obj.color = &quot;blue&quot;; sayColor.call(obj, &quot;The color is &quot;, &quot;a very nice color indeed.&quot;); * apply() 方法：apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。 - 例如： function sayColor(sPrefix,sSuffix) &#123; alert(sPrefix + this.color + sSuffix); &#125;; var obj = new Object(); obj.color = &quot;blue&quot;; sayColor.apply(obj, new Array(&quot;The color is &quot;, &quot;a very nice color indeed.&quot;)); * 原型链（prototype chaining）：继承这种形式在 ECMAScript 中原本是用于原型链的。 - 例如： function ClassA() &#123; &#125; ClassA.prototype.color = &quot;blue&quot;; ClassA.prototype.sayColor = function () &#123; alert(this.color); &#125;; function ClassB() &#123; &#125; ClassB.prototype = new ClassA(); * 混合方式：这种继承方式使用构造函数定义类，并非使用任何原型。 - 例如： function ClassA(sColor) &#123; this.color = sColor; &#125; ClassA.prototype.sayColor = function () &#123; alert(this.color); &#125;; function ClassB(sColor, sName) &#123; ClassA.call(this, sColor); this.name = sName; &#125;; ClassB.prototype = new ClassA(); ClassB.prototype.sayName = function () &#123; alert(this.name); &#125;;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript DOM2和DOM3扩展]]></title>
    <url>%2F2019%2F09%2F17%2FJavaScript-DOM2%E5%92%8CDOM3%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;JavaScript DOM2和DOM3扩展&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/transitions.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 立即执行函数 (function () &#123; // 严格模式 &quot;use strict&quot;; // DOM的变化 // DOM2级和3级的目的在于扩展DOM API，以满足操作XML的所有需求，同事提供更好的错误处理及特性检测能力。从某种意义上来讲，实现这一目的的很大程度意味着对命名空间的支持 // 针对XML命名空间的变化 // 1.Node类型的变化 // 在DOM2级中，Node类型包含下列特定于命名空间的属性： // localName - 不带命名空间前缀的节点名称 // namespaceURI - 命名空间URI或者（在未指定的情况下是）null // prefix - 命名空间前缀或者（在未指定的情况下是）null // DOM3级在此基础上更进一步，又引入了下列与命名空间有关的方法： // isDefaultNamespace(namespace: DOMString) - 在指定的namespaceURI是当前节点的默认命名空间的情况下返回true // lookupNamespaceURI(prefix: DOMString) - 返回给定prefix的命名空间 // lookupPrefix(namespace: DOMString) - 返回给定 namespaceURI的前缀 // 2.Document类型的变化 // DOM2级中的Document类型也发生了变化，包含下列命名空间有关的方法： // createElementNS(namespace: DOMString, qualifiedName: DOMString) - 使用给定的 tagName 创建一个属于命名空间 namespaceURI 的新元素 // createAttributeNS(namespaceURI, attributName) - 使用给定的attributName 创建一个属于命名空间 namespaceURI的新元素 // getElementsByTagNameNS(namespace: DOMString, localName: DOMString) - 返回属于命名空间 namespaceURI 的 tagName 元素的 NodeList // 3.Element类型的变化 // DOM2级核心中有关Element的变化，主要涉及操作特性，新增的方法如下： // getAttributeNS(namespace: DOMString, localName: DOMString) - 取得属于命名空间 namespaceURI 且名为 localName 的特性 // getAttributeNodeNS(namespaceURI, tagName) - 返回属于命名空间 namespaceURI 且名为 localName 的特性 // getElementsByTagNameNS(namespace: DOMString, localName: DOMString) - 返回属于命名空间 namespaceURI 的 tagName 元素的 NodeList // hasAttributeNS(namespace: DOMString, localName: DOMString) - 确定当前元素是否有一个名为 localName 的特性，而且该特性的命名空间是 namespaceURI。 // removeAttributeNS(namespace: DOMString, localName: DOMString) - 删除属于命名空间 namespaceURI 且名为 localName 的特性。 // setAttributeNS(namespace: DOMString, name: DOMString, value: DOMString) - 设置属于命名空间 namespaceURI 且名为 qualifiedName 的特性的值为 value。 // setAttributeNodeNs(attNode) - 设置属于命名空间 namespaceURI的特性节点。 // 4.NamedNodeMap类型的变化 // NamedNodeMap类型也新增了下列与命名空间有关的方法。由于特性是通过NamedNodeMap表示的，因此这些方法多数情况下只针对特性使用。 // getNamedItemNS(namespaceURI, localName) - 取得属于命名空间 namespaceURI 且名为 localName 的项 // removeNamedItemNS(namespaceURI, localName) - 移出属于命名空间 namespaceURI 且名为 localName 的项。 // setNamedItemNS(node) - 添加node，这个节点已经实现指定了命名空间信息。 // 其他方面的变化 // 1.DocumentType 类型的变化 // DocumentType 类型新增了3个属性：publicId、systemId 和 internalSubset。其中，前两个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。 // 2.Document 类型的变化 // Document类型的变化中唯一与命名空间无关的方法是importNode()。这个方法的用途是从一个文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分。需要注意的是，每个节点都有一个ownerDocument属性，表示所属的文档。 // 如果调用appendChild()时传入的节点属于不同的文档（ownerDocument属性的值不一样），则会导致错误。 // 但在调用importNode()时传入不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。 // importNode()方法与Element与cloneNode()方法非常相似，它接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。 // var newNode = document.importNode(oldNode, true) //导入节点机器所有子节点 // document.body.appendChild(newNode) // DOM2级视图模块添加了一个名为defaultView的属性，其中保存着一个指针，指向拥有给定文档的窗口（或框架）。 // var parentWindow = document.defaultView || document.parentWindow; // DOM2级核心为document.implementation对象规定了两个新方法：createDocumentType() 和 createDocument()。前者用于创建一个新的DocumentType节点，接收3个参数：文档类型名称、publicId、systemId。 // createDocumentType()只在创建新文档时有用：创建新文档时需要用到createDocument()方法。这个方法接受3个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型。 // var doctype = document.implementation.createDocumentType(&quot;html&quot;,&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;, &quot;http://www.w3.org/TR/xhtml/DTD/xhtml-strict.dtd&quot;); // var doc = document.implementation.createDocument(&quot;http://www.w3.org/1999/xhtml&quot;,&quot;html&quot;,doctype); // DOM2级HTML模块也为document.implementation新增了一个方法，名叫createHTMLdocument()。这个方法用途是创建一个完整的HTML文档，包括&lt;html&gt;、&lt;head&gt;、&lt;title&gt;和&lt;body&gt;元素。这个方法只接受一个参数，即新创建文档的标题(放在&lt;title&gt;元素中的字符串)，返回新的HTML文档。 // var htmldoc = document.implementation.createHTMLDocument(&quot;New Doc&quot;); // console.log(htmldoc.title); // console.log(typeof htmldoc.body); // 3.Node类型的变化 // Node类型中唯一与命名空间无关的变化，及时添加了isSupported()方法。用于确定当前节点具有什么能力。 // if(document.body.isSupported(&quot;html&quot;, &quot;2.0&quot;))&#123; // 执行只有“DOM2 级HTML”才支持的操作 // &#125; // DOM3级引入了两个辅助比较节点的方法 isSameNode() 和isEqualNode()。这两个方法都接收一个节点参数，并在窜入节点与引用的节点相同或相等时返回true。所谓相同，指的是两个节点引用的是同一个对象。 // var div1 = document.createElement(&apos;div&apos;); // div1.setAttribute(&apos;class&apos;,&apos;box&apos;); // var div2 = document.createElement(&apos;div&apos;); // div2.setAttribute(&apos;class&apos;, &apos;box&apos;); // console.log(div1.isSameNode(div2)); // console.log(div1.isEqualNode(div2)); // console.log(div1.isSameNode(div2)); // DOM3级还针对DOM节点添加额外数据引入了新方法。其中，setUserData() 方法会将数据指定节点，它接受3个参数：要设置的键、实际的数据（可以是任何数据类型）和处理函数。一下代码可以将数据指定给一个节点。 // document.body.setUserData(&quot;name&quot;,&quot;Nicholas&quot;,function()&#123;&#125;); // var value = document.body.getUserData(&quot;name&quot;); // 传入 setUserData()中的处理函数会在带有数据的节点被复制、删除、重命名或引入一个文档时调用，因而你可以实现决定在上述操作发生时如何处理用户数据。处理函数接受5个参数：表示操作类型的数值（1 - 表示复制 2 - 表示导入 3 - 表示删除 4 - 表示重命名）、数据键、数据值、源节点和目标节点。再删除节点时，源节点null；复制节点时，目标节点时null。 // var div = document.createElement(&apos;div&apos;); // div.setUserData(&apos;name&apos;,&apos;Nicholas&apos;,function(operation,key,value,src,dest)&#123; // if(operation === 1)&#123; // dest.setUserData(key,value,function()&#123;&#125;); // &#125; // &#125;); // var newDiv = div.cloneNode(true); // console.log(newDiv.getUserData(&apos;name&apos;)); // 4.框架的变化 // 框架和内嵌框架分别用HTMLFrameElement和HTMLFrameElement表示，它们在DOM2级中都有了一个新属性，名叫contentDocument。这个属性包含一个指针，指向表示框架内容的文档对象。 // var iframe = document.getElementById(&apos;myIframe&apos;); // var iframeDoc = iframe.contentDocument; // 在IE8以前的版本中无效 // IE8之前支持的一个属性contentWindow的属性。改属性返回框架的window对象，而这个window对象又有一个document属性。因此，要向在上述所有浏览器汇总访问内嵌框架的文档对象 // var iframe = document.getElementById(&apos;myIframe&apos;); // var iframeDoc = iframe.contentDocument || iframe.contentWindow.document; // 样式 // 访问元素的样式 // css属性 —— javascript属性 // background-image style.backgroundImage // color style.color // display style.display // font-family style.fontFamily // 1.DOM样式属性和方法 // DOM2级样式规范还未style对象定义了一些属性和方法。 // cssText: 通过它能够访问到style特性中的CSS代码。 // length: 应用给元素的CSS属性的数量 // parentRule: 表示CSS信息CSSRule对象。 // getPropertyCSSValue(propertyName): 返回包含给定属性值的CSSValu对象。 // getProperPriority(propertyName): 如果给定属性使用了!important设置，则返回“important”,否则返回空字符串。 // getPropertyValue(propertyName): 返回给定属性的字符串值。 // item(index): 返回给定位置的CSS属性的名称。 // removeProperty(propertyName): 从样式中删除给定属性。 // setProperty(propertyName,value,priority): 将给定属性设置为相应的值，并加上优化权标志（“important”或者一个空字符串）。 // 2.计算的样式 // DOM2级样式增强了document.defaultView，提供了getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个微元素字符串（例如：“:after”）.如果不需要伪元素信息，第二个参数可以是null。getComputedStyle()方法返回一个CSSStyleDeclaration对象（与style属性的类型相同），其中包含当前元素的所有计算的样式。 // 操作样式表 // CSSStyleSheet类型表示的是样式表，报错通过&lt;link&gt;元素包含的样式表在&lt;sytle&gt;元素中定义的样式表。从StyleSheet接口继承而来的属性如下： // disabled: 表示样式表是否被禁用的布尔值。 // href：如果样式表示通过&lt;link&gt;包含的，则样式表的URL，否则，是NULL。 // media：当前样式表支持的所有媒体类型的集合。 // ownerNode：指向拥有当前样式表的节点的指针。样式表可能在HTML通过&lt;link&gt;或&lt;style/&gt;引入的（在XML中可能是通过处理指令引入的）。如果当前样式表是其他样式表通过@import导入的情况下，这个属性值为null。 // parentStyleSheet：在当前样式表是通过@import导入的情况下，这个属性是一个指向导入他的样式表的指针。 // title：ownerNode中title属性的值。 // type：表示样式表类型的字符串。 // cssRule：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为null。 // deleteRule(index)：删除cssRules集合中指定的位置插入rule字符串。 // insertRule(rule, index)：向cssRules集合中指定的位置插入rule字符串。 // 1.CSS规则 // cssText：返回整条规则对应的文本。 // parentRule：如果当前规则是导入的规则，这个属性应用就是导入规则；否则，这个值为null。 // parentStyleSheet：当前规则所属的样式表。 // selectorText：返回当前规则的选择符文本。 // style：一个CSSStyleDeclaration对象，可以通过它设置或取得规则中特性的样式值。 // type: 表示规则类型的常量值。 // 2.创建规则 // insertRule()方法。这个方法接受两个参数：规则文本和表示在哪里插入规则的索引。 // 3.删除规则 // deleteRule()方法，这个方法接受一个参数：要删除的规则的位置。 // 元素大小 // 1.偏移量 - 包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意：不包括外边距）。有4个属性可以取得元素偏移量： // offsetHeight：元素在垂直方向上占用的空间大小，以像素计。 // offsetWidth：元素在水平方向上占用的空间大小，以像素计。 // offsetLeft：元素左外边框至包含元素的左内边距之间的像素距离。 // offsetRight：元素上外边框至包含元素的上内边框之间的像素距离。 // 2.客户区大小 - 元素内容及其内边距所占据的空间大小。 // clientWidth：元素内容区宽度加上左右边距宽度。 // clientHeight：元素内容区高度加上上下内边距高度。 // 3.滚动大小 - 包含滚动内容的元素大小。 // scrollHeight：在没有滚动条的情况下，元素内容的总高度。 // scrollWidth：在没有滚动条的情况下，元素内容的总宽度。 // scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。 // scrollTop: 被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。 // 4.确定元素大小 // getBoundingClientRect()方法。这个方法返回一个矩形对象，包含4个属性：left、top、right和bottom。 // 遍历 // DOM2级遍历和范围模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优化的遍历操作。 // 检测浏览器对DOM2级遍历能力的支持情况 // var supportsTraversale = document.implementation.hasFocus(&quot;Traversal&quot;, &apos;2.0&apos;); // var supportsNodeIterator = (typeof document.createNodeIterator === &quot;function&quot;); // var supportaTreeWalker = (typeof document.createTreeWalker === &quot;function&quot;) // createNodeIterator(root: Node, whatToShow?: unsigned long, filter?: NodeFilter) // 这个方法接受下列4个参数： // root：想要座位搜索起点的树中的节点。 // whatToShow：表示要访问哪些节点的数字代码。 // filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝谋众特定节点的函数。 // entityReferenceExpansion：布尔值，便是是否要扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展。 // whatToShow参数是一个位掩码，通过应用一个或多个过滤器（filter）来确定要访问哪些节点。这个参数与的值以常量形式在NodeFilter类型中定义，如下所示： // NodeFilter.SHOW_All：显示所有类型的节点。 // NodeFilter.SHOW_ELEMENT：显示元素节点。 // NodeFilter.SHOW_ATTRIBUTE：显示特性节点。 // NodeFilter.SHOW_TEXT：显示文本节点。 // NodeFilter.SHOW_CDATA_SECTION：显示CDAT节点。对HTML页面没有用。 // NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没有用。 // NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没有用。 // NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没有用。 // NodeFilter.SHOW_COMMENT：显示注释节点。 // NodeFilter.SHOW_DOCUMENT：显示文档节点。 // NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型的节点。 // NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段的节点。对HTML页面没有用。 // NodeFilter.SHOW_NOTATION：显示符合节点。对HTML页面没有用。 // TreeWalker，是NodeIterator的一个更高级的版本。除了包括nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。 // parentNode()：遍历当前节点的父节点。 // firstChild()：遍历当前节点的第一个子节点。 // lastChild()：遍历当前节点的最后一个子节点。 // nextSibling()：遍历当前节点的下一个同辈节点。 // previousSibling()：遍历当前节点的上一个同辈节点。 // 创建TreeWalker对象要使用document.createTreeWalker(root: Node, whatToShow?: unsigned long, filter?: NodeFilter)方法，这个方法接受4个参数与document.createNodeIterator(root: Node, whatToShow?: unsigned long, filter?: NodeFilter)方法相同： // 作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。 // var div = document.getElementById(&apos;div1&apos;); // var filter = function(node)&#123; // return node.tagName.toLowerCase() === &quot;li&quot; ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; // &#125;; // var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, filter, false); // var node = iterator,nextNode(); // while(node !== null)&#123; // console.log(node.tagName); // 输出标签名 // node = iterator.nextNode(); // &#125; // 范围，DOM2级遍历和范围模块定义了范围接口。 // DOM中的范围 // DOM2级在Document类型中定义了createRange()方法。每个范围由一个Range类型的实例来表示，这个实例拥有很多属性和方法： // startContainer：包含范围起点的节点（即选区中第一个节点的父节点） // startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本节点、注释节点或CDATA节点，那么startOffset就是范围起点之前跳过的字符数量。否则startOffset就是范围中第一个子节点的索引。 // endContainer：包含范围重点的节点（即选区中最后一个节点的父节点） // endOffset：范围在endContainer中终点的偏移量（与startOffset遵循相同的取值规则）。 // commonAncestorContainer：startContainer和endContainer共同的祖先节点在文档树中位置最深的那个。 // setStartBefore(refNode)：将范围的起点设置在refNode之前，因此refNode也就是范围选区中的第一个子节点。同事会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引。 // setStartAfter(refNode)：将范围的起点设置在refNode之后，因此refNode也就不再范围之内了，其下一个同辈节点才是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引加1. // setEndBefore(refNode)：将范围的重点设置在refNode之前，因此refNode也就不再范围之内了，其上一个同辈节点才是范围选区中的最后一个子节点。同时会将endContainer属性设置为refNode.parentNode，将endOffset属性设置为refNode再其父节点的childNodes集合中的索引。 // setEndAfter(refNode)：将范围的重点设置在refNode之后，因此refNode也就是范围选区中的最后一个子节点。同时会将endCOntainer属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNode集合中的索引加1. // 1.用DOM范围实现简单选择 // &lt;!DOCTYPE html&gt; // &lt;html&gt; // &lt;head&gt; // &lt;meta charset=&quot;utf-8&quot;&gt; // &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; // &lt;title&gt;&lt;/title&gt; // &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt; // &lt;/head&gt; // &lt;body&gt; // &lt;p id=&quot;p1&quot;&gt; // &lt;b&gt;Hello&lt;/b&gt; world! // &lt;/p&gt; // &lt;/body&gt; // &lt;/html&gt; // var range1 = document.createRange(); // range2 = document.createRange(); // p1 = document.getElementById(&apos;p1&apos;); // range1.selectNode(p1); // range2.selectNodeContents(p1); // 2.用DOM范围实现复杂选择 // 要创建复杂的范围就得使用setStart()和setEnd()方法。这两个方位都接受两个参数：一个参展节点和一个偏移量。 // 3.操作DOM范围中的内容 // deleteContents()，这个方法能够从文档中删除范围所包含的内容。 // extractContents()，也会从文档中移出范围选区。会返回范围的文档片段。 // cloneContents()，创建范围对象的一个副本，然后在文档的其他地方插入该副本。返回范围中节点的副本。 // 4.插入DOM范围中的内容 // insertNode()可以向范围选区的开始处插入一个节点。 // surroundContents(newParent: Node)，环绕范围插入节点，这个方法接受一个参数，即环绕范围内容的节点。 // 5.折叠DOM范围 // collapse()方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠刀范围的哪一端。 // 6.比较DOM范围 // compareBoundaryPoints(how: unsigned short, sourceRange: Range) 方法来确定这些范围是否有公共的边界（起点或重点）。这个方法接受两个采纳数：表示比较方式的常量值和要比较的范围。 // 7.复制DOM范围 // cloneRange() // 8.清理DOM范围 // 在使用完范围之后，最好是调用detach()方法，以便从创建范围的文档中分离出该范围。 // range1.detach(); // 从文档中分离 // range1 = null; // 解除引用 // IE8及更早版本中的范围 &#125;)() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript DOM扩展]]></title>
    <url>%2F2019%2F09%2F16%2FJavaScript-DOM%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;JavaScript DOM扩展&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/transitions.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot; id=&quot;box&quot; name=&quot;box&quot; title=&quot;box&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt; &lt;!-- &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;第一个节点&lt;/li&gt; &lt;li&gt;第二个节点&lt;/li&gt; &lt;li&gt;第三个节点&lt;/li&gt; &lt;li&gt;第四个节点&lt;/li&gt; &lt;li&gt;第五个节点&lt;/li&gt; &lt;/ul&gt; --&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 立即执行函数 (function () &#123; // 严格模式 &quot;use strict&quot;; // JavaScript单线程设计的初衷就是为了操作DOM元素 // Node类型 // if (someNode.nodeType === Node.ELEMENT_NODE) &#123; // // 在IE中无效 // console.log(&quot;node is an element&quot;); // if (someNode.nodeType === 1) &#123; // // 适用所有浏览器 // console.log(&quot;node is an element&quot;); // &#125; // &#125; // nodeName的值是元素的标签名 nodeValue的值始终是null // if (someNode.nodeType === 1) &#123; // value = someNode.nodeName; // &#125; // 节点关系 childNodes firstNode lastNode parentNode nextSibling perviousSlibling // var firstChild = someNode.childNodes[0]; // var secondChild = someNode.childNodes.item[1]; // var count = someNode.childNodes.length; // 操作节点 // appendChild() 向childNodes列表的末尾添加一个节点 // insertBefore() 参数：要插入的节点，作为参照的节点。 被插入的节点会变成参照节点前的一个同胞节点previousSlibing，同时方法被返回。如果参照节点为null，则执行结果与appendChild()相同。 // replaceChild() 参数：要插入的节点，要替换的节点。 // removeChild() 参数：要移出的节点 // 其他方法： cloneNode() 用于创建调用这个方法的节点的一个完全相同的副本。 // var list = document.getElementById(&apos;list&apos;); // var clist = list.cloneNode(true); // console.log(clist.childNodes.length) // var clonelist = list.cloneNode(false); // console.log(clonelist.childNodes.length) // document方法 // 对HTML的引用 var html = document.documentElement; console.log(html === document.childNodes[0]); console.log(html === document.firstChild); // 对Body的引用 var body = document.body; // 对&lt;!DOCTYPE&gt;的引用 var doctype = document.doctype; // 设置文档标题 document.title = &apos;标题&apos;; // 取得完整URL console.log(document.URL); // 取得域名 console.log(document.domain); // 取得来源页面的URL console.log(document.referrer); // 查找元素 // document.getElementById(&apos;id&apos;) 通过元素ID获取节点。 var div = document.getElementById(&apos;box&apos;); // document.getElementByName(&apos;name&apos;) 通过元素Name获取节点。 var box = document.getElementsByName(&apos;box&apos;); // document.getElementByTabName(&apos;div&apos;) 通过元素标签获取节点。 var tagDiv = document.getElementsByTagName(&apos;div&apos;); // htmlControl console.log(tagDiv.length); console.log(tagDiv.item(0).className); // document.getElementByTagName(&apos;*&apos;) 返回所有注释的节点 console.log(document.getElementsByTagName(&apos;*&apos;)); // 特殊集合 // document.anchors 包含文档中所有带name特性的a元素 console.log(document.anchors); // document.forms 包含所当中所有form元素 console.log(document.forms); // document.images 包含文档中所有image元素 console.log(document.images); // document.links 包含文档中所有带有href特性的a元素 console.log(document.links); // Dom一致性检测 浏览器支持此给定名称及版本的功能，则返回true var hasXmlDom = document.implementation.hasFeature(&apos;XML&apos;, &apos;1.0&apos;); console.log(hasXmlDom); // 文档写入 document.writeln(&apos;我是无敌的！&apos;); // 会在字符串末尾添加一个换行\n document.write(&apos;我就是超级无敌宇宙赛亚人！&apos;); // 要写入输出流的文本 document.open() // 打开网页的输出流 document.close() // 关闭网页的输出流 // element类型 var dbox = document.getElementById(&apos;box&apos;); // 适用于任何文档 if(dbox.tagName.toLowerCase === &apos;div&apos;)&#123; return true; &#125; // html元素 console.log(dbox.id); console.log(dbox.className); console.log(dbox.title); console.log(dbox.lang); console.log(dbox.dir); // 取得特性 console.log(dbox.getAttribute(&apos;id&apos;)); // 删除特性 console.log(dbox.removeAttribute(&apos;class&apos;)) // 设置特性 console.log(dbox.setAttribute(&apos;class&apos;,&apos;box&apos;)); // attributes 属性 // attributes.getNamedItem(name) 返回nodeName属性等于name的节点 // attributes.removeNamedItem(name) 从列表中移除nodeName属性等于name的节点 // attributes.setNamedItem(node) 向列表中添加节点，以节点的nodeName属性为索引 // attributes.item(pos) 返回位于数字pos位置出的节点 console.log(dbox.attributes.length); // attributes.specified 默认值为false console.log(dbox.attributes.specified); // 创建元素 var div = document.createElement(&apos;div&apos;) document.getElementById(&apos;box&apos;).appendChild(div); // 元素的子节点 for(var i = 0; i &lt; document.childNodes.length; i++)&#123; if(dbox.childNodes[i].nodeType === 1)&#123; return true; &#125; &#125; // Text类型 // appendData(text) 将text添加到节点的末尾 // deleteData(offset, count) 从offset指定位置开始删除count个字符 // instertData(offset, text) 在offset指定的位置插入text // replaceData(offset, count, text) 用text替换从offset指定的位置开始到offset+count为止处的文本 // splitText(offset) 从offset指定的位置将当前文本节点分成两个文本节点 // substringData(offset, count) 提取从offset指定的位置开始到offset+count为止出的字符串 // length属性 // 创建文本节点 document.createTextNode(&apos;文本节点&apos;) // 规范化文本节点 // normalize() // 分割文本节点 // splitText(offset: unsigned long) // Comment类型 CDATASection类型 // comment类型、CDATASection类型与text类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法。 // DocumentType类型 console.log(document.doctype) // DocumentFragment类型 // document fragment 是一种轻量级文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。 // 创建文档片段 document.createDocumentFragment() // Attr类型 // Attr对象有三个属性：name, value, specified // Dom操作技术 // 动态脚本 var js = document.createElement(&apos;script&apos;); js.type = &apos;text/javascript&apos;; document.body.appendChild(js); // 动态样式 function loadStyle(url)&#123; var link = document.createElement(&apos;link&apos;); link.rel = &apos;stylesheet&apos;; link.type = &apos;text/css&apos;; link.href = url; var head = document.getElementsByTagName(&apos;head&apos;)[0]; head.appendChild(link); &#125; loadStyle(&quot;style.css&quot;); // 操作表格 // &lt;table&gt; 的属性和方法 // caption 保存着对&lt;caption&gt;元素的指针 // tBodies 是一个&lt;tbody&gt;元素的HTMLCollection // tFoot 保存着对&lt;tfoot&gt;元素的指针 // tHead 保存着对&lt;thead&gt;元素的指针 // rows 是一个表格所有行的HTMLCollection // createTHead() 创建&lt;thead&gt;元素，将其放到表格中，返回引用 // createTFoot() 创建&lt;tfoot&gt;元素，将其放到表格中，返回引用 // createCaption() 创建&lt;caption&gt;元素，将其放到表格中，返回引用 // deleteTHead() 删除&lt;thead&gt;元素 // deleteTFoot() 删除&lt;tfoot&gt;元素 // deleteCaption() 删除&lt;caption&gt;元素 // deleteRow(pos) 删除指定位置的行 // insertRow(pos) 向rows集合中指定位置插入一行 // &lt;tbody&gt; 的属性和方法 // rows 保存&lt;tbody&gt;元素中的HTMLCollection // deleteRow(pos) 删除指定位置的行 // insertRow(pos) 向rows集合中指定位置插入一行 // &lt;tr&gt; 的属性和方法 // cells 保存着&lt;tr&gt;元素中单元格的HTMLCollection // deleteCell(pos) 删除指定位置的单元格 // insertCell(pos) 向cells集合中的指定为会插入一个单元格，返回对新插入的单元格的引用 // 使用NodeList // querySelector() 方法 接收一个CSS选择符，返回与该模式匹配的第一个元素，没有则返回null var body = document.querySelector(&apos;body&apos;); // querySelectorAll() 方法 接收一个CSS选择符，返回与该模式匹配的所有元素，没有则返回null var stongs = document.querySelectorAll(&apos;p strong&apos;); // matchesSelector() 方法 接收一个CSS选择符，如果调用元素与该选择符匹配，则返回true，否则，返回false. matchesSelector(document.body, &quot;body.page1&quot;) // 元素遍历 // childElementCount 返回子元素的个数 // firstElementChild 指向第一个子元素：firstChild的元素版 // lastElementChild 指向最后一个子元素：lastChild的元素版 // previousElementSibling 指向前一个同辈元素：previousSibling的元素版 // nextElementSibling 指向后一个同辈元素：nextSibling的元素版 // HTML // 与类相关的扩充 // getElementsByClassName()方法 接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList // classList属性 这个classList属性是新集合类型DOMTokenList的实例 // add(value) 将给定的字符串值添加到列表中。如果值已经存在，就不添加了 // contains(value) 表示列表中是否存在给定的值，返回true/false // remove(value) 从列表中删除给定的字符串 // toggle(value) 如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它 // 焦点管理 // document.activeElement 属性 // HTML5添加了辅助管理DOM焦点的功能。首先是document.activeElement属性。这个属性始终会引用DOM中当前获得焦点的元素 // document.hasFocus()方法 确定文档是否获得了焦点 // HTMLDocument的变化 // readyState属性值：loading，正在加载文档 | complete，已经加载完文档 // 兼容模式 compatMode的属性 if (document.compatMode === &quot;CSS1Compat&quot;) &#123; console.log(&apos;Standards mode&apos;); &#125; else &#123; console.log(&apos;Quirks mode&apos;); &#125; // head属性 document.head // 字符集属性 document.charset = &quot;UTF-8&quot;; //自定义数据属性 // 设置值 // document.getElementById(&apos;box&apos;).dataset.appId = 123 // document.getElementById(&apos;box&apos;).dataset.myname = &quot;Michael&quot; // if (document.getElementById(&apos;box&apos;).dataset.myname) &#123; // console.log(document.getElementById(&apos;box&apos;).dataset.myname); // &#125; // 插入标记 // div.innerHTML = &quot;&lt;input type=\&quot;hidden\&quot;&gt;&lt;script&gt;alert(&apos;hi&apos;);&lt;\/script&gt;&quot;; // outerHTML属性 // 返回调用他的元素及所有子节点的HTML标签 // div.outerHTML = &quot;&lt;p&gt;This is a paragrph.&lt;/p&gt;&quot; // insertAdjacentHTML()方法 // beforebegin 在当前元素之前插入一个紧邻的同辈元素 // element.insertAdjacentHTML(&quot;beforebegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); // afterbegin 在当前元素之下插入一个新的子元素火灾第一个子元素之前再插入新的子元素 // element.insertAdjacentHTML(&quot;afterbegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); // beforeend 在当前元素之下插入新的子元素或最后一个子元素之后再插入新的子元素 // element.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); // afterend 在当前元素之后插入一个紧邻的同辈元素 // element.insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;); // 内存和性能问题 // 在替换子节点可能会导致浏览器的内存占用问题。在使用innerHTML、outerHTML、insertAdjacentHTML方法时，最好手工删除要被替换的元素的所有回见处理程序和JavaScript对象属性。 // scrollIntoView()方法 // 可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。 // 传入true作为参数，或者不传入任何参数时，串口滚动之后会让调用元素的顶部与视口尽可能平齐 // 传入false作为参数，调用元素会尽可能全部出现在视口中，（可能的话，调用元素的底部会与视口顶部平齐。）不过顶部不一定平齐 // 让元素可见 // document.forms[0].scrollIntoView(); // 文档模式 // &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content = &apos;IE=IEVersion&apos;&gt; // IEVersion： // Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。 // EmulateIE9：如果有文档类型声明，则以IE9标准模式渲染页面，否则将文档模式设置为IE5。 // EmulateIE8：如果有文档类型声明，则以IE8标准模式渲染页面，否则将文档模式设置为IE5。 // EmulateIE7：如果有文档类型声明，则以IE7标准模式渲染页面，否则将文档模式设置为IE5。 // 9：强制以IE9标准模式渲染页面，忽略文档类型声明。 // 8：强制以IE8标准模式渲染页面，忽略文档类型声明。 // 7：强制以IE7标准模式渲染页面，忽略文档类型声明。 // 5：强制以IE5标准模式渲染页面，忽略文档类型声明。 // children属性 只包含元素中同样还是元素的子节点 // var childCount = element.children.length; // contains()方法 // 调用contains()方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检查的后代节点。返回值 true/false // document.documentElement.contains(document.body); // 插入文本 // innerText 属性 可以操作元素中包含的所有文本内容，包括子文档树中的文本。 // div.innerText = &quot;Hello world!&quot; // outerText 属性 读取文本内容 // console.log(div.outerText) // 滚动 // scrollIntoViewIfNeeded() 只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。 // scrollByLines() 将元素的内容滚动指定的行高 // scrollByPages() 将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。 // document.body.scrollIntoViewIfNeeded(true) // 将页面主体滚动5行 // document.body.scrollByLines(5) // 将页面主体滚动1页 // document.body.scrollByPages(-1) &#125;)(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 数组]]></title>
    <url>%2F2019%2F09%2F16%2FJavaScript-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;script type=&quot;text/javascript&quot;&gt;// 立即执行函数(function () &#123; // 严格模式 &quot;use strict&quot;; var arr = [1, 3, 5, 3, 21, 5]; if (typeof (arr)) &#123; console.log(&apos;此数据类型为对象&apos;); // 检测数组 isArray返回 true or false if (Array.isArray(arr)) &#123; console.log(&apos;此对象为数组对象&apos;); // 数组的转化 console.log(arr.toString()); var list = new Array(); // 栈方法：LIFO(后进先出) list.push(&apos;张三&apos;, &apos;李四&apos;, &apos;王五&apos;); console.log(list); console.log(list.pop()); console.log(list); // 队列方法：FIFO(先进先出) list.unshift(&apos;陈六&apos;, &apos;赵七&apos;); console.log(list); console.log(list.shift()); console.log(list); // 数组重排 list.reverse(); console.log(list); // 升序排序 list.sort(); console.log(list); // 操作方法 console.log(list.concat(&apos;钱八&apos;, [&apos;豆豆&apos;, &apos;豆花&apos;])); console.log(list.slice(1, 4)); console.log(list); // 删除 console.log(list.splice(0, 1)); console.log(list); // 插入 console.log(list.splice(0, 0, &apos;花花&apos;, &apos;毛毛&apos;)); console.log(list); // 替换 console.log(list.splice(2, 1, &apos;二狗子&apos;, &apos;铁头&apos;)); console.log(list); // 位置方法 console.log(list.indexOf(&quot;二狗子&quot;)); console.log(list.lastIndexOf(&quot;铁头&quot;)); // 迭代方法 // every() 对数组中的每一项给定函数，若该函数都返回true，则返回true console.log(list.every(function (item, index, arry) &#123; return typeof (item) === &apos;string&apos;; &#125;)); /**************************/ list.push(1, 4, 5, 7, 21, 100); console.log(list); /**************************/ // some() 对数组中的每一项给定函数，若该函数有一项返回true，则返回true console.log(list.some(function (item, index, arry) &#123; return typeof (item) === &apos;string&apos;; &#125;)); // filter() 对数组中的每一项给定函数，返回该函数返回true的项组成新的数组 console.log(list.filter(function (item, index, arry) &#123; return item === &apos;二狗子&apos;; &#125;)); // forEach() 对数组中的每一项给定函数。这个方法没有返回值 console.log(list.forEach(function (item, index, arry) &#123; console.log(item); &#125;)); // map() 对数组中的每一项给定函数，返回每次函数调用的结果组成的数组 console.log(list.map(function (item, index, arry) &#123; return item &gt; 0; &#125;)); // 缩小方法 // reduce() 从第一项向后叠加 console.log(list.reduce(function (prev, cur, index, array) &#123; return prev + cur; &#125;)) // reduceRight 从最后一项向第一项叠加 console.log(list.reduceRight(function (prev, cur, index, array) &#123; return prev + cur; &#125;)) &#125; &#125; else &#123; // console.log(typeof(arr)) console.log(&apos;数据类型非数组&apos;); &#125; // 数据基本类型：null undefined number string object boolean // 从这里我们可以看出typeof验证数据的返回类型：undefined、boolean、string、number、object、function&#125;)();&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES5 核心]]></title>
    <url>%2F2019%2F09%2F11%2FES5-%E6%A0%B8%E5%BF%83%2F</url>
    <content type="text"><![CDATA[作用域在 JavaScript 中, 作用域（scope，或译有效范围）就是变量和函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。在ES5中没有块级作用域的概念。 全局作用域（Global Scope）：最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的。 局部作用域（Local Scope）：和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部。 如果局部作用域的“预解析空间”（AO-活动对象（Active object））没有找到，那么代码会从上一级的作用域寻找，上级作用域不能在下级作用域寻找。 注意事项： 需要注意的是，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！ 只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明” 作用域链（Scope Chain）通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。当执行函数时，总是先从函数内部找寻局部变量；如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上。 执行环境（execution context）：JavaScript为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。 闭包 可以读取自身函数外部的变量（沿着作用域链寻找） 让这些外部变量始终保存在内存中 js函数内的变量值不是在编译的时候就确定的，而是等在运行时期再去寻找的。 模块 必须有外部的封闭函数，该函数至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改其他私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。 this对象“谁调用指向谁” this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象调用时，this等于那个对象。不过，匿名函数具有全局性，因此this对象同常指向window。 严格模式 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 消除代码运行的一些不安全之处，保证代码运行的安全 为未来新版本的Javascript做好铺垫 在使用严格模式的时候在全局或函数的第一条语句需定义为: ‘use strict’; 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用 主要内容： 必须用var声明变量（混杂模式中可以直接使用变量而不定义，但是这种做法会对后期造成很大的麻烦） 创建eval作用域 禁止this指向window 对象不能用重名的属性 函数不能有重名的形参 12345678910111213141516171819&apos;use strict&apos;; //在全局或函数内第一行书写//1.变量必须使用var 定义 否则报错str=&quot;xxx&quot;;//2.函数内的this指向不再是windowfunction Person(name,age) &#123; console.log(this);//undefined this.name=name;//相当于设置undefined.name =name 报错 this.age=age; &#125;//3.让eval有自己的作用域 var str =123; eval(&apos;var str=456;alert(str)&apos;);//456 alert(str);//123//4.对象不能用重名属性var obj =&#123; username:&apos;kobe&apos;, username:&apos;zs&apos; &#125; console.log(obj);//运行时没有报错,不过编辑器内有提示 最好别这么写就是了 json对象JSON.stringify(obj/arr)js对象（数组）转换为json对象（数组）JSON.parse(json)json对象（数组）转换为js对象（数组） 12345var obj=&#123;username:&quot;mike&quot;&#125;;obj=JSON.stringify(obj);console.log(typeof obj);//json对象和数组，不要说json字符串//json是一种传输数据的格式，还有xml。 object对象方法扩展ES5给Object扩展了好一些静态方法, 常用的2个: Object.create(prototype[, descriptors]) : 创建一个新的对象 以指定对象（prototype）为原型创建新的对象 指定新的属性, 并对属性进行描述value : 指定值writable : 标识当前属性值是否是可修改的, 默认为trueget : 用来得到当前属性值的回调函数set : 用来监视当前属性值变化的回调函数 1234var obj=&#123;username:&quot;damu&quot;,age:30&#125;;var obj1=&#123;&#125;;obj1=Object.create(obj); //Object是obj1上一级的构造函数，调用他所具有的函数creatconsole.log(obj1); //也就是obj1可以继承obj的属性username和age 1234567891011121314151617181920var obj=&#123;username:&quot;damu&quot;,age:30&#125;;var obj1=&#123;&#125;;obj1=Object.create(obj,&#123;sex:&#123; value:&quot;男&quot;, writable:true,//有一个writable属性：标识当前属性值是否是可以修改的，默认为false configurable:true,//有一个属性configurable：标识当前属性是否可以被删除 enumerable:true //有一个属性enumerable：标识当前属性是否能用for in枚举 默认为false&#125;&#125; //对当前扩展属性的描述&#125;); //使用create给obj1添加扩展属性console.log(obj1.sex);obj1.sex=&quot;女&quot;console.log(obj1.sex);delete obj1.sex;//规定不能直接删掉，有一个属性configurable：标识当前属性是否可以被删除，默认为falseconsole.log(obj1.sex);for(var i in obj1)&#123;console.log(i)//for in 找不到obj1使用create扩展出来的属性//有一个属性enumerable：标识当前属性是否能用for in枚举 默认为false&#125; Object.defineProperties(object,descriptors)作用：为指定object对象定义扩展多个属性get：用来获取当前属性值的回调函数set：修改当前属性值的触发的回调函数，并且实参即为修改后的值存取器属性：setter，getter一个用来存值一个用来取值 1234567891011121314151617181920212223242526272829303132333435363738394041var obj2=&#123;firstName:&quot;kobe&quot;,lastName:&quot;bryant&quot;&#125;;Object.defineProperties(obj2,&#123;fullName:&#123; get:function () &#123;//使用get来获取扩展属性的值 return this.firstName+&quot; &quot;+this.lastName//fullName想要设置的值 &#125;, set:function (data) &#123;//监听扩展属性，当扩展属性发生变化时自动调用后会将变化的值作为实参注入到set函数。 console.log(&quot;set()&quot;,data); var names=data.split(&quot; &quot;); this.firstName=names[0]; this.lastName=names[1]; &#125;&#125;//创建一个配置对象&#125;)console.log(obj2.fullName)obj2.fullName=&quot;haha heih&quot;;console.log(obj2.fullName)//get方法什么时候调用？ 获取扩展属性值的时候，get方法自动调用//对象本身的两个方法：//get propertyName()&#123;&#125;//set propertyName()&#123;&#125;var objj=&#123;age:15,tall:180,get all()&#123; return this.age+&quot; &quot;+this.tall;&#125;,set all(data)&#123; console.log(&quot;set()&quot;,data); var names=data.split(&quot; &quot;); this.age=names[0]; this.tall=names[1];&#125;&#125;console.log(objj);objj.all=&quot;13 189&quot;;console.log(objj); 数组扩展 Array.prototype.indexOf(value):得到值在数组中的第一个下标,输入第一个3的下标 Array.prototype.lastIndexOf(value):得到值在数组中的最后一个下标 Array.prototype.forEach(function(item,index){}):遍历数组 Array.prototype.map(function(item,index){}):遍历数组返回一个新的数组，返回加工之后的值 Array.prototype.filter(function(item,index){}):遍历过滤出一个新的子数组，返回条件为true的值 123456789101112131415161718var arr=[2,3,5,1,4,6,3];console.log(arr.indexOf(3)); //输出第一个6的下标console.log(arr.lastIndexOf(3)); //输出最后一个6的下标arr.forEach(function(item,index)&#123; console.log(item+&quot; &quot;+index) //输出所有元素的值和下标&#125;)var arr1=arr.map(function(item,index)&#123; return item+10;&#125;);console.log(arr1); //根据arr产生一个新数组，要求每个元素比原来大10var arr2=arr.filter(function(item,index)&#123; return item &gt; 4; &#125;)console.log(arr2); //根据arr产生一个新数组，返回的每个元素都要大于4 bind()、call()、apply()的区别123456789101112131415161718192021222324var obj=&#123;username:&quot;kobe&quot;&#125;;function foo(data)&#123; console.log(this,data)&#125;// foo();//自调用时this指向的是window，使this指向我们定义的objfoo.call(obj);foo.apply(obj);//call和apply在不传参的情况下使用方式是一样的//区别function foo(data)&#123; console.log(this,data)&#125;foo.call(obj,33); //直接传入参数foo.apply(obj,[33]); //传入数据必须写在数组里//bindvar bar=foo.bind(obj,33);//绑定完this有一个返回值，不会立即调用当前函数而是将函数返回,通常用来指定回调函数的this。用bar来接收返回的函数然后执行bar();// 也可写成foo.bind(obj,33)()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 代码约定]]></title>
    <url>%2F2019%2F09%2F11%2FJavaScript-%E4%BB%A3%E7%A0%81%E7%BA%A6%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[可维护性 可理解性 直观性 可适应性 可扩展性 可调试性 代码约定 函数和方法：每个函数或方法都应该包含一个注释，描述其目的和用于完成任务所可能使用的算法。陈述实现的假设也非常重要，汝参数代表什么，函数是否有返回值（因为这个不能从函数定中推断出来）。 大段代码：用于完成单个任务的多行代码应该再前面放一个描述任务的注释。 复杂的算法：如果使用了一种独特的方式解决某个问题，则要在主时钟解释你是如何做的。这不仅仅可以帮助其他浏览你代码的人，也能在你自己查阅代码的时候帮助理解。 Hack：因为存在浏览器差异，JavaScript代码一般会包含一些Hack。不要假设其他人在看代码的时候能够理解Hack索要应付的浏览器问题，如果因为其他浏览器无法使用普通的方法，所以扭腰用一些不同的方法，那么请假这些信息放在注释中。这样可以减少出现这种情况的可能性：有人偶然看到你的hack,然后“修正”了它，最后重新引入了你本来修正了的错误。缩进和注释可以带来更可读的代码，未来则更容易维护。 变量名应该为名词如：car或person 函数名应该以动词开始，如getName()。返回布尔类型值得函数一般以is开头，如：isEnable（）。 变量和函数都应使用呵护逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩来缓解。 变量类型透明 123456// 用于指定数据类型的匈牙利标记法var bFound; // 布尔型var iCount; // 整数var sName; // 字符串var oPerson; // 对象 松散耦合 解耦HTML/JavaScript 在Web上，HTML和JavaScript各自代表了解决方案中的不同层次：HTML是数据，JavaScript是行为。 1234567891011121314&lt;!-- 使用了&lt;script&gt;的紧密耦合 --&gt;&lt;script&gt; docment.write(&quot;hello world&quot;)&lt;/script&gt;&lt;!-- 使用时间处理程序属性值的紧密耦合的HTML/JavaScript --&gt;&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclilck=&quot;doSomething()&quot;&gt;// 将HTML紧密耦合到JavaScriptfunction insetMessage(msg)&#123; var container = docment.getElementById(&quot;container&quot;); container.innerHTML = &quot;&lt;div&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt;&quot;&#125; 解耦CSS/JavaScript 1234567891011// CSS对JavaScript的紧密耦合element.style.color = &quot;red&quot;;element.style.backgroundColor = &quot;blue&quot;;// CSS对JavaScript的松散耦合element.className = &quot;edit&quot;//JavaScript对CSS的紧密耦合div&#123; width: exprerssion(docment.body.offsetWidth - 10 + &quot;px&quot;);&#125; 解耦应用逻辑/事件处理程序 12345678910function handleKeyPress(event)&#123; event = EventUtil.getEvent(event); if(event.keyCode == 13)&#123; var target = EventUtil/getTarget(event); var value = 5 * parseInt(target.value); if(value &gt; 10)&#123; docment.getElementById(&quot;error-msg&quot;).style.display = &quot;block&quot;; &#125; &#125;&#125; 尊重对象所有权 不要为实例或原型添加属性 不要为实例或原型添加方法 不要冲定义已存在的方法 创建包含所需功能的新对象，并用它与相关对象进行交互 创建自定义类型，继承需要进行修改的类型。然后可以为定义类型添加额外功能。 避免全局量 避免与null进行比较 使用常量 重复值：任何在多出用到的值都应该抽取为一个常量。用户界面字符串：任何用于显示给用户的字符串，都应该抽取出来以便国际化。URLs：在Web应用中，资源位置很容易变更，所以推荐使用一个公共地方存放所有的URL。任意可能会更改的值：每当你再拥戴字面量值得时候，你都要问一下自己这个值字啊未来是不是会变化。 性能 作用域 避免全局查找 避免with语句 选择正确方法 避免不必要的属性查找 优化循环：减值迭代、简化终止条件、简化循环体、使用后测试循环 展开循环 避免双重解释 性能的其他注意事项：原生方法比较快、switch语句比较快、位运算比较快 最小化语句数 多个变量声明 插入迭代值 使用数组和对象字面量 优化DOM交互 最小化现场更新 使用innerHTML 使用事件代理 注意HTMLCollection 构建过程 知识产权问题：若果吧带有完整注释的代码放到线上，那别人就跟容易知道你的以图，对它再利用，并且可能找到安全漏洞。 文件大小：书写代码要保证容易阅读，才能更好地维护，但是这对于性能是不利的。浏览器不能从额外的空白字符或者是冗长的函数名和变量名中获得什么好处。 代码组织：组织代码要考虑到可维护性并不一定是传送给浏览器的最好方式。 验证 eval()的使用 未声明变量的使用 遗漏的分号 不恰当的换行 错误的逗号使用 语句周围遗漏的括号 switch分支语句中遗漏的break 重复声明的变量 with的使用 错误使用的等号（替代了双等号或三等号） 无法到达的代码 压缩 文件压缩 删除额外的空白（包括换行） 删除所有注释 缩短变量名 HTTP压缩 不过现在基本都是用ESlint语法检测工具、webpack压缩打包了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 离线与存储]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript-%E7%A6%BB%E7%BA%BF%E4%B8%8E%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[离线检测1234567891011121314// navigator.online属性if (navigator.online)&#123; // 正常工作&#125; else &#123; // 执行离线状态时的任务&#125;// online offline事件EventUtil.addHandler(window, &quot;online&quot;, function()&#123; alert(&quot;Online&quot;);&#125;)EventUtil.addHandler(window, &quot;offline&quot;, function()&#123; alert(&quot;Offline&quot;);&#125;) 应用缓存applicationCache对象，status属性： 0：无缓存，即没有与页面相关的应用缓存； 1：闲置，即应用缓存未得到更新； 2：检查中，即正在下载描述文件并检查更新； 3：下载中，即应用缓存正在下载描述文件中指定的资源； 4：更新完成，即应用缓存已经更新了资源，而且所有资源都已下载完毕，可以通过swapCache()来使用了； 5：废弃：即应用缓存的描述文件已经不存在，因此页面无法在访问应用缓存； 事件： checking：在浏览器为应用缓存查找更新时触发； error：在检查更新或下载资源期间发生错误时触发； noupdate：在检查妙手文件发现文件无变化时触发； downloading：在开始下载应用缓存资源时触发； progress：在文件下载应用缓存的过程中持续不断地触发； updateready：在页面新的应用缓存下载完毕并且可以通过swapCache()使用时触发； cached: 在应用缓存完整可用时触发 数据存储HTTP Cookie，通常直接叫做Cookie，最初是在客户端用于存储回话信息的。该标准要求服务器对任意HTTP请求发送Set-Cookie HTTP头座位响应的一部分，其中包含回话信息。 1234HTTP/1.1 200 OKContent-TYpe: text/htmlSet-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.comOther-header: other-header-value 限制 cookie在性质上是绑定在特定的域名下的。当设定一个cookie后，再给创建它的域名发送请求时，都会包含这个cookie。 cookie的构成 名称/值/域/路径/失效时间/安全标志 子cookie 绕开浏览器的单域名下的cookie数量限制，子cookie是存放在单个cookie中的更小段数据。也就是cookie值来存储多个键值对。 name=name1=value1 &amp; name2=value2 &amp; name3=value3 &amp; name4=value4 &amp; name5=value5 子cookie一般也以查询字符串的格式进行格式化。然后这些值可以使用单个cookie进行存储和访问，而非每个键值对使用不同的cookie存储。 IE用户数据在IE5.0中，微软通过一个自定义行为引入了持久化用户数据的概念。永辉数据允许每个文档最多128kb数据，每个域名最多1MB数据。 1234567var dataStor = document.getElementById(&quot;dataStore&quot;);dataStore.setAttribute(&quot;name&quot;, &quot;张三&quot;);dateStore.setAttribute(&quot;book&quot;, &quot;书名&quot;);dataStore.save(&quot;BookInfo&quot;);dataStore.load(&quot;BookInfo&quot;);dataStore.getAttribute(&quot;name&quot;); Web存储机制Web Storage 最早是在web超文本应用技术工作组(WHAT-WG)的Web应用1.0规范中描述的。这个规范最初的工作最终成为了HTML5的一部分。主要目标有两个： 提供一种在cookie之外存储回话数据的途径； 提供一种存储大量可以跨回话存在的数据的机制。 最初的Web Storage规范包含了两种对象的定义：sessionStorage和globalStorage。这两个对象在支持的浏览器中是以windows对象属性的形式存在的。 Storage类型 clear(): 删除所有值getItem(name): 根据指定的名字那么获取对象的值key(index): 获得index位置处的值得名字removeItem(name): 喊出有那么指定名值对setItem(name,value):为指定的名值对设置一个对应的值。 sessionStorage seeionStorage对象存储特定于某个回话的数据，也就是该数据只保持浏览器关闭。这个对象就像回话cookie，也会在浏览器关闭后消失。 globalStorage对象 具备同源策略限制。 1234// 保存数据globalStorage[&quot;wrox.com&quot;].name = &quot;张三&quot;;// 获取数据var name = globalStorage[&quot;wrox.com&quot;].name; localStorage对象 localStorage对象在修订过的HTML5规范中作为持久保存客户端数据的方案取代了globalStorage。与globalStorage不同，不能给localStorage指定任何访问规则，规则事先就设定好了。要访问一个localStorage对象，页面必须来自同一个域名(子域名无效)，使用同一种协议，在同一个端口上。 12345678// 使用方法存储数据localStorage.setItem(&quot;name&quot;,&quot;张安&quot;);// 使用属性存储数据localStorage.book = &quot;book&quot;;// 使用方法读取数据var name = localStorage.getItem(&quot;name&quot;);// 使用属性读取数据var book = localStorage.book; 存储在localStorage中的数据和存储globalStorage中的数据一样，都遵循相同的规则：数据保留到通过JavaScript删除或者用户清楚浏览器缓存。 Storage事件 domain: 发生变化的存储空间域名； key:设备或删除的域名; newValue：如果是设置值，则是更新，如果是删除，则是null。 oldValue: 键被更改之前的值 限制 大多数桌面浏览器设置每个来源5MB的限制。Chrome和Safari对每个来源的限制是2.5MB。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 跨域技术]]></title>
    <url>%2F2019%2F09%2F10%2FJavaScript-%E8%B7%A8%E5%9F%9F%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[在CORS出现之前，要实现跨域Ajax通信颇费一些周折。开发人员想出了一些办法，利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求。虽然CORS技术已经无处不在，但开发人员自己发明的这些技术仍然被广泛使用，毕竟这样不需要修改服务器端代码。 图像Ping&lt;img&gt;标签，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。可以动态的创建图像，使用他们的onload和onerror事件处理程序来确定是否接受到了响应。 动态创建图像经常用于图像Ping。图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的。 12345var img = new Image();img.onload = img.onerror = function()&#123; alert(&quot;Done!&quot;);&#125;;img.src = &quot;url&quot;; JSONPJSONP是JSON with padding（填充式JSON或参数JSON）的简写，是应用JSON的一种新方法，在后来的Web服务中非常流行。JSONP看起来与JSON差不多，只不过是被包含在函数调用中的JSON，就像下面这样。 callback({&quot;name&quot;:&quot;张飒&quot;}); JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。 http://freegeoip.net/json/?callback=handleResponse 这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调参数是很常见的。JSONP是通过动态&lt;script&gt;元素来使用的，使用时可以为src属性指定一个跨域RUL。这里的&lt;script&gt;元素与&lt;img&gt;元素类似，都有能力不受限制地从其他域加载资源。因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。 1234567function handleResponse(response)&#123; alert(&quot;You&apos;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);&#125;var script = document.createElement(&quot;script&quot;);script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore(script,document.body.firstChild); 优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过，JSONP也有两点不足。 首先，JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究。因此在使用不是你自己运维的Web服务时，一定得保证它安全可靠。 其次，要确定JSONP请求是否失败并不容易。虽然HTML5给&lt;script&gt;元素新增了一个onerror事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和宽带都一样。 CometComet是Alex Russell发明的一个词，指的是一种更高级的Ajax技术（经常也有人称为”服务器推送”）。Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。 轮询轮询（Polling）是一种CPU决策如何提供周边设备服务的方式，又称“程控输入输出”（Programmed I/O）。轮询法的概念是：由CPU定时发出询问，依序询问每一个周边设备是否需要其服务，有即给予服务，服务结束后再问下一个周边，接着不断周而复始。 有两种实现Comet方式： 长轮询和流。长轮询是传统轮询（也成为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据。12345678910111213&lt;?php $i = 0; while(true)&#123; // 输出一些数据，然后立即刷新输出缓存 echo &quot;number is $i&quot;; flush(); // 等几秒钟 sleep(10); $i++; &#125;php&gt; 随着不断从服务器接收数据，readyState的值会周期性的变为3.当readyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用XHR对象实现HTTP流的典型代码如下所示： 1234567891011121314151617181920212223242526272829function createStreamingClient(url, progress, finished)&#123; var xhr = new XMLHttpRequest(), received = 0; xhr.open(&quot;get&quot;,url,true); xhr.onreadystatechange = function()&#123; var result; if(xhr.readyState === 3)&#123; // 知趣的最新数据并调整计算器 result = xhr.responseText.substring(received) recelived += result.length; // 调用progress回调函数 progress(result); &#125; else if （xhr.readyState） &#123; finished(xhr, responseText) &#125; &#125;； xhr.send(null); return xhr;&#125;var client = createStreamingClient(&quot;streaming.php&quot;, function(data)&#123; alert(&quot;Received:&quot; + data); &#125;,function(data)&#123; alert(&quot;Done!&quot;);&#125;) 这个createStreamingClient()函数接收三个参数： 要连接的URL; 在接收到数据时调用的函数以及关闭连接时调用的函数。 有时候，当连接关闭时，很可能还需要重新建立，所以关注链接什么时候关闭还是有必须要的。 只要readystatechange事件发生，而且readyState值为3，就对responseText进行分割以取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。然后通过progress回调函数来处理传入的新数据。而当readyState值为4时，则执行finished回调函数，传入响应返回的全部内容。 服务器发送事件SSE（Server-Sent Events,服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须是text/event-stream，而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。有了这么简单实用的API，再实现Comet就容易多了。 HTTP流。它在页面整个生命周期内只使用一个HTTP连接，具体使用方法即页面向浏览器发送一个请求，而服务器保持tcp连接打开，然后不断向浏览器发送数据。 SSE API SSE的javaScript API与其他传递消息的JavaScript API很相似。要预订新的事件流，首先要创建一个新的EventSource对象，并传进一个入口点： var source = new EventSource(“myevents.php”); 注意，传入的URL必须与创建对象的页面同源（相同的URL模式、域及端口）。EventSource的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭了连接。 另外，还有一下三个事件。 open: 在建立连接时触发。 message: 在从服务器接收到新事件时触发。 error: 在无法简历连接时触发。 就一般的用法而言，onmessage事件处理程序也没有什么特别的。 1234source.onmessage = function(event)&#123; var data = event.data; // 处理数据&#125;; 服务器发回的数据以字符串形式保存在event.data中。 默认情况下，EventSource对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着SSE适合长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close()方法。 source.close(); 事件流 所谓服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为 text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀data:，例如： 12345data: foodata: bardata: foodata: bar 对以上响应而言，事件流中的第一个message事件返回的event.data值为”foo”，第二个message事件返回的event.data值为”bar”,第三个message事件返回的event.data值为”foo\nbar”（注意中间的换行符）。对于多个连续的以data:开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。只有包含data:的数据行后面有空行时，才会触发message事件，因此在服务器上生成事件流时不能忘了多添加这一行。 通过id:前缀可以给特定的事件指定一个关联的ID，这个ID行位于data:行前面或后面皆可： 12data: fooid: 1 设置了ID后，EventSource对象会跟踪上一次触发的事件。如果连接断开，回想服务器发送一个包含名为Last-Event-ID的特殊HTTP头部请求，以便服务器知道下一次该触发哪个事件。在多次连接得事件流中，这种机制可以确保浏览器以正确的顺序收到连接得数据段。 Web Sockets要说是令人津津乐道的新浏览器API，就得数Web Sockets了。Web Sockets的目标是在一个单独的持久连接上提供全双工、双向通信。在JavaScript中创建了Web Socket之后，会有一个HTTP请求发送到浏览器已发起连接。在取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为Web Socket协议。也就是说，使用标准的HTTP服务器无法实现Web Sockets,只有支持这种协议的专门服务器才能正常工作。 由于WebSockets使用了自定义的协议，所以URL模式也略有不同。未加密的连接不再是http://,而是ws://；加密的链接也是不是https://,而是wss://。在使用Web SocketURL时。必须带着这个模式，因为将来还有可能支持其他模式。 使用自定义协议而非HTTP协议的好处是，能够在客户端和服务端之间发送非常少量的数据，而不必担心HTTP那样字节集的开销。由于传递的数据包很小，因此WebSockets非常适合移动应用。毕竟对移动应用而言，带宽和网络延迟都是关键问题。使用自定义协议的缺点在于，制定协议的时间比制定JavaScriptAPI的时间还要常。Web Sockets曾几度搁浅，就因为不断有人发现这个新协议存在一致性和安全性问题。 Web Sockets API 要创建WebSocket,先实例一个WebSocket对象并传入要连接得URL； var socket = new WebSocket(&quot;URL&quot;); WebSocket.OPENING(0): 正在建立连接。WebSocket.OPEN(1): 已经建立连接。WebSocket.CLOSING(2): 正在关闭连接。WebSocket.CLOSE(3): 已经关闭连接。 关闭WebSocket连接，可以在任何时候调用close()方法： socket.close(); 发送和接收数据 1234567var message = &#123; time: new Date(), text: &quot;Hello world!&quot;, clientId: &quot;54564646&quot;&#125;;socket.send(JSON.stringify(message)); 接下来，服务器要读取其中的数据，就要解析接收道德JSON字符串。 1234socket.onmessage = function(event)&#123; var data = event.data; // 处理数据&#125; 与通过send()发送到服务器的数据一样，event.data中返回的数据也是字符串。如果你想得到其他格式的数据，必须手工解析这些数据。 其他事件 WebScoket对象有其他三个事件，在连接生命周期的不同阶段触发。 open: 在成功建立连接时触发。 error: 在发生错误时触发，连接不能持续。 close: 在连接关闭时触发。 WebScoket 对象不支持DOM2级时间侦听器，因此必须使用DOM0级语法分别定义每个事件处理程序。 1234567891011121314var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);socket.onopen = function () &#123; alert(&quot;Connection established.&quot;);&#125;;socket.onerror = function () &#123; alert(&quot;Connection error.&quot;);&#125;;socket.onclose = function (event) &#123; alert(&quot;Connection closed.&quot;); console.log(&quot;Was clean ? &quot; + event.wasClean + &quot;Code = &quot; + event.code + &quot; Reason= &quot; + event.reason);&#125;; SSE 与 Web Sockets面对某个具体的用力，在考虑是使用SSE还是使用WebSockets时，可以考虑如下几个因素。首先，你是否有自由度简历和维护WebSockets服务器？其次，到底需不需要双向通信。 安全 要求以SSL连接来访问可以通过XHR请求的资源。 要求每一次请求都要附带经过响应算法计算得到的验证码。 建议采用上面两种办法。 要求发送POST而不是GET请求 检查来源URL以确定是否可信 基于cookie信息进行验证]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Ajax]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-Ajax%2F</url>
    <content type="text"><![CDATA[XMLHttpRequest对象 XHR的用法 12345// 请求类型，请求地址，是否异步xhr.open(&quot;get&quot;,&quot;http://www.baidu/com&quot;, false)// 作为请求主体发送的数据xhr.send(null) XHR对象的属性： responseText: 作为相应主体被返回的文本。 responseXML: 如果相应的内容类型是”text/html”或”application/xml”，这个属性中将保存喊着响应数据的XML DOM文档。 status: 响应HTTP状态。 statusText：HTTP状态的说明。 readyState：该属性表示请求/响应过程的当前活动阶段。（0未初始化，1启动，2发送，3接收，4完成） 12345678910111213141516var xhr = createXHR();xhr.onreadystatechange = functuin () &#123; if (xhr.readState === 4) &#123; if( (xhr &gt;= 200 &amp;&amp; xhr.status &lt;300) || xhr.status === 304) &#123; alert(xhr.responseText); &#125; else &#123; alert(&quot;Request was unsuccessful: &quot; + xhr.status); &#125; &#125;&#125;xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);xhr.send(null);在接收响应之前还可以调用abort()方法来取消异步请求。 HTTP头部信息 默认情况下，在发送XHR请求的同时，还会发送下列头部的信息： Accept：浏览器能够处理的内容类型。 Accept-Charset：浏览器能够显示的字符集。 Accept-Encoding：浏览器能够处理的压缩编码。 Accept-Language：浏览器当前设置的语言。 Connection：浏览器与服务器之间连接的类型。 Cookie：当前页设置的任何Cookie。 Host：发出请求的页面所在的域。 Referer：发布请求的页面的URL。 User-Agent：浏览器的用户代理字符串。 使用setRequestHeader()方法可以设置自定义的请求头部。这个方法接受两个参数：头部字段的名称和头部字段的值。 12345678910111213var xhr = createXHR();xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125; &#125;&#125;xhr.open(&quot;get&quot;,&quot;url&quot;,true);xhr.setRequestHeader(&quot;MyHeader&quot;,&quot;Myvalue&quot;);xhr.send(null) 使用getErsponseHeader()方法并栓如头部字段名称，可以取得相应的响应头部信息。使用getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串。 12var myHeader = xhr.getResponseHeader(&quot;MyHeader&quot;);var allHeader = xhr.getAllResponseHeaders(); Get请求 GET是最常见的请求类型，最常用于服务器查询某些信息。必要时，可以将查询字符串参数追加到URL的末尾，一遍将信息发送给服务器。对于XHR而言，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码才行。 使用GET请求经常会发生一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行解码，然后才能放到URL的末尾。 xhr.open(&#39;get&#39;,&#39;a.html?name=value&amp;name1=value1&#39;,true) addURLParam()函数 123456789101112// 要添加参数的URL 参数名称 参数值function addURLParam(url, name, value)&#123; url += (url.indexOf(&quot;?&quot;) === -1 ? &quot;?&quot; : &quot;&amp;&quot;); url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value); return url;&#125;;// 调用url = addURLParam(url, &quot;book&quot;, &quot;张三&quot;);// 初始化请求xhr.open(&quot;get&quot;, url, false); POST请求 通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主题提交，而GET请求传统上不是这样。 12345678910111213141516function submitData()&#123; var xhr = createXHR(); xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125; &#125; &#125; xhr.open(&quot;post&quot;, &quot;example.php&quot;, true) xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;) var form = document.getElementById(&quot;user-info&quot;) xhr.send(serialize(form))&#125; XMLHttpRequest 2级 FormData 12345678910111213var xhr = createXHR();xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125; &#125;&#125;xhr.open(&quot;post&quot;,&quot;url&quot;,true);var form = document.getElementById(&quot;user-info&quot;)xhr.send(new FormData(form)) 超时设定 12345678910111213141516var xhr = createXHR();xhr.onreadystatechange = function () &#123; if(xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125; &#125;&#125;xhr.open(&quot;get&quot;,&quot;url&quot;,true);xhr.timeout = 1000;xhr.ontimeout = function () &#123; alert(&quot;Request did not return is a second.&quot;);&#125;xhr.send(null) overrideMimeType()方法 通过调用overrideMimeType()方法，可以保证把响应当做XML而非纯文本来处理 1234var xhr = createXHR();xhr.open(&quot;get&quot;,&quot;url&quot;,true);xhr.overrideMimeType(&quot;text/xml&quot;);xhr.send(null); 进度事件 loadstart：在接收到响应数据的第一个字节是触发。 progress：在接收响应期间持续不断地触发。 error：在请求发生错误时触发。 abort：在因为调用abort()方法而终止连接时触发。 load：在接收到完整响应数据时触发。 loadend：在通信完成或者触发error、abort或load事件后触发。 load事件，只要浏览器接收到服务器响应，不管其状态如何，都会触发load事件。 12345678910var xhr = createXHR();xhr.onload = function () &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125;&#125;xhr.open(&quot;get&quot;,&quot;altevents.php&quot;,true)xhr.send(null) progress事件 12345678910111213141516171819var xhr = createXHR();xhr.onload = function () &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123; alert(xhr.responsetext) &#125; else &#123; alert(&quot;Request was unsuccessful:&quot; + xhr.status) &#125;&#125;xhr.onprogress = function(event)&#123; var divStatus = document.getElementById(&quot;status&quot;); if(event.lengthComputable)&#123; divStatus.innerHTML = &quot;Received&quot; + event.position + &quot;of&quot; + event.totalSize + &quot;bytes&quot;; &#125;&#125;xhr.open(&quot;get&quot;,&quot;altevents.php&quot;,true)xhr.send(null) 跨源资源共享CORS(Cross-Origin Resource Sharing, 跨源资源共享)，是W3C的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应是应该成功，还是应该失败。 IE对CORS的实现 微软在IE8中引入了XDR(XDomainRequest)类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。以下是XDR与XHR的一些不同之处。 cookie不会随请求发送，也不会随响应返回。 智能设置请求头部信息中的Content-Type字段。 不能访问响应头部信息。 只支持GET和POST请求。 这些变化使CSRF(Cross-Site Request Forgery,跨站点请求伪造)和XSS(Cross-Site Scripting,跨站点脚本)的问题得到了缓解。 被请求的资源可以根据它认为合适的任意数据（用户代理，来源页面等）来决定是否设置Access-Control-Allow-Origin头部。作为请求的一部分，Origin头部的值表示请求的来源域，以便远程 资源明确地识别XDR请求。 12345678910111213141516171819var xdr = new XDomainRequest();xdr.onload = function()&#123; alert(xdr.responseText);&#125;;xdr.onerror = function()&#123; alert(&quot;An error occurred.&quot;)&#125;;xdr.timeout = 1000;xdr.ontimeout = function()&#123; alert(&quot;Request took too long.&quot;)&#125;// GET请求xdr.open(&quot;get&quot;,&quot;url&quot;);xdr.send(null);// POST请求xdr.open(&quot;post&quot;,&quot;url&quot;);xdr.contentType = &quot;application/x-www-form-urencoded&quot;;xdr.send(&quot;name=value&amp;name2=value2&quot;); 跨域XHR对象也有一些限制，但是为了安全这些限制是必需的。 不能使用setRequestHeader()设置自定义头部。 不能发送和接收cookie。 调用getAllResponseHeaders()方法总会返回空字符串。 Preflighted Reqeusts透明服务器验证机制支持开发人员使用自定义头部、GET或POST之外的方法，以及不同类型的主体内容。 Origin：与简单的请求相同。 Access-Control-Request-Method：请求自身使用的方法。 Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。 123Origin: urlAccess-Control-Request-Method: POSTAccess-Control-Request-Headers: NCZ 发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。 1234Access-Control-Allow-Origin: urlAccess-Control-Allow-Method: POST,GETAccess-Control-Allow-Headers: NCZAccess-Control-Max-Age: 1728000 Preflight请求结束后，结果将按照响应中指定的时间缓存起来。 带凭据的请求默认情况下，跨源请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。如果服务器接收带凭据的请求，会用下面的HTTP头部来响应。 Access-Control-Allow-Credentials: true 跨浏览器的CORS12345678910111213141516171819202122function createCORSRequest(method,url)&#123; var xhr = new XMLHttpRequest(); if(&quot;withCredentials&quot; in xhr)&#123; xhr.open(method,url,true); &#125; if(typeof XDomainRequest != &quot;undefined&quot;)&#123; vxhr = new XDomainRequest(); xhr.open(method, url); &#125; else &#123; xhr = null; &#125; return xhr;&#125;var request = createCORSRequest(&quot;get&quot;,url);if(request)&#123; request.onload = function () &#123; // 对request.responseText进行处理 &#125; request.send();&#125; XMLHttpRequest对象与XDomainRequest对象共同的属性/方法如下： abort(): 用于停止正在进行的请求。 onerror: 用于替代onreadystatechange检测错误。 onload: 用于替代onreadystatechange检测成功。 responseText: 用于取得响应内容。 send(): 用于发送请求。 以上成员都包含在createCORSRequest()函数返回的对象中。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript JSON]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-JSON%2F</url>
    <content type="text"><![CDATA[JSON语法JSON语言可以表示一下三种类型的值： 简单值，使用与JavaScript相同的语法，可以在JSON中表示字符串，数值，布尔值，和null，但JSON不支持JavaScript中的特殊值undefined; 对象：对象作为一种复杂数据类型，表示是一组有序的键值对。而每个键值对中的值可以是简单之，也可以是复杂数据类型的值； 数组：数组也是一种复杂数据类型，表示一组有序的值得列表。可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。 简单值最简单的JSON数据形式就是简单值 12345&quot;Hello world&quot;truenull JavaScript字符串与JSON字符串的最大区别在于，JSON字符串必须使用双引号(单引号会导致语法错误)。 对象JSON中的对象与JavaScript字面量稍微有一些不同。 1234var person = &#123; name: &quot;张飒&quot;, age: 18&#125; JSON表示上述对象方式 1234&#123; &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 18&#125; 数组JSON中的第二种复杂数据类型是数组。JSON数组采用的就是Javascript中数组字面量形式。 var value = [25, 10, &quot;张三&quot;] JSON中，可以采用同样语法表示同一个数组 12345678910[ &#123; &quot;title&quot;:&quot;张三&quot;, &quot;age&quot;: 18 &#125;, &#123; &quot;title&quot;:&quot;李四&quot;, &quot;age&quot;: 18 &#125;,] 解析与序列化1doc.getElementsByTagName(&quot;book&quot;)[2].getAttribute(&quot;title&quot;) JSON 对象123456789101112131415var book = &#123; title: &quot;张三&quot;, authors: [ &quot;李四&quot; ], edition: 3, year: 2019,&#125;;var jsonText = JSON.stringfy(book);// stringfy对象序列化为一个JSON字符串var bookCopy = JSON.parse(jsonText)// 如果传给JSON.parse()的字符串不是有效的JSON，该方法会抛出错误 序列化选项 过滤结果 12345678910var book = &#123; &quot;title&quot;: &quot;标题&quot;, &quot;authors&quot;: [ &quot;作者君&quot; ], edition: 1, year: 2019&#125;var jsonText = JSON.stringfy(book,[&quot;title&quot;,&quot;edition&quot;]); JSON.stringfy()的第二个参数是一个数组，其中包含两个字符串：”title” “edition”。这两个属性与将要序列化的对象中的属性是对应的，因此在返回的结果字符中，就只会包含着两个属性： {&quot;title&quot;: &quot;标题&quot;, &quot;edition&quot;: 1} 如果第二个参数是函数，行为会稍有不同。传入的函数接收两个参数，属性和属性值。根据属性可以知道应该如何处理要序列化的对象中的属性。 123456789101112var jsonText = JSON.stringify(book, function(key, value)&#123; switch(key)&#123; case &quot;authors&quot;: return value.join(&quot;,&quot;) case &quot;year&quot;: return 2000; case &quot;edition&quot;: return undefined; default: return value &#125;&#125;) 字符串缩进 JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的每个级别缩进的空格数。 var jsonText = JSON.stringify(book, null, 4); console.log(jsonText)返回结果： 123&#123; &quot;title&quot;: &quot;张三&quot;&#125; toJSON()方法 12345678var book = &#123; &quot;title&quot;: &quot;标题&quot; toJSON: function () &#123; return this.title; &#125;&#125;var jsonText = JSON.stringify(book); 解析选项JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。 123456789var bookCopy = JSON.parse(jsonText, function (key, value)&#123; if(key === &quot;releaseDate&quot;)&#123; return new Date(value); &#125; else &#123; return value; &#125;&#125;);alert(bookCopy.releaseDate.getFullYear()); ECMAScript 5定义了一个原生的JSON对象，可以用来将对象序列化为JSON字符串或者将JSON数据解析为JavaScript对象。JSON.stringify()和JSON.parse()方法分别用来实现上述两项功能。这两个方法都有一些选项，通过他们可以改变过滤的方式，或者改变序列化的过程。 JSON对象转化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;script&gt;//json字符串、json对象、数组 三者之间的转换let jsonStr = &apos;[ &#123;&quot;id&quot;:&quot;01&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;01&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;011&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;01&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;03&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;04&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;05&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, &#123;&quot;id&quot;:&quot;06&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;]&apos;;let jsonObj = $.parseJSON(jsonStr);//json字符串转化成json对象(jq方法)//let jsonObj = JSON.parse(jsonStr)//json字符串转化成json对象（原生方法）let jsonStr1 = JSON.stringify(jsonObj)//json对象转化成json字符串//console.log(jsonStr1+&quot;jsonStr1&quot;)//json对象转化成json数组对象let arr1=[];for(let i in jsonObj)&#123; //let o=&#123;&#125;; //o[i]=jsonObj[i]; arr1.push(jsonObj[i]); &#125;//console.log(arr1);//console.log(typeof(arr));let jsonStr11 = JSON.stringify(arr1)//json数组转化成json字符串//console.log(jsonStr11);let jsonArr = [];for(let i in jsonObj)&#123; jsonArr[i] = jsonObj[i];&#125;//console.log(jsonArr);//console.log(typeof(jsonArr));&lt;/script&gt;&lt;script&gt;//将对象转化为数组let obj=&#123;&apos;未完成&apos;:5,&apos;已完成&apos;:8,&apos;待确认&apos;:4,&apos;已取消&apos;:6&#125;;let arr = [];for (let i in obj) &#123; //arr.push(obj[i]); //属性 //arr.push(obj[i]); //值 let o=&#123;&#125;; o[i]=obj[i]; arr.push(o);&#125;function objToArray(array) &#123; let arr = []; for (let i in array) &#123; let o=&#123;&#125;; o[i]=array[i]; arr.push(o); &#125; console.log(arr); //return arr;&#125;// console.log(arr)objToArray(obj);&lt;/script&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 错误与调试]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[浏览器的报错try-catch语句12345try &#123; // 可能会导致出错的代码&#125; catch(error) &#123; // 在错误发生时怎么处理&#125; 错误类型 Error:基类，其它错误类型都继承自该类型。 EvalError：如果没将eval当成函数调用就会抛出此类型错误。 RangeError:超出范围就会抛出此错误类型。例如：在初始化数组时传入了不支持的项数，比如-20。 ReferenceError:访问不存在的变量时会抛出此类型的错误。 SyntaxError: 当语法错误时会抛出此类型的错误。例如：在js中运行 ’a 这样的错误语句。 TypeError:当发生类型错误时抛出此类型的错误。例如：运行不存在的方法，在undefined中取值 URIError:在使用encodeURI或decodeURI时url格式不正确会抛出此类错误。我尝试传入对象，数值都没抛出错误。例:%abcd。会报错 浏览器的调试 error(message)：将错误消息记录到控制台 info(message)：将信息性消息记录到控制台 log(message)：将一般消息记录到控制台 warn(message)：将警告消息记录到控制台]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript DOM]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-DOM%2F</url>
    <content type="text"><![CDATA[HTML DOM (文档对象模型) DOM0级处理事件就是将一个函数赋值给一个事件处理属性。 123456789101112131415161718// 改变 HTML 输出流 在 JavaScript 中，document.write() 可用于直接向 HTML 输出流写内容。// 改变 HTML 内容 document.getElementById(id).innerHTML=新的 HTML// 改变 HTML 属性 document.getElementById(id).attribute=新属性值// 改变 HTML 样式 document.getElementById(id).style.property=新样式// 使用时间 onclick=&quot;document.getElementById(&apos;id1&apos;).style.color=&apos;red&apos;&quot;// 1. 当用户点击鼠标时onclick// 2. 当网页已加载时onload 和 onunload 事件会在用户进入或离开页面时被触发。onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。onload 和 onunload 事件可用于处理 cookie。// 3. 当图像已加载时// 4. 当鼠标移动到元素上时onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。// 5. 当输入字段被改变时onchange 事件常结合对输入字段的验证来使用。// 6. 当提交 HTML 表单时// 7. 当用户触发按键时 DOM2级事件在DOM0级时间段额基础上弥补了一个处理处理程序，无法同时绑定多个处理函数的缺点。允许给一个程序添加多个处理函数。 1234567891011121314151617181920211. addEventListener() 方法addEventListener() 方法用于向指定元素添加事件句柄。addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。你可以向一个元素添加多个事件句柄。你可以向同个元素添加多个同类型的事件句柄，如：两个 &quot;click&quot; 事件。你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。当你使用 addEventListener() 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。你可以使用 removeEventListener() 方法来移除事件的监听。2. removeEventListener() 方法removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄 DOM3级事件是在DOM2级事件的基础上添加很多事件类型。 123456789UI事件，当用户与页面上的元素交互时触发，如：load、scroll焦点事件，当元素获得或失去焦点时触发，如：blur、focus鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel文本事件，当在文档中输入文本时触发，如：textInput键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified同时DOM3级事件也允许使用者自定义一些事件。 DOM0级 使用赋值方式绑定事件； 只能在冒泡阶段触发； 只能绑定一个事件函数； 通过置空onclick属性解绑事件； 事件函数this属性引用当前函数对象。 DOM2级 非IE方式 使用addEventListeren绑定事件； 事件名无on前缀； 使用addEventListeren第三个参数控制事件触发阶段； 可绑定多个事件函数； 多个事件函数的书法顺序和绑定顺序一样； 事件函数this属性引用当前函数对象； IE方式和非IE不同的是以下几点： 事件名带on前缀； 事件函数this属性引用全局对象； 多个事件函数的书法顺序和绑定顺序相反；]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript BOM]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-BOM%2F</url>
    <content type="text"><![CDATA[浏览器对象模型 (BOM)所有浏览器都支持 window 对象。它表示浏览器窗口。 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 Window 对象是BOM中所有对象的核心，除了是BOM中所有对象的父对象外，还包含一些窗口控制函数。 Window的子对象主要有如下几个： JavaScript document 对象 JavaScript frames 对象：可以在 JavaScript 中创建三种消息框：警告框、确认框、提示框。 JavaScript history 对象：window.history 对象包含浏览器的历史。 history.back() - 与在浏览器点击后退按钮相同 history.forward() - 与在浏览器中点击向前按钮向前相同 JavaScript location 对象：window.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。 location.hostname 返回 web 主机的域名 location.pathname 返回当前页面的路径和文件名 location.port 返回 web 主机的端口 （80 或 443） location.protocol 返回所使用的 web 协议（http:// 或 https://） JavaScript navigator 对象：window.navigator 对象包含有关访问者浏览器的信息。 123456789101112131415&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script&gt;txt = &quot;&lt;p&gt;Browser CodeName: &quot; + navigator.appCodeName + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;Browser Name: &quot; + navigator.appName + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;Browser Version: &quot; + navigator.appVersion + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;Cookies Enabled: &quot; + navigator.cookieEnabled + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;Platform: &quot; + navigator.platform + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;User-agent header: &quot; + navigator.userAgent + &quot;&lt;/p&gt;&quot;;txt+= &quot;&lt;p&gt;User-agent language: &quot; + navigator.systemLanguage + &quot;&lt;/p&gt;&quot;;document.getElementById(&quot;example&quot;).innerHTML=txt;&lt;/script&gt; JavaScript screen 对象：window.screen 对象包含有关用户屏幕的信息。 screen.availWidth - 可用的屏幕宽度 screen.availHeight - 可用的屏幕高度 Cookies1234567891011121314151617181920212223242526272829303132// 写入function setCookie(cname,cvalue,exdays)&#123; var d = new Date(); d.setTime(d.getTime()+(exdays*24*60*60*1000)); var expires = &quot;expires=&quot;+d.toGMTString(); document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires;&#125;// 读取function getCookie(cname)&#123; var name = cname + &quot;=&quot;; var ca = document.cookie.split(&apos;;&apos;); for(var i=0; i&lt;ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name)==0) return c.substring(name.length,c.length); &#125; return &quot;&quot;;&#125;// 检测function checkCookie()&#123; var user=getCookie(&quot;username&quot;); if (user!=&quot;&quot;)&#123; alert(&quot;Welcome again &quot; + user); &#125; else &#123; user = prompt(&quot;Please enter your name:&quot;,&quot;&quot;); if (user!=&quot;&quot; &amp;&amp; user!=null) &#123; setCookie(&quot;username&quot;,user,365); &#125; &#125;&#125; 客户端检测 能力检测：识别浏览器的能力 怪癖检测：识别浏览器的特殊行为 用户代理检测： 不能直接准确地使用能力监测或怪癖检测。 同一款浏览器在不同平台下具备不同的能力。 为了跟踪分析等目的需要知道确切的浏览器。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 函数表达式]]></title>
    <url>%2F2019%2F09%2F09%2FJavaScript-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数定义1234// 函数声明 关键字function 函数名 参数function functionName (arg0, arg1, arg2) &#123; // 函数体&#125;; 函数声明，特性：函数声明提升，就是说执行代码之前会先读取函数声明。举个例子 123456// 调用函数sayHi();// 定义函数function sayHi()&#123;&#125;; 12// 函数表达式var functuinName = function(arg0, arg1, arg2) &#123;&#125; 递归递归函数是在函数通过名字调用自身的情况下构成的。 1234567function factorial(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num - 1); &#125;&#125; 闭包JavaScript 变量可以是局部变量或全局变量。私有变量可以用到闭包。 123456function createFunction (name)&#123; return function(object1) &#123; var value1 = object1(name) alert(value1) &#125;&#125; this对象this对象是运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。 123456789101112var name = &quot;The Window&quot;;var object = &#123; name: &quot;My object&quot;, getNameFunc: function() &#123; var that = this; // 将getNameFunc()的this保存在that变量中 var age = 15; return function() &#123; return that.name; &#125;; &#125;&#125;alert(object.getNameFunc()()); // &quot;My object&quot; 内存泄漏 闭包中引用变量消除循环引用 把element变量设置为null，这样能够解除对DOM对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。 模仿块级作用域1234567(function()&#123; for (var i = 0; i &lt; count; i++) &#123; alert(i) &#125; var i; alert(i)&#125;)(); 私有变量特权方法，有权访问私有变量和私有函数的公有方法称为特权方法。 1234567891011121314function MyObject()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction () &#123; return false; &#125; // 特权方法 this.publicMethod = function () &#123; privateVariable++; return privateFunction(); &#125;&#125; 静态私有变量1234567891011121314(function()&#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction () &#123; return false; &#125; // 特权方法 this.publicMethod = function () &#123; privateVariable++; return privateFunction(); &#125;&#125;)() 模块模式123456789101112131415161718var singleton = function () &#123; // 私有变量和私有函数 var privateVariable = 10; function privateFunction()&#123;&#125; var object = new CustomType() // 添加特权方法/公有属性和方法 object.publicProperty = true; object.publicMethod = function () &#123; privateVariable++; return privateFunction(); &#125; return object&#125;();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 面向对象]]></title>
    <url>%2F2019%2F09%2F05%2FJavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象面向队形的语言有一个标志，那就是他们都有类的概念，而通过类可以创建多个具有相同属性和方法的对象。 1234567var person = new Object();person.name = &quot;闪电侠&quot;person.age = 18person.job = function () &#123; return this.name&#125; 属性类型分为访问器属性，数据属性 数据属性四个特性 12345678910111213var persoon = &#123; name: &apos;张三&apos;&#125;// 全局对象的属性// window.Object// 修改对象属性特性Object.defineProperty(persoon,&quot;name&quot;,&#123; // 具体特性 configurable: false, // 删除属性从而重新定义属性，能否修改属性的特性 enumerable: false, // 能否通过for-in循环返回属性 writable: true, // 能够修改属性值 value: &apos;李四&apos; // 属性数据值&#125;) 访问器属性四个特性 12345678910111213141516171819202122232425262728293031 // 定义对象var send = &#123; name: 1, // 访问器属性写法》？？ _符号 _getName: &apos;张飒&apos;, setName: &apos;李四&apos;&#125;;// 修改对象特性Object.defineProperty(send, &quot;getName&quot;,&#123; configurable: false, // 删除属性从而重新定义属性，能否修改属性的特性 enumerable: false, // 能否通过for-in循环返回属性 get: function () &#123; return this._getName // 之前this声明并没有拿到正确的函数返回值，现在试试 &#125;, //定义函数 set: function (number1) &#123; if(number1 &gt; 0)&#123; alert(this.setName) &#125; else &#123; return this.name &#125; &#125;&#125;)// 如何调用上面声明的对象特性 set写入 写入后应该是李四send.getName = 10// get读取console.log(send.getName)// 说明写入 和 读取是分开进行的 并且写入不修改原对象属性值 defineProperties() 定义多个属性特性1234567891011121314151617181920212223242526Object.defineProperties(person, &#123; // 这个时候就很明确了 name: &#123; value: &apos;张三&apos; &#125;, _job: &#123; value: 10 &#125;, job: &#123; get: function () &#123; return this._job &#125;, set: function (num) &#123; if (num &gt; 0) &#123; console.log(this.name) &#125; else &#123; return this._job &#125; &#125; &#125;&#125;);// 首先我们先看下这个对象其中一个属性的值console.log(person.name);person.job = 11;console.log(person.job); getOwnPropertyDescriptor() 读取属性特性12345678910111213141516171819202122232425262728293031var person = &#123;&#125;;Object.defineProperties(person, &#123; // 这个时候就很明确了 name: &#123; value: &apos;张三&apos; &#125;, _job: &#123; value: 10 &#125;, job: &#123; get: function () &#123; return this._job &#125;, set: function (num) &#123; if (num &gt; 0) &#123; console.log(this.name) &#125; else &#123; return this._job &#125; &#125; &#125;&#125;);// 从字面上看这个方法是获取特性// 这个方法的使用方式(对象,&quot;属性名&quot;)var getList = Object.getOwnPropertyDescriptor(person, &quot;job&quot;)// 我们来看看获取的是什么数据值console.log(getList) 工程模式与构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 工厂模型// 定义一个全局函数进行多次调用可以创建多个相同属性的对象，对象名不同，属性相同。function functionName(arg1, arg2, arg3) &#123; var list = new Object(); // 赋值 list.arg1 = arg1; list.arg2 = arg2; // 对象属性中包含函数时为什么没有直接执行？ 函数作用域 list.pushNum = function (arg3) &#123; if(arg3 === 1)&#123; return arg3; &#125; &#125; return list;&#125;var getList = functionName(&quot;张飒&quot;,&quot;李四&quot;, 1)console.log(getList)// 工厂模式解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)// 构造函数模型// 构造函数名始终以大写字母开头function Person(name,age,sex)&#123; this.name = name; this.age = age; this.sex = function()&#123; return sex; &#125;&#125;var person = new Person(&quot;张三&quot;,18,&quot;2&quot;);console.log(person)// 工厂模型和构造函数模型之间的不同// 没有显式的创建对象// 直接将属性和方法赋值给this对象// 没有return语句// 1. 将构造函数当作函数// 任何函数，只要通过New操作符来调用，那它就可以构造函数，而任何函数，如果不通过New调用，那就是普通函数// 2. 构造函数问题// 构造函数的缺点，每个方法都要在实例上重新创建一遍 原型模型我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以有特定类型的所有实例共享的属性和方法。 prototype就是通过调用构造函数而创建的那个对象实例的原型对象。 优点：原型对象可以让所有对象实例共享它包含的属性和方法。 12345678910function Person() &#123;&#125;Person.prototype.name = &apos;张飒&apos;Person.prototype.age = function () &#123; return this.name&#125;// isPrototypeOf() 确认属性是否跟原型对象存在关系// hasOwnProperty() 检测一个属性是否存在于实例中// for-in操作符 组合使用构造函数和原型模式123456789101112131415161718192021// 构造函数function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = [&quot;张飒&quot;, &quot;李四&quot;];&#125;// 原型模型Persoon.prototype = &#123; constructor : persoon, sayName : function()&#123; alert(this.name) &#125;&#125;var person1 = new Person(&quot;张三&quot;,10,&quot;soga&quot;);var person2 = new Person(&quot;李四&quot;,10,&quot;dou);// 数组的操作person1.friends.push(&quot;王五&quot;) 在这个代码中，实例属性都是在构造函数中定义的，而由所有实例共享的属性constructor和方法sayName()则是在原型中定义的。而修改person.friends，并不影响person2.friends，因为他们分别引用不同的数组。 这种构造函数与原型混成的模式，是目前ECMAScript中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 动态原型模式1234567891011121314funtion Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job if(typeof this.sayName != &quot;function&quot;) &#123; Person.prototype.sayName = function () &#123; alert(this.name); &#125; &#125;&#125;var friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);friend.sayName(); 寄生构造函数模式稳妥构造函数模式继承原型链ECMAScript中描述了原型链的概念，并将原型链座位实现继承的主要方法。其中思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。 1234567891011121314151617181920212223242526// 函数function SuperType()&#123; this.property = true;&#125;// 函数添加一个属性SuperType.prototype.getSuperValue = function () &#123; return this.property;&#125;// 函数function SubType()&#123; this.subproperty = false;&#125;// 继承了SuperTypeSubType.prototype = new SuperType(); // true// 添加Subtype.prototype.getSubValue = function ()&#123; return this.subproperty;&#125;var instance = new SubType();alert(instance.getSuperValue()); 原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而赋值得到的副本还可以得到进一步改造。 123456789101112131415function createAnother(original)&#123; var clone = object(original); clone.sayHi = function()&#123; alert(&apos;hi&apos;); &#125;; return clone;&#125;var person = &#123; name: &quot;张飒&quot;, friends: [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]&#125;;var anotherPerson = createAnother(person);anotherPerson.sayHi(); 寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。 12345678910111213141516171819function SuperType(name)&#123; this.name = name; this.colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;function SubType(name,age)&#123; SuperType.call(this.name); this.age = age;&#125;SubType.prototype = new SuperType();SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function () &#123; alert(this.age);&#125; 寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript语法]]></title>
    <url>%2F2019%2F09%2F02%2FJavaScript%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ECMAScriptECMA-262定义的ECMAScript与Web浏览器没有依赖关系。实际上，这门语言本身并不包含输入和输出定义。ECMA-262定义的只是这门语言的基础，而在此基础智商可以构建更完善的脚本语言。 ECMA-262规定了这门语言的组成部分： 语法 类型 语句 关键字 保留字 操作符 对象 ECMAScript 就是对实现该标准规定的各个方面内容的语言的描述。 文档对象模型(DOM)Document Object Model，是针对XML但经过扩展用于HTML的应用程序编程接口（API，Application Programming Interface）。 DOM级别 DOM1由两个模块组成：DOM核心（DOM Core）和 DOM HTML DOM2引入： DOM视图：定义了跟踪不同文档 DOM事件：定义了事件和事件处理的接口 DOM样式：定义了基于CSS为元素应用样式的接口 DOM遍历和范围：定义了遍历和操作文档树的接口 DOM3引入： 以统一方式加载和保存文档的方法：在DOM加载和保存模块中定义； 新增了验证文档的方法：在DOM验证模块中定义。 浏览器对象模型（BOM）支持可以访问和操作浏览器窗口的浏览器对象模型（BOM，Browser Object MOdel） JavaScriptJavaScript是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成： ECMAScript，由 ECMA-262定义，提供核心语言功能； 文档对象模型(DOM)，提供访问和操作网页内容的方法和接口； 浏览器对象模型(BOM),提供与浏览器交互的方法和接口。 &lt;script&gt;元素 &lt;script&gt;定义了6个属性： async：可选，表示应该立即下载脚本； charset：可选，表示通过src属性指定的代码的字符集； defer：可选，表示脚本可以延迟到文档完全被解析和显示之后再执行； language：可废弃； src：可选，表示包含要执行代码的外部文件； type：可选，可以看成是language的替代属性；表示编写代码使用的脚本语言的内容类型（也成为MIME类型）。 注：anync的脚本加载时并不能保证他们的先后执行顺序！ 外部文件优点： 可维护性； 可缓存； 适应未来。 语法 标识符 所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。 第一个字符必须是一个字母、下划线（_）或者一个美元符号（$）; 其他字符可以是字母、下划线、美元符号或数字。 ECMAScript标识符采用驼峰大小写格式。 严格模式 ECMAScript 5引入了严格模式的概念。严格模式是为JavaScript定义了一种不同的解析和执行模型。在严格模式下，ECMAScript3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。 use strict 关键字和保留字 关键字和保留字不能用作标识符。 数据类型5种基本数据类型：Null、Undefined、Boolean、Number、String1种复杂数据类型：Object 数值类型转换：Number()、parseInt()、parseFloat() 字符类型转换：toString()、String() 对象：Object() typeof 操作符检测给定变量的数据类型。 操作符 一元操作符 递增和递减操作符（++、–） 一元加和减操作符，正负（+、-） 位操作符 按位非~，执行按或非的结果就是返回数值的反码 按位与&amp;，按位与操作就是将两个数值的每一位对齐（具体参考真值表） 按位或|，同样也有两个操作数，按位或操作遵循（真值表） 按位异或^，也有两个操作数，按位异或操作遵循（真值表） 左移&lt;&lt;，这个操作符会将数值的所有位向左移动指定的位数 有符号的右移&gt;&gt;，这个操作符会将数值向右移动，但保留符号位（即正负号标记） 无符号右移&gt;&gt;&gt;，这个操作符会将数值的所有32位都向右移动 布尔操作符 逻辑非!，返回一个布尔值 逻辑与&amp;&amp;，返回一个布尔值 逻辑或||，返回一个布尔值 乘性操作符 乘法* 除法/ 求模(余数)% 加性操作符 加法+ 减法- 关系操作符 小于&lt; 大于&gt; 小于等于&lt;= 大于等于&gt;= 相等操作符 相等==和不相等!= 全等===和不全等!== 条件操作符 a &gt; b ? a : b 赋值操作符 = 算术操作符：（乘/赋值*=）、（除/赋值/=）、（模/赋值%=）、（加/赋值+=）、（减/赋值-=）、（左移/赋值&lt;&lt;=）、（右移/赋值&gt;&gt;=）、（无符号右移/赋值&gt;&gt;&gt;=） 逗号操作符 逗号操作多用于声明多个变量；但除此之外，逗号操作符还可以用于赋值。 语句 if语句 1234567if(条件)&#123; &#125;else if(条件)&#123;&#125;else&#123;&#125; do-while语句 123do&#123;&#125;while(条件) while语句 123while(条件)&#123;&#125; for语句 123for(var i;i&lt;length;i++)&#123;&#125; for-in语句 123for(属性 in 对象)&#123;&#125; label语句可以在代码中添加标签 加标签的语句一般都要与for语句等循环语句配合使用 break和continue语句 break立即退出循环，强制继续执行后面的语句 continue退出循环后从循环顶部继续执行 with语句 with语句的作用是将代码的作用域设置到一个特定的对象中。 switch语句 12345678910switch(表达式)&#123; case 值: 声明 break; case 值: 声明 break; default: 声明&#125; 函数123function (参数)&#123;&#125; 函数对于任何语言来说都是一个核心的概念，通过函数可以封装任意多条语句，而且可以在任何地方，任何时候调用执行。ECMAScript函数不能像传统意义上那样实现重载。 执行环境执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。 延长作用域链执行环境的类型总共只有两种-全局和局部(函数)，但还是有其他办法来延长作用域链。 try-catch语句的catch块 with语句 垃圾收集JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。 标记清除 引用计数 手工解除引用 变量 = null,解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。 引用类型 Object类型 Array类型 Date类型 RegExp类型：支持正则表达式 Function类型，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。 基本包装类型 Boolean类型 Number类型 String类型 单体内置对象 Global对象在某种意义上市座位一个终极的“兜底儿对象”来定义的。不属于任何其他对象的属性和方法，最终都是他的属性和方法。 Math对象提供了辅助完成这些计算的属性和方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP报文]]></title>
    <url>%2F2019%2F08%2F30%2FHTTP%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[HTTP 报文请求报文 HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。 规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。 123&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; HTTP 定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。 URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。 Get &amp; Post GET 用于信息获取，而且应该是安全的和幂等的。 安全的：意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 幂等的：意味着对同一 URL 的多个请求应该返回同样的结果。 GET 请求报文示例： 12345GET /books/?sex=man&amp;name=Professional HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive POST 表示可能修改变服务器上的资源的请求。 12345678POST / HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivesex=man&amp;name=Professional 注意: GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制； 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制； 参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里。 POST 提交数据的方式HTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端可以根据 Content-Type 和 Content-Encoding解析成功才有意义。 一般服务端语言都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据，包含了 Content-Type 和消息主体编码方式两部分： application/x-www-form-urlencoded 这是最常见的 POST 数据提交方式。浏览器的原生&lt;form&gt;表单，如果不设置 enctype属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。上个小节当中的例子便是使用了这种提交方式。可以看到 body 当中的内容和 GET 请求是完全相同的。 multipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 &lt;form&gt; 表单的 enctype 等于 multipart/form-data。 举个例子： 12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 &lt;form&gt;表单也只支持这两种方式（通过 &lt;form&gt;元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。 随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，例如 application/json，text/xml，乃至 application/x-protobuf 这种二进制格式。 响应报文HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 响应正文 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。 下面是一个HTTP响应的例子： 1234567HTTP/1.1 200 OKServer:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:23:42 GMTContent-Length:112&lt;html&gt;... 条件 GETHTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。 HTTP 条件 GET 使用的时机？客户端之前已经访问过某网站，并打算再次访问该网站。 HTTP 条件 GET 使用的方法？客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。 下面是一个具体的发送接受报文示例： 客户端发送请求： 1234GET / HTTP/1.1 Host: www.sina.com.cn:80 If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT Connection: Close 第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。 12345678HTTP/1.0 304 Not Modified Date: Thu, 04 Feb 2010 12:38:41 GMT Content-Type: text/html Expires: Thu, 04 Feb 2010 12:39:41 GMT Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT Age: 28 X-Cache: HIT from sy32-21.sina.com.cn Connection: close 如果服务器端资源已经更新的话，就返回正常的响应。 会话跟踪 什么是会话？ 客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。 什么是会话跟踪？ 会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。 为什么需要会话跟踪？ 浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。 会话跟踪常用的方法: URL 重写：URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。 隐藏表单域：将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示 Cookie：Cookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,客户端可以采用两种方式来保存这个 Cookie 对象，以便下次使用。一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。（Cookie 是可以被客户端禁用的。） Session：每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。 跨站攻击 CSRF（Cross-site request forgery，跨站请求伪造）CSRF(XSRF) 顾名思义，是伪造请求，冒充用户在站内的正常操作。 例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：http://example.com/bbs/create_post.php?title=标题&amp;content=内容那么，我们只需要在论坛中发一帖，包含一链接：http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。 如何防范 CSRF 攻击？可以注意以下几点： 关键操作只接受 POST 请求 验证码 CSRF 攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。 但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。 检测 Referer 常见的互联网页面与页面之间是存在联系的，比如你在www.baidu.com 应该是找不到通往www.google.com的链接的，再比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 Referer 中。通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。 Token 目前主流的做法是使用 Token 抵御 CSRF 攻击。下面通过分析 CSRF 攻击来理解为什么 Token 能够有效CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击。 另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的。这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击。 Token 使用原则： Token 要足够随机————只有这样才算不可预测 Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度 Token 要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中 注意：过滤用户输入的内容不能阻挡 csrf，我们需要做的是过滤请求的来源。 XSS（Cross Site Scripting，跨站脚本攻击）XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。 运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口： 123while (true) &#123; alert(&quot;你关不掉我~&quot;);&#125; 也可以是盗号或者其他未授权的操作。 XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。 如何防御 XSS 攻击？理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于 script。防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。 如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML escape 。下面一小段脚本： &lt;script&gt;window.location.href=”http://www.baidu.com”;&lt;/script&gt; 经过 escape 之后就成了： &amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.baidu.com&amp;quot;&amp;lt;/script&amp;gt; 它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。 当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。更好的方法可能是，将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。 参考资料： https://hit-alibaba.github.io/interview/basic/network/HTTP.html]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP/HTTPS协议]]></title>
    <url>%2F2019%2F08%2F30%2FHTTP-HTTPS%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP状态码 1xx（临时响应） 2xx（成功）：表示成功处理了请求的状态码。 3xx（重定向）：要完成请求，需要进一步操作。通常，这些状态码用来重定向。建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。 4xx（请求错误）：这些状态码表示请求可能出错，妨碍了服务器的处理。 5xx（服务器错误）：这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 状态码列表 状态码 描述 100（继续） 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 200（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对robots.txt文件显示此状态码，则表示已成功检索到该文件。 201（已创建） 请求成功并且服务器创建了新的资源。 202（已接受） 服务器已接受请求，但尚未处理。 203（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容） 服务器成功处理了请求，但没有返回任何内容。 205（重置内容） 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 206（部分内容） 服务器成功处理了部分 GET 请求。 300（多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 302（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 303（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304（未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 &lt;a href=answer.py?answer=&gt;301&lt;/a&gt; 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 400（错误请求） 服务器不理解请求的语法。 401（未授权） 请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止） 服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到） 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。 405（方法禁用） 禁用请求中指定的方法。 406（不接受） 无法使用请求的内容特性响应请求的网页。 407（需要代理授权） 此状态码与 &lt;a href=answer.py?answer=35128&gt;401（未授权）&lt;/a&gt;类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时） 服务器等候请求时发生超时。 409（冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除） 如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 411（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型） 请求的格式不受请求页面的支持。 416（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态码。 417（未满足期望值） 服务器未满足”期望”请求标头字段的要求。 500（服务器内部错误） 服务器遇到错误，无法完成请求。 501（尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 作用域访问对象 对象名称 描述 PageScope 与页面作用域page中的属性相关的Map类 requestScope 与请求作用域request中的属性相关的Map类 sessionScope 与会话作用域session中的属性相关的Map类 applicationScope 与应用程序作用域application中的属性相关的Map类 参数访问的对象 对象名称 描述 Param 按照参数名称访问单一请求的Map对象 paramValues 按照参数名称访问数组请求的Map对象 Jsp隐式对象 对象名称 描述 PageContext 提供页面信息的内置对象的访问]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议]]></title>
    <url>%2F2019%2F08%2F30%2FTCP-IP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。 TCP/IP协议的优点 TCP/IP协议不依赖于任何特定的计算机硬件或操作系统，提供开放的协议标准，即使不考虑Internet，TCP/IP协议也获得了广泛的支持。所以TCP/IP协议成为一种联合各种硬件和软件的实用系统。 TCP/IP协议并不依赖于特定的网络传输硬件，所以TCP/IP协议能够集成各种各样的网络。用户能够使用以太网（Ethernet）、令牌环网（Token Ring Network）、拨号线路（Dial-up line）、X.25网以及所有的网络传输硬件。 统一的网络地址分配方案，使得整个TCP/IP设备在网中都具有惟一的地址 标准化的高层协议，可以提供多种可靠的用户服务。 TCP/IP协议的缺点 在服务、接口与协议的区别上就不是很清楚。一个好的软件工程应该将功能与实现方法区分开来，TCP/IP恰恰没有很好地做到这点，就使得TCP/IP参考模型对于使用新的技术的指导意义是不够的。TCP/IP参考模型不适合于其他非TCP/IP协议簇。 主机-网络层（网络接口层）本身并不是实际的一层，它定义了网络层与数据链路层的接口。物理层与数据链路层的划分是必要和合理的，一个好的参考模型应该将它们区分开，而TCP/IP参考模型却没有做到这点。 TCP传输的三次握手为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。 用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。 握手过程中使用了TCP的标志：SYN和ACK。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 PS：若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 断开TCP连接的四次挥手 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 为什么连接的时候是三次握手，关闭的时候却是四次挥手？因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP]]></title>
    <url>%2F2019%2F08%2F30%2FTCP-IP%2F</url>
    <content type="text"><![CDATA[应用层（Application Layer）应用层(Application Layer)包含所有的高层协议。 应用层是所有用户所面向的应用程序的统称。ICP/IP协议族在这一层面有着很多协议来支持不同的应用，如我们进行万维网（WWW）访问用到了HTTP协议、DNS用于把主机名映射到网络地址、文件传输用FTP协议、电子邮件发送用SMTP、域名的解析用DNS协议、 远程登录用Telnet协议等等，都是属于TCP/IP应用层的. NNTP用于新闻的发布、检索和获取； 包括：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。 简单说来：应用层是应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。 TCP/IP 是用于因特网 (Internet) 的通信协议。通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。 TCP/IP 是供已连接因特网的计算机进行通信的通信协议。 TCP/IP 指传输控制协议/网际协议 (Transmission Control Protocol / Internet Protocol)。 TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。 TCP/IP 中包含一系列用于处理数据通信的协议： TCP (传输控制协议) - 应用程序之间通信 UDP (用户数据包协议) - 应用程序之间的简单通信 IP (网际协议) - 计算机之间的通信 ICMP (因特网消息控制协议) - 针对错误和状态 DHCP (动态主机配置协议) - 针对动态寻址 TCP 用于应用程序之间的通信。当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。 这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。 UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。 IP 用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。 通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。 IP 负责将每个包路由至它的目的地。 TCP/IPTCP/IP 意味着 TCP 和 IP 在一起协同工作。 TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。 IP 负责计算机之间的通信。 TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。 IP 负责将包发送至接受者。 HTTP - 超文本传输协议HTTP 负责 web 服务器与 web 浏览器之间的通信。 HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。 HTTPS - 安全的 HTTPHTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。 作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。 SSL - 安全套接字层SSL 协议用于为安全数据传输加密数据。 SMTP - 简易邮件传输协议SMTP 用于电子邮件的传输。 SMTP 协议用于传输电子邮件。SMTP 负责把邮件发送到另一台计算机。 通常情况下，邮件会被送到一台邮件服务器（SMTP 服务器），然后被送到另一台（或几台）服务器，然后最终被送到它的目的地。 SMTP 也可以传送纯文本，但是无法传输诸如图片、声音或者电影之类的二进制数据。 SMTP 使用 MIME 协议通过 TCP/IP 网络来发送二进制数据。MIME 协议会将二进制数据转换为纯文本。 MIME - 多用途因特网邮件扩展MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。 IMAP - 因特网消息访问协议IMAP 用于存储和取回电子邮件。 与 POP 类似，IMAP 协议同样被邮件程序使用。 IMAP 协议与 POP 协议之间的主要差异是：如果 IMAP 连上了邮件服务器，它不会自动地将邮件下载到邮件程序之中。 IMAP 使你有能力在下载邮件之前先通过邮件服务器端查看他们。通过 IMAP，你可以选择下载这些邮件或者仅仅是删除它们。比方说你需要从不同的位置访问邮件服务器，但是仅仅希望回到办公室的时候再下载邮件，IMAP 在这种情况下会很有用。 POP - 邮局协议POP 用于从电子邮件服务器向个人电脑下载电子邮件。 POP 协议被邮件程序用来取回邮件服务器上面的邮件。 假如你的邮件程序使用 POP，那么一旦它连接上邮件服务器，你的所有的邮件都会被下载到邮件程序中（或者称之为邮件客户端）。 FTP - 文件传输协议FTP 负责计算机之间的文件传输。 NTP - 网络时间协议NTP 用于在计算机之间同步时间（钟）。 DHCP - 动态主机配置协议DHCP 用于向网络中的计算机分配动态 IP 地址。 SNMP - 简单网络管理协议SNMP 用于计算机网络的管理。 LDAP - 轻量级的目录访问协议LDAP 用于从因特网搜集关于用户和电子邮件地址的信息。 ICMP - 因特网消息控制协议ICMP 负责网络中的错误处理。 ARP - Address Resolution ProtocolARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。 RARP - Reverse Address Resolution ProtocolRARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。 BOOTP - Boot ProtocolBOOTP 用于从网络启动计算机。 PPTP - 点对点隧道协议PPTP 用于私人网络之间的连接（隧道）。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS @media媒体查询]]></title>
    <url>%2F2019%2F08%2F30%2FCSS-media%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[语法1234//语法：@media mediatype and | not | only (media feature) &#123; css-code; &#125;//也可以针对不同的媒体使用不同的stylesheets: &lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet.css&quot;&gt; 标签&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 标签中引入（CSS2 media）123&lt;link rel=&quot;stylesheet&quot; href=&quot;styleA.css&quot; media=&quot;screen&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styleB.css&quot; media=&quot;screen and (max-width: 800px)&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styleC.css&quot; media=&quot;screen and (max-width: 600px)&quot;&gt; 但是上面这个方法，最大的弊端是他会增加页面http的请求次数，增加了页面负担，我们用CSS3把样式都写在一个文件里面才是最佳的方法。 CSS3 @media1234567891011121314// 等于960px尺寸的代码，以下代码需要写在style标签或者css文件中：@media screen and (max-device-width:960px)&#123; body&#123;background:red;&#125;&#125;// 当浏览器尺寸大于960px时候的代码了：@media screen and (min-width:960px)&#123; body&#123;background:orange;&#125;&#125;// 混合使用上面的用法：@media screen and (min-width:960px) and (max-width:1200px)&#123; body&#123;background:yellow;&#125;&#125; Media所有参数汇总以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释： width:浏览器可视宽度。 height:浏览器可视高度。 device-width:设备屏幕的宽度。 device-height:设备屏幕的高度。 orientation:检测设备目前处于横向还是纵向状态。 aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio:检测设备的宽度和高度的比例。 color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色） color-index:检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid:检测输出的设备是网格的还是位图设备。 媒体类型 all 所有媒体 braille 盲文触觉设备 embossed 盲文打印机 print 手持设备 projection 打印预览 screen 彩屏设备 speech ‘听觉’类似的媒体类型 tty 不适用像素的设备 tv 电视 关键字 and not not关键字是用来排除某种制定的媒体类型 only only用来定某种特定的媒体类型 -很多时候是用来对那些不支持媒体特性但却支持媒体类型的设备 常用的几种屏幕宽度设定：123456789101112131415@media screen and (min-width: 1200px) &#123; css-code;&#125;@media screen and(min-width: 960px) and (max-width: 1199px) &#123; css-code;&#125;@media screen and(min-width: 768px) and (max-width: 959px) &#123; css-code;&#125;@media screen and(min-width: 480px) and (max-width: 767px) &#123; css-code;&#125;@media screen and (max-width: 479px) &#123; css-code;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 渐变]]></title>
    <url>%2F2019%2F08%2F30%2FCSS3-%E6%B8%90%E5%8F%98%2F</url>
    <content type="text"><![CDATA[CSS3 线性渐变CSS3 Gradient 分为 linear-gradient（线性渐变）和 radial-gradient（径向渐变）。 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向 径向渐变（Radial Gradients）- 由它们的中心定义 语法 background: linear-gradient(direction, color-stop1, color-stop2, ...); 线性渐变 - 从上到下（默认情况下） 123456#grad &#123; background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, blue); /* 标准的语法 */&#125; 线性渐变 - 从左到右 123456#grad &#123; background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to right, red , blue); /* 标准的语法 */&#125; 线性渐变 - 对角 123456#grad &#123; background: -webkit-linear-gradient(left top, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(bottom right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to bottom right, red , blue); /* 标准的语法 */&#125; 使用角度 background: linear-gradient(angle, color-stop1, color-stop2); 123456#grad &#123; background: -webkit-linear-gradient(180deg, red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(180deg, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(180deg, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(180deg, red, blue); /* 标准的语法 */&#125; 使用多个颜色结点 123456#grad &#123; background: -webkit-linear-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, green, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, green, blue); /* 标准的语法 */&#125; 使用透明度（transparent） 123456#grad &#123; background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); /* Safari 5.1 - 6 */ background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Opera 11.1 - 12*/ background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Firefox 3.6 - 15*/ background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法 */&#125; 重复的线性渐变 repeating-linear-gradient() 函数用于重复线性渐变： 12345678910#grad &#123; /* Safari 5.1 - 6.0 */ background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%); /* Opera 11.1 - 12.0 */ background: -o-repeating-linear-gradient(red, yellow 10%, green 20%); /* Firefox 3.6 - 15 */ background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%); /* 标准的语法 */ background: repeating-linear-gradient(red, yellow 10%, green 20%);&#125; CSS3 径向渐变为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。 background: radial-gradient(center, shape size, start-color, ..., last-color); 径向渐变 - 颜色结点均匀分布（默认情况下） 123456#grad &#123; background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: radial-gradient(red, green, blue); /* 标准的语法 */&#125; 径向渐变 - 颜色结点不均匀分布 123456#grad &#123; background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */ background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */&#125; 设置形状 shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。 不同尺寸大小关键字的使用 size 参数定义了渐变的大小。它可以是以下四个值： closest-side farthest-side closest-corner farthest-corner 重复的径向渐变 repeating-radial-gradient() 函数用于重复径向渐变]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 动画原理]]></title>
    <url>%2F2019%2F08%2F29%2FCSS3-%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[2D/3D 旋转动画的概念：https://zhuanlan.zhihu.com/p/19855108 1234567891011121314151617181920212223242526272829div &#123; /* background-image: -webkit-linear-gradient(92deg,#f35626,#feab3a); */ width: 10px; height: 100px; margin: 0 auto; text-align: center; color: rgba(0, 0, 0, 0); background-color: #f35626; background-clip: text; /* -webkit-text-fill-color:transparent; */&#125;div:hover &#123; height: 300px; width: 600px; text-align: center; background-color: wheat; color: rgb(66, 66, 66); /* transition: 2s height ease, 2s background-color linear, 2s 2s width ease-in, 4s 4s color; */ /** 只对block级元素生效 */ /** 动画持续时长 */ transition-duration: 2s,2s,2s,4s; /** 动画渐变的属性 */ transition-property: height, background-color, width, color; /** 延迟播放动画 */ transition-delay: 0s,0s,2s,4s; /** 动画过渡函数 */ transition-timing-function: ease,linear,ease-in,normal;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html &#123; font-size: 14px; &#125; .flex &#123; position: fixed; width: 100%; height: 100%; display: flex; flex-direction: row; flex-wrap: wrap; align-items: center; align-content: center; justify-content: center; overflow: hidden; &#125; .box &#123; width: 100px; height: 100px; border: 1px solid black; background-color: #fff; /* 2D属性 translate移动(x,y) scale缩放(x,y) rotate角度(deg) skew倾斜转换(deg,deg)*/ transform: translate(20px,20px) scale(1.1,1.2) rotate(20deg) skew(20deg,40deg); -webkit-transform: translate(20px,20px) scale(1.1,1.2) rotate(20deg) skew(20deg,40deg); /* 设置旋转元素的基点位置 */ transform-origin: 10% 20%; -webkit-transform-origin: 10% 20%; /* 效果开始时间 */ transition-delay: 1s; /* 效果持续时间 */ transition-duration: 3s; /* 持续时间效果 */ transition-timing-function: cubic-bezier(0.075, 0.82, 0.165, 1); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 弹性盒子 --&gt; &lt;div class=&quot;flex&quot;&gt; &lt;!-- 绝对居中 --&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3D效果直接在属性后面添加3d，属性值相对性变成(x,y,z)三维坐标 3D加速 适用情况 通过-webkit-transform:transition3d/translateZ开启GPU硬件加速的适用范围： 使用很多大尺寸图片(尤其是PNG24图)进行动画的页面。 页面有很多大尺寸图片并且进行了css缩放处理，页面可以滚动时。 使用background-size:cover设置大尺寸背景图，并且页面可以滚动时。 编写大量DOM元素进行CSS3动画时(transition/transform/keyframes/absTop&amp;Left) 使用很多PNG图片拼接成CSS Sprite时 CSS3动画与关键帧 Animation &amp; @keyframes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html &#123; font-size: 14px; &#125; .flex &#123; position: fixed; width: 100%; height: 100%; display: flex; flex-direction: row; flex-wrap: wrap; align-items: center; align-content: center; justify-content: center; overflow: hidden; &#125; .box &#123; position: relative; width: 100px; height: 100px; border: 1px solid transparent; background-color: #000; /* 开启3D加速 */ transform: translate3d(0, 0, 0); /* 动画名称 */ animation-name: do; /* 动画持续时间 */ animation-duration: 5s; /* 动画开始时间 */ /* animation-delay: 1s; */ /* 动画播放次数 */ animation-iteration-count: infinite; /* 动画播放速率 */ animation-timing-function:cubic-bezier(0.755, 0.05, 0.855, 0.06); /* 动画是否保留属性值 */ animation-fill-mode: forwards; &#125; /* 关键帧 */ @keyframes do &#123; 10% &#123; border-radius: 10%; &#125; 20% &#123; border-radius: 20%; transform: rotate(30deg); &#125; 30% &#123; border-radius: 30%; transform: rotate(90deg); &#125; 40% &#123; border-radius: 40%; transform: rotate(180deg); &#125; 50% &#123; border-radius: 50%; &#125; 60% &#123; border-radius: 40%; transform: rotate(180deg); &#125; 70% &#123; border-radius: 30%; transform: rotate(90deg); &#125; 80% &#123; border-radius: 20%; transform: rotate(30deg); &#125; 90% &#123; border-radius: 10%; &#125; 100% &#123; border-radius: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 弹性盒子 --&gt; &lt;div class=&quot;flex&quot;&gt; &lt;!-- 绝对居中 --&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;turn&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116* &#123; padding: 0; margin: 0;&#125;body&#123; background: rgb(17, 75, 122); color: #fff;&#125;.box&#123; text-align: center;&#125;.title&#123; position: relative; top: -45px; animation-name: title; animation-delay: 1s; animation-duration: 3s; animation-timing-function: ease-in-out; animation-fill-mode: forwards;&#125;@keyframes title&#123; 0%&#123; top: -45px; &#125; 100%&#123; top: 200px; &#125;&#125;.content&#123; max-width: 960px; margin: auto; padding: 30px; position: relative; top: 200px; left: -100%; text-align: left; font-size: 14px; line-height: 2; text-indent: 24px; animation-name: content; animation-delay: 2s; animation-duration: 3s; animation-timing-function: linear; animation-fill-mode: forwards;&#125;@keyframes content&#123; 0% &#123; left: -100%; &#125; 100% &#123; left: 0; &#125;&#125;.btn&#123; position: relative; top: 220px; display: inline-block; font-size: 14px; text-indent: 0; line-height: 2; padding: 0.5rem 1rem; border: 1px solid #fff; text-decoration: none; color: #fff; opacity: 0; animation-name: btn; animation-delay: 5s; animation-duration: 2s; animation-timing-function: linear; animation-fill-mode: forwards; transition-property: transform; transition-duration: 2s; transition-timing-function: linear;&#125;.btn:hover&#123; transform: rotateY(180deg);&#125;@keyframes btn&#123; 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;&#125;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/transitions.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;h1 id=&quot;title&quot; class=&quot;title&quot;&gt;Welcome to page&lt;/h1&gt; &lt;div id=&quot;content&quot; class=&quot;content&quot;&gt; 《哈姆雷特》（英语：Hamlet）又名《王子复仇记》，是莎士比亚于1599年至1602年间的一部悲剧作品，是他最负盛名和被人引用最多的剧本。习惯上将本剧与《麦克白》、《李尔王》和《奥赛罗》一起，并称为莎士比亚的“四大悲剧”。 戏剧中叔叔克劳迪谋害了哈姆雷特国王，篡了王位，并娶了国王的遗孀葛簇特；王子哈姆雷特因此为父王之死向叔叔复仇。剧本细致入微地刻画了伪装的、真实的疯癫 —— 从悲痛欲绝到假装愤怒 —— 探索了背叛、复仇、乱伦、堕落等主题。 &lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;btn&quot;&gt;Read More&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 盒模型]]></title>
    <url>%2F2019%2F08%2F29%2FCSS3-%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[CSS盒模型所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。 CSS盒模型本质上是一个盒子，它包括：边距，边框，填充，和实际内容。 盒子模型(Box Model)： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;!-- Margin(外边距) - 清除边框外的区域，外边距是透明的。（margin的长度是允许出现负值的）注意：当以百分比来设置长度时，不管是宽度还是高度，都是按照父元素的宽度百分比计算的（即便是计算上下外边距也是按照父元素的宽度百分比计算的） --&gt; &lt;div class=&quot;margin&quot;&gt; &lt;!-- Border(边框) - 围绕在内边距和内容外的边框。 --&gt; &lt;div class=&quot;border&quot;&gt; &lt;!-- Padding(内边距) - 清除内容周围的区域，内边距是透明的。（padding的长度是不允许出现负值的）和margin一样，当以百分比来设置长度时，不管是宽度还是高度，都是按照父元素的宽度百分比计算的。 --&gt; &lt;div class=&quot;padding&quot;&gt; &lt;!-- Content(内容) - 盒子的内容，显示文本和图像。 --&gt; &lt;div class=&quot;content&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局圣杯布局和双飞翼布局达到的效果基本相同，都是侧边两栏宽度固定，中间栏宽度自适应。 主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样，圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现，而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。 双飞翼布局要求 header和footer各自占领屏幕所有宽度，高度固定。 中间的container是一个三栏布局。 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。 布局实现 left、center、right三种都设置左浮动 设置center宽度为100% 设置负边距，left设置负边距为100%，right设置负边距为自身宽度 设置content的margin值为左右两个侧栏留出空间，margin值大小为left和right宽度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;style&gt; body &#123; min-width: 550px; font-weight: bold; font-size: 20px; &#125; #header, #footer &#123; background: rgba(29, 27, 27, 0.726); text-align: center; height: 60px; line-height: 60px; &#125; #container &#123; overflow: hidden; &#125; .column &#123; text-align: center; height: 300px; line-height: 300px; &#125; #left, #right, #center &#123; float: left; &#125; #center &#123; width: 100%; background: rgb(206, 201, 201); &#125; #left &#123; width: 200px; margin-left: -100%; background: rgba(95, 179, 235, 0.972); &#125; #right &#123; width: 150px; margin-left: -150px; background: rgb(231, 105, 2); &#125; .content &#123; margin: 0 150px 0 200px; &#125;&lt;/style&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt;#header&lt;/div&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt; &lt;div class=&quot;content&quot;&gt;#center&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt;&lt;/body&gt; CSS3 弹性盒子模型(Flex Box Model)弹性盒子是 CSS3 的一种新的布局模式。 CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。 引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。 属性 描述 flex-direction 指定弹性容器中子元素排列方式 flex-wrap 设置弹性盒子的子元素超出父容器时是否换行 flex-flow flex-direction 和 flex-wrap 的简写 align-items 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式 align-content 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 justify-content 设置弹性盒子元素在主轴（横轴）方向上的对齐方式 flex-direction 属性： 决定项目的方向。注意：如果元素不是弹性盒对象的元素，则 flex-direction 属性不起作用。 row 默认值。元素将水平显示，正如一个行一样。 row-reverse 与 row 相同，但是以相反的顺序。 column 元素将垂直显示，正如一个列一样。 column-reverse 与 column 相同，但是以相反的顺序。 flex-wrap 属性： flex-wrap 属性规定flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。 nowrap 默认值。规定元素不拆行或不拆列。 wrap 规定元素在必要的时候拆行或拆列。 wrap-reverse 规定元素在必要的时候拆行或拆列，但是以相反的顺序。 flex-flow 属性： flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; display: flex; height: 100px; background-color: black; flex-direction: row; flex-wrap: wrap; align-items: center; justify-content: space-between; &#125; .item &#123; background-color: blanchedalmond; color: blueviolet; font-size: 14px; width: 40px; height: 40px; text-align: center; line-height: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot; style=&quot;order: 10&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex-grow: 0.3&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex-shrink: 8&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex-basis: 20px&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex:0.3 1 10px&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;align-self:flex-start&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;7&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; align-items属性： align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。 stretch 默认值。项目被拉伸以适应容器。 center 项目位于容器的中心。 flex-start 项目位于容器的开头。 flex-end 项目位于容器的结尾。 baseline 项目位于容器的基线上。 justify-content属性 justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。 flex-start 默认值。项目位于容器的开头。 flex-end 项目位于容器的结尾。 center 项目位于容器的中心。 space-between 项目位于各行之间留有空白的容器内。 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 弹性子元素属性 order 设置弹性盒子的子元素排列顺序。 flex-grow 设置或检索弹性盒子元素的扩展比率。 flex-shrink 指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。 flex-basis 用于设置或检索弹性盒伸缩基准值。 flex 设置弹性盒子的子元素如何分配空间。 align-self 在弹性子元素上使用。覆盖容器的 align-items 属性。 FCFC的全称是：Formatting Contexts，是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 BFC(Block Formatting Contexts)意为“块级格式化上下文”。就是页面上的一个渲染区域，容器内的子元素不会对外面的元素布局产生影响，反之亦然。 BFC的布局规则: 内部的盒子会在垂直方向，一个个地放置 盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此 BFC的区域不会与float重叠 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此 计算BFC的高度时，浮动元素也参与计算 如何生成BFC： 根元素或其它包含它的元素 float的值不为none overflow的值不为visible position的值不为relative和static display的值为table-cell,table-caption和inline-block中的任何一个 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 块格式化上下文对于定位与清除浮动很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 IFC(Inline Formatting Contexts)意为“内联格式化上下文”,IFC中，盒子依次水平放置，从包含块的顶部开始 FFC(Flex Formatting Contexts)意为“自适应格式化上下文”,display值为flex或者inline-flex的元素将会生成自适应容器。flex box由伸缩容器和伸缩子元素组成。通过设置元素display:flex/inline-flex可以得到伸缩容器，前者为块级元素，后者为行内元素。伸缩容器外元素不受影响。 GFC(GridLayout Formatting Contexts)意为“网格布局格式化上下文”当一个元素设置为display:grid的时候，此元素将获得一个独立的渲染区域，可以在网格容器上定义网格行和列，为每一个网格定义位置和空间。GFC和table的区别在于GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础]]></title>
    <url>%2F2019%2F08%2F28%2FCSS-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[CSS基础知识CSS 指层叠样式表 (Cascading Style Sheets)，是一种用来表现 HTML 文档样式的语言，样式定义如何显示 HTML 元素，是能够真正做到网页表现与结构分离的一种样式设计语言。 外部样式表可以极大提高工作效率 外部样式表通常存储在CSS文件中 多个样式定义可层叠为一 层叠次序 浏览器缺省设置 外部样式表 内部样式表(位于&lt;head&gt;标签内部) 内联样式表(在HTML元素内部) 选择器优先级 内联样式的权重为1000 ID选择器的权重为100 类选择器的权重为10 元素选择器的权重为1 权重计算永不进位 CSS语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器的分组，用都好将需要分组的选择器分开 集成及其问题，子元素从父元素继承属性有些浏览器不支持其继承，可以用组选择器 !important定义和用法提升指定样式规则的应用优先权。 div{color:#f00!important;color:#000;} comment定义和用法/* 这里是注释内容 */ @import定义和用法指定导入的外部样式表及目标媒体。 &lt;url&gt;：使用绝对或相对地址指定导入的外部样式表文件。可以是url(url)或者直接是一个url &lt;media_query_list&gt;：指定媒体类型和查询条件。 123@import url(example.css) screen and (min-width:800px);@import url(example.css) screen and (width:800px),(color);@import url(example.css) screen and (min-device-width:500px) and (max-device-width:1024px); @charset定义和用法在外部样式表文件内使用。指定该样式表使用的字符编码。 &lt;charset&gt;：字符编码。如：@charset “utf-8”; @media定义和用法指定样式表规则用于指定的媒体类型和查询条件 媒体类型 描述 all 所有浏览器-用于所有媒体设备类型 aural Opera-用于语音和音乐合成器 braille Opera-用于触觉反馈设备 handheld Chrome,Safari,Opera-用于小型或手持设备 print 所有浏览器-用于打印机 projection Opera-用于投影图像，如幻灯片 screen 所有浏览器-用于计算机显示器 tty Opera-用于使用固定间距字符格的设备。如电传打字机和终端 tv Opera-用于电视类设备 embossed Opera-用于凸点字符（盲文）印刷设备 123456789@media all and (width:1024px)&#123; body&#123;color:#f00;&#125;&#125;@media all and (device-height:800px)&#123; … &#125;@media all and (orientation:landscape)&#123; … &#125;@media all and (device-aspect-ratio:16/10)&#123; … &#125;@media all and (min-color:1)&#123; … &#125;@media all and (monochrome:0)&#123; … &#125;@media all and (grid:0)&#123; … &#125; @font-face定义和用法设置嵌入HTML文档的字体。 &lt;identifier&gt;：字体名称 &lt;url&gt;：此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径 &lt;string&gt;：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype, opentype，embedded-opentype, svg等 &lt;font&gt;：定义字体相关样式 12345678@font-face &#123; font-family: &apos;diyfont&apos;; src: url(&apos;diyfont.eot&apos;); /* IE9+ */ src: url(&apos;diyfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;diyfont.woff&apos;) format(&apos;woff&apos;), /* chrome、firefox */ url(&apos;diyfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url(&apos;diyfont.svg#fontname&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125; @page定义和用法设置页面容器的版式，方向，边空等。 &lt;label&gt;：页面标识符 &lt;pseudo-class&gt;：打印伪类:first, :left, :right @page:first{margin:300px;} @keyframes定义和用法指定动画名称和动画效果。@keyframes定义的动画名称用来被animation-name所使用。定义动画时，简单的动画可以直接使用关键字from和to，即从一种状态过渡到另一种状态： 12345678@keyframes testanimations&#123; 0%&#123;transform:translate(0,0);&#125; 20%&#123;transform:translate(20,20);&#125; 40%&#123;transform:translate(40,0);&#125; 60%&#123;transform:translate(60,20);&#125; 80%&#123;transform:translate(80,0);&#125; 100%&#123;transform:translate(100,20);&#125;&#125; CSS 函数 名称 描述 counter() 插入计数器，counter()只能被使用在content属性上。li:before{counter-increment:item;content:counter(item)&quot;.&quot;;color:#f00;} attr() 插入元素的属性值。div{width:attr(width, px, auto);} calc() 用于动态计算长度值。任何长度值都可以使用calc()函数进行计算。calc()函数支持+, -, *, /, mod运算，以后还可能加入对min()/max()等运算。.test{width:-moz-calc(100% - 50px);width:calc(100% - 50px);background:#eee;} min() 用于比较数值的大小并取出最小的那个。div{width:min(10% + 20px, 300px);} max() 用于比较数值的大小并取出最大的那个。div{width:max(10% + 20px, 300px);} cycle() 允许子孙元素使用取值序列中的值循环替换继承而来的值。li &gt; ul{list-style-type:toggle(disk,circle,square,box);} Image 属性 描述 linear-gradient() 用线性渐变创建图像。 radial-gradient() 用径向渐变创建图像。 repeating-linear-gradient() 用重复的线性渐变创建图像。 repeating-radial-gradient() 用重复的径向渐变创建图像。 CSS单位CSS 的单位对于 CSS 的值有是一个直接影响的。因为 CSS 的单位直接对 CSS 的值的计算是有直接影响的，在 CSS 中单位的之间有一个关系如下所示： 单位 描述 角度单位&lt;angle&gt; deg：度grad：梯度rad：弧度turn：圈 字体单位&lt;length&gt; em：相对于父元素rem：相对于根元素ch：数字“0”的宽度ex：相对长度单位。相对于字符“x”的高度。通常为字体高度的一半。 频率单位&lt;frequency&gt; Hz：赫兹KHz：千赫兹 整数单位&lt;length&gt; px：相对长度单位，像素 长度单位&lt;length&gt; cm：厘米（Centimeters）。绝对长度单位。mm：毫米（Millimeters）。绝对长度单位。in：英寸（Inches）。绝对长度单位。pt：点（Points）。绝对长度单位。pc：派卡（Picas）。绝对长度单位。相当于我国新四号铅字的尺寸。px：相对长度单位。像素（Pixels）。 百分比单位 %：百分比 分辨率单位&lt;resolution&gt; dpi：每英寸包含点的数量（dots per inch）普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx），打印时一般会需要更大的dpi；dpcm：每厘米包含点的数量（dots per centimeter）dppx：每像素包含点的数量（dots per pixel） 时间单位&lt;time&gt; s:秒ms:毫秒 视窗单位&lt;length&gt; vw：相对于视口的宽度。视口被均分为100单位的vwvh：相对于视口的高度。视口被均分为100单位的vhvmax：相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmaxvmin：相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin 单位 描述 相对单位 字体相对单位：em、rem、ch、ex视窗相对单位：vw、vh、vmax、vmin 绝对单位 px、pt、pc、cm、mm、in 角度单位 deg、grad、rad、turn 时间单位 s、ms 分辨率单位 dpi、dpcm、dppx 频率单位 Hz、KHz 绝对单位不受任何屏幕大小或字体的影响。这些单位的显示可能会根据不同的屏幕分辨率而有所不同，因为它们取决于屏幕的DPI（每英寸上的点数）。绝对单位常用于一些物理测量上。在环境输出已知的情形下非常有用。 分辨率术语 术语 描述 720P 1280*720-称为：HD，中文译为“高清” 1080P 1920*1080-称为：FULL HD，中文称为“全高清” 1440P 2560*1440-称为：QHD或Quad HD,即4倍的HD 2160P 3840*2160-称为：4K 4320P 7680*4320-称为：8K 参考地址：https://www.w3cplus.com/css/css-values-and-units.html 颜色值 属性 描述 HEX 颜色值十六进制(HEX)表示,语法如：#rrggbb或#rgb RGB RGB表示方式，语法如：rgb(128,128,128) RGBA 颜色值RGBA表示方式，语法如：rgba(128,128,128,0.5) HSL 颜色值HSL表示方式，HSL(Hue-色调,Saturation-饱和度,Lightness-亮度) HSLA 颜色值HSLA表示方式，HSL(Hue-色调,Saturation-饱和度,Lightness-亮度,Alpha-透明度)语法如：hsla(360,50%,50%,0.5) Transparent 颜色值透明(Transparent)表示方式(RGBA) 元素选择符 选择符 描述 通配选择符* 选定所有对象。 类型选择符E 以文档语言对象类型作为选择符。 ID选择符E#ID 以唯一标识符id属性等于myid的E对象作为选择符。 类选择符E.Class 以class属性包含myclass的E对象作为选择符。 关系选择符 选择符 描述 包含选择符E F 选择所有被E元素包含的F元素。 子选择符E&gt;F 选择所有作为E元素的子元素F。 相邻选择符E+F 选择紧贴在E元素之后F元素。 兄弟选择符E~F 选择E元素后面的所有兄弟元素F。 属性选择符 选择符 描述 E[att] 选择具有att属性的E元素。 E[att=&quot;val&quot;] 选择具有att属性且属性值等于val的E元素。 E[att~=&quot;val&quot;] 选择具有att属性且属性值为一用空格分隔的字词列表，其中一个等于val的E元素。 E[att^=&quot;val&quot;] 选择具有att属性且属性值为以val开头的字符串的E元素。 E[att$=&quot;val&quot;] 选择具有att属性且属性值为以val结尾的字符串的E元素。 E[att*=&quot;val&quot;] 选择具有att属性且属性值为包含val的字符串的E元素。 ```E[att =”val”]``` 伪类选择符 选择符 描述 E:link 设置超链接a在未被访问前的样式。 E:visited 设置超链接a在其链接地址已被访问过时的样式。 E:hover 设置元素在其鼠标悬停时的样式。 E:active 设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 E:focus 设置元素在成为输入焦点（该元素的onfocus事件发生）时的样式。 E:lang(fr) 匹配使用特殊语言的E元素。 E:not(s) 匹配不含有s选择符的元素E。 E:root 匹配E元素在文档的根元素。 E:first-child 匹配父元素的第一个子元素E。 E:last-child 匹配父元素的最后一个子元素E。 E:only-child 匹配父元素仅有的一个子元素E。 E:nth-child(n) 匹配父元素的第n个子元素E。 E:nth-last-child(n) 匹配父元素的倒数第n个子元素E。 E:first-of-type 匹配同类型中的第一个同级兄弟元素E。 E:last-of-type 匹配同类型中的最后一个同级兄弟元素E。 E:only-of-type 匹配同类型中的唯一的一个同级兄弟元素E。 E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E。 E:nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E。 E:empty 匹配没有任何子元素（包括text节点）的元素E。 E:checked 匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时) E:enabled 匹配用户界面上处于可用状态的元素E。 E:disabled 匹配用户界面上处于禁用状态的元素E。 E:target 匹配相关URL指向的E元素。 @page:first 设置页面容器第一页使用的样式。仅用于@page规则 @page:left 设置页面容器位于装订线左边的所有页面使用的样式。仅用于@page规则 @page:right 设置页面容器位于装订线右边的所有页面使用的样式。仅用于@page规则 伪对象选择符 选择符 描述 E:first-letter/:first-letter 设置对象内的第一个字符的样式。 E:first-line/:first-line 设置对象内的第一行的样式。 E:before/:before 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E:after/:after 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E::placeholder 设置对象文字占位符的样式。 E::selection 设置对象被选择时的颜色。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5地理定位]]></title>
    <url>%2F2019%2F08%2F27%2FHTML5%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[位置定位地理位置（Geolocation）是 HTML5 的重要特性之一，提供了确定用户位置的功能，借助这个特性能够开发基于位置信息的应用。 检测浏览器是否支持123456if (navigator.geolocation) &#123;//console.log(&quot;浏览器支持!&quot;);&#125;else &#123;// console.log(&quot;浏览器不支持!&quot;);&#125; navigator.geolocation用于获取基于浏览器的当前用户地理位置123456789// 1、获取用户当前位置void getCurrentPosition(onSuccess,onError,options);// 2、持续获取当前用户位置int watchCurrentPosition(onSuccess,onError,options);// 3、watchId 为watchCurrentPosition返回的值void clearWatch(watchId);// 取消监控 示例代码PS：也可以调用百度地图、谷歌地图、高德地图等，只需要将HTML5 Geolocation API获取到的值传入到相应的地图接口中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;/&gt;&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no&quot;&gt;&lt;title&gt;基于浏览器的HTML5地理定位&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;div id=&quot;info&quot;&gt;&lt;/div&gt; &lt;script src=&quot;http://map.qq.com/api/js?v=2.exp&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script&gt; var clientWidth = document.documentElement.clientWidth, clientHeight = document.documentElement.clientHeight; var container = document.getElementById(&apos;container&apos;); container.style.width = clientWidth + &apos;px&apos;; container.style.height = clientHeight + &apos;px&apos;; function getLocation()&#123; var options=&#123; enableHighAccuracy:true, //boolean 是否要求高精度的地理信息，默认为false maximumAge:1000 //应用程序的缓存时间 &#125; if(navigator.geolocation)&#123; //浏览器支持geolocation navigator.geolocation.getCurrentPosition(onSuccess,onError,options); &#125;else&#123; //浏览器不支持geolocation console.log(&quot;浏览器不支持!&quot;); &#125; &#125; //成功时 function onSuccess(position)&#123; //返回用户位置 //经度 var longitude =position.coords.longitude; //纬度 var latitude = position.coords.latitude; //腾讯地图的中心地理坐标 var center = new qq.maps.LatLng(latitude, longitude); //使用腾讯地图API var map = new qq.maps.Map(document.getElementById(&quot;container&quot;), &#123; //地图的中心地理坐标 center: center, //初始化地图缩放级别 zoom: 16 &#125;); //在地图中创建信息提示窗口 var infoWin = new qq.maps.InfoWindow(&#123; map: map &#125;); //打开信息窗口 infoWin.open(); //设置信息窗口显示区的内容 infoWin.setContent(&apos;&lt;div style=&quot;width:200px;padding:10px;&quot;&gt;&apos;+ &apos;您在这里&lt;br/&gt;纬度：&apos;+ latitude+ &apos;&lt;br/&gt;经度：&apos;+longitude); //设置信息窗口的位置 infoWin.setPosition(center); &#125; //失败时 function onError(error)&#123; switch(error.code)&#123; case error.PERMISSION_DENIED: alert(&quot;用户拒绝对获取地理位置的请求&quot;); break; case error.POSITION_UNAVAILABLE: alert(&quot;位置信息是不可用的&quot;); break; case error.TIMEOUT: alert(&quot;请求用户地理位置超时&quot;); break; case error.UNKNOWN_ERROR: alert(&quot;未知错误&quot;); break; &#125; &#125; window.onload=getLocation; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 服务器发送事件]]></title>
    <url>%2F2019%2F08%2F27%2FHTML5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Server-Sent EventsServer-Sent Events(SSE)用于网页自动获取服务器上更新的数据，它是一个实时性的机制 实时性获取数据 Polling(轮询)：在客户端重复的向服务端发送新请求。如果服务器没有新的数据更动，关闭本次连接。然后客户端在稍等一段时间之后，再次发起新请求，一直重复这样的步骤。 Long-polling(长轮询)：在长轮询中，客户端发送一个请求到服务端。如果服务端没有新的数据更动，那么本次连接将会被保持，直到等待到更新后的数据，返回给客户端并关闭这个连接。 Server-Sent Events：SSE类似于长轮询的机制，但是它在每一次的连接中，不只等待一次数据的更动。客户端发送一个请求到服务端 ，服务端保持这个请求直到一个新的消息准备好，将消息返回至客户端，此时不关闭连接，仍然保持它，供其它消息使用。SSE的一大特色就是重复利用一个连接来处理每一个消息（又称event）。 WebSocker：WebSocket不同于以上的这些技术，因为它提供了一个真正意义上的双向连接。WebSocket是HTML5中非常强大的新特性，已经得到广泛应用。 Server-Sent Events实现在后台获取时间，不断发送给前台。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;获得服务器更新&lt;/h1&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt; if(typeof(EventSource)!==&quot;undefined&quot;)&#123; var source=new EventSource(&quot;/example/html5/demo_sse.php&quot;); source.onmessage=function(event)&#123; document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;; alert(&quot;提示有新的内容&quot;); this.location.reload(); &#125;; &#125; else &#123; document.getElementById(&quot;result&quot;).innerHTML=&quot;抱歉，您的浏览器不支持 server-sent 事件 ...&quot;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端代码12345678&lt;?php header(&apos;Content-Type: text/event-stream&apos;); header(&apos;Cache-Control: no-cache&apos;); $time = date(&apos;r&apos;); echo &quot;data: The server time is: &#123;$time&#125;\n\n&quot;; flush();?&gt; EventSource对象 属性 描述 onopen 当通信服务器连接被打开 onmessage 当接收到消息 onerror 当发生错误 其他自动刷新方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 1.页面自动刷新：把如下代码加入&lt;head&gt;区域中 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt;,其中20指每隔20秒刷新一次页面. // 2.页面自动跳转：把如下代码加入&lt;head&gt;区域中 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;20;url=http://www.jb51.net&quot;&gt;// 其中20指隔20秒后跳转到http://www.jb51.net页面 // 3.页面自动刷新js版 &lt;script language=&quot;javascript&quot;&gt; function myrefresh()&#123; window.location.reload(); &#125; setTimeout(&apos;myrefresh()&apos;,1000); //指定1秒刷新一次 &lt;/script&gt; // 4.websocker&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;websocket&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function WebSocketTest() &#123; if (&quot;WebSocket&quot; in window) &#123; alert(&quot;您的浏览器支持 WebSocket!&quot;); // 打开一个 web socket var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(&quot;发送数据&quot;); alert(&quot;数据发送中...&quot;); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(&quot;数据已接收...&quot;); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(&quot;连接已关闭...&quot;); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(&quot;您的浏览器不支持 WebSocket!&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sse&quot;&gt; &lt;a href=&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 Web Worker用法]]></title>
    <url>%2F2019%2F08%2F26%2FHTML5-Web-Worker%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Web Worker的用法简单来说，其实就是在Javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后再回到主线程上，在这个过程中并不影响主线程的执行过程。 判断当前浏览器是否支持web worker1234567891011121314151617if (typeof (Worker) != &quot;undefined&quot;) &#123; //浏览器支持web worker if (typeof (w) == &quot;undefined&quot;) &#123; //w是未定义的,还没有开始计数 w = new Worker(&quot;webworker.js&quot;); //创建一个Worker对象,利用Worker的构造函数 &#125; //onmessage是Worker对象的properties w.onmessage = function (event) &#123; //事件处理函数,用来处理后端的web worker传递过来的消息 // do something &#125;;&#125; else &#123; // 浏览器不支持web worker // do something&#125; API 创建新的Worker var worker = new Worker(&quot;worker.js&quot;) 传递参数 worker.postMessage() 接收消息 worker.onMessage = function(msg){} 异常处理 worker.onerror = function(err){} 结束worker worker.terminate() 载入工具类函数 importScripts() 作用域创建一个新的worker时，该代码会运行在一个全新的javascript的环境中（WorkerGlobalScope）运行,是完全和创建worker的脚本隔离，这时我们可以把创建新worker的脚本叫做主线程，而被创建的新的worker叫做子线程。 WorkerGlobalScope是worker的全局对象，所以它包含所有核心javascript全局对象拥有的属性如JSON等，window的一些属性，也拥有类似于XMLHttpRequest()等。 但是我们所开启的新的worker也就是子线程，并不支持操作页面的DOM。 共享线程（SharedWorker）共享线程是为了避免线程的重复创建和销毁过程，降低了系统性能的消耗，共享线程SharedWorker可以同时有多个页面的线程链接。 var worker = new SharedWorker(&quot;sharedworker.js&quot;); 共享线程也使用了message事件监听线程消息，但使用SharedWorker对象的port属性与线程通信如下: worker.port.onmessage = function(msg){}; 同时我们也可以使用SharedWorker对象的port属性向共享线程发送消息如下： worker.port.postMessage(msg); 应用 可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信 可以在worker中通过importScripts(url)加载另外的脚本文件 可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval() 可以使用XMLHttpRequest来发送请求 可以访问navigator的部分属性 注意事项 不能跨域加载JS worker内代码不能访问DOM 各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行 不是每个浏览器都支持这个新特性]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5本地存储]]></title>
    <url>%2F2019%2F08%2F26%2FHTML5%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[localStroage &amp; sessionStroageHTML5 提供了本地存储对象 window.localStroage - 存储没有截止日期的数据（localStorage 生命周期是永久，除非主动清除 localStorage 信息，否则这些信息将永远存在。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。） window.sessionStroage - 针对一个 Session 的数据存储（仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。） 两者区别就是一个作为临时保存，一个长期保存。 之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 localStroage123456789// 1、保存数据到本地// 第一个参数是保存的变量名，第二个是赋给变量的值localStorage.setItem(&apos;Author&apos;, &apos;local&apos;);// 2、从本地存储获取数据localStorage.getItem(&apos;Author&apos;);// 3、从本地存储删除某个已保存的数据localStorage.removeItem(&apos;Author&apos;);// 4、清除所有保存的数据localStorage.clear(); 应用场景实际工作中对 localstorage 的使用一般有以下需求： 缓存一般信息，如搜索页的出发城市，达到城市，非实时定位信息 缓存城市列表数据，这个数据往往比较大 每条缓存信息需要可追踪，比如服务器通知城市数据更新，这个时候在最近一次访问的时候要自动设置过期 每条信息具有过期日期状态，在过期外时间需要由服务器拉取数据 ………… sessionStroage123456789// 1、保存数据到本地// 第一个参数是保存的变量名，第二个是赋给变量的值sessionStorage.setItem(&apos;Author&apos;, &apos;session&apos;);// 2、从本地存储获取数据sessionStorage.getItem(&apos;Author&apos;);// 3、从本地存储删除某个已保存的数据sessionStorage.removeItem(&apos;Author&apos;);// 4、清除所有保存的数据sessionStorage.clear(); 其他隐私模式下可以采用 window.name 模拟 sessionStorage 的方式处理，因为 window.name 是可做保存的，这个也是其解决跨域方案的原因。 postMessage 发送：调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象 otherWindow.postMessage(message, targetOrigin, [transfer]); 监听：message 事件 window.addEventListener( &quot;message&quot;, function(event) {alert(event.data);}) 假设在 a.html 里嵌套个&lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;,在这两个页面里互相通信 a.com/a.html1234567window.onload = function() &#123; window.addEventListener(&quot;message&quot;, function(event) &#123; alert(event.data); &#125;); //window.frames[0].postMessage(&quot;b data&quot;, &quot;http://www.b.com/b.html&quot;); //调用postMessage方法的window对象是指要接收消息的那一个window对象&#125; b.com/b.html123456window.onload = function() &#123; //window.addEventListener(&quot;message&quot;, function(event) &#123; // alert(event.data); //&#125;); window.parent.postMessage(&quot;a需要的数据&quot;, &quot;http://www.a.com/a.html&quot;);&#125; postMessage是从a窗口发送信息到b窗口，b窗口监听到消息后做出回应； localStorage是在a窗口改变某一个存储值，b窗口监听到了存储值的变化，然后获取该值，进而完成通信的同样的效果。 HTML5 应用缓存在 Html5 中，提供了一种叫 Application Cache 应用程序缓存的技术，通俗解释就是，通过一个文本文件可以告诉浏览器，我这个网页中的资源，哪些本地有就直接用本地，哪些必须要去网络拉取。 其实就是离线资源使用，本地缓存，如果有缓存，就能提升页面访问速度，节省流量，也能减少服务端负载，进而节省带宽费用。 如何实现 HTML5 应用程序缓存？ 创建一个 cache.manifest 文件，并确保文件具有正确的内容 在服务器上设置内容类型 所有的 HTML 文件都指向 cache.manifest cache.manifest1234567891011121314151617CACHE MANIFEST# version1CACHE:index.html404.htmlfavicon.icorobots.txthumans.txtapple-touch-icon.pngcss/main.cssimg/pho-cat.jpgFALLBACK:online.js local.jsNETWORK:* 注意事项： 第一行必须是”CACHE DMANIFEST”文字，以把本文件的作用告知浏览器，即对本地缓存中的资源文件进行具体设置。 在 manifest 文件中，可以加上注释来进行一些必要说明或解释。注释行以”#”文字开头。 在 CACHE 之后的部分为列出我们需要缓存的文件。 在 FALLBACK 之后的部分每一行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时使用的备用资源文件。 在 NETWORK 之后可以指定在线白名单，即列出我们不希望离线存储的文件，因为通常它们的内容需要互联网访问才有意义。 另外，在此部分我们可以使用快捷方式：通配符* 这将告诉浏览器，应用服务器中获取没有在显示部分中提到的任何文件或 URL。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F08%2F25%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML 基础 HTML 文档元信息 &lt;meta/&gt; 的重要性&lt;meta/&gt; 可分为两大部分：[ http-equiv ] 和 [ name ] 变量 [ http-equiv ]http-equiv相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助浏览器正确地显示网页内容。 值 描述 content-type 设定页面使用的字符集&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html; charset=&quot;utf-8&quot;&gt;UTF-8：世界通用的语言编码GB2312：编码是简体中文ISO-8859-1：编码是英文 X-UA-Compatible IE8的专用标记，用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式，以此来解决部分兼容问题&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot;&gt;以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8/9都会以IE7引擎来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot;&gt;以上代码告诉IE浏览器，IE8/9都会以IE8引擎来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame expires 设定网页的过期时间&lt;meta http-equiv=&quot;expires&quot;content=&quot;Fri,12Jan200118:18:18GMT&quot;&gt;必须使用GMT的时间格式 refresh 自动刷新并指向新页面&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2;URL=https://www.baidu.com&quot;&gt; set-cookie 如果网页过期，那么自动删除本地cookie&lt;meta http-equiv=&quot;Set-Cookie&quot;content=&quot;cookie value=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt;必须使用GMT的时间格式 windows-target 强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;&gt; cache-control 缓存机制&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;Public：指示响应可被任何缓存区缓存。Private：指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。no-cache：指示请求或响应消息不能缓存。no-store：用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。max-age：指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。min-fresh：指示客户机可以接收响应时间小于当前时间加上指定时间的响应。max-stale：指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 [ name ]name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 值 描述 author 标注网页的作者&lt;meta name=&quot;author&quot; content=&quot;value&quot; /&gt; keywords 页面关键词，用于被搜索引擎收录&lt;meta name=&quot;keywords&quot; content=&quot;value1,value2&quot;&gt; description 页面描述，用于搜索引擎收录&lt;meta name=&quot;description&quot; content=&quot;value&quot;&gt; viewport 用于控制页面缩放&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt; renderer 指定双核浏览器默认以何种方式渲染页面&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;webkit：默认webkit内核ie-comp：默认IE兼容模式ie-stand：默认IE标准模式 generator 说明网站的采用的什么软件制作&lt;meta name=&quot;generator&quot; content=&quot;Microsoft&quot;/&gt; revised 网页文档的修改时间&lt;meta name=&quot;revised&quot; content=&quot;WebName, MM/DD/YYYY&quot;/&gt; robots 用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引&lt;meta name=&quot;robots&quot; content=&quot;all&quot;/&gt;all：文件将被检索，且页面上的链接可以被查询none：文件将不被检索，且页面上的链接不可以被查询index：文件将被检索noindex：页面上的链接可以被查询follow：文件将不被检索，但页面上的链接可以被查询nofollow：文件将不被检索，页面上的链接可以被查询 copyright 网站版权信息&lt;meta name=&quot;copyright&quot; content=&quot;本页版权XXX所有。All Rights Reserved&quot; /&gt; HTML 块级元素 &amp; 内联元素 &amp; 置换元素 类型 描述 块级元素 div、header、nav、article、aside、section、footer、p、h1~h6、ul、ol… 块级元素特点： 独占一行 行高和边距可变 可以容纳块级元素和内联元素 display: block / table; 类型 描述 内联元素 span、img、label、input、button…. 内联元素特点： 与其他元素在同一行上 行高和边距不可变 只可容纳内联元素 display: inline / inline-block; 置换元素一个内容不受 CSS 视觉格式化模型控制，CSS 渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，浏览器会根据置换元素的标签和属性，来决定元素的具体显示内容。 置换元素与一般行内元素的区别在于：置换元素拥有内在尺寸，可以设置宽高，其性质等同于设置了 display: inline-block; 的元素。 常见的有 &lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;等 HTML 语义化 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 标签 语义 &lt;article&gt; 定义文档内的文章 &lt;aside&gt; 定义页面内容之外的内容 &lt;details&gt; 定义用户可查看或隐藏的额外细节 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题 &lt;figure&gt; 定义自包含内容，比如图示、图表、照片、代码清单等等 &lt;footer&gt; 定义文档或节的页脚 &lt;header&gt; 定义文档或节的页眉 &lt;main&gt; 定义文档的主内容 &lt;mark&gt; 定义重要或强调的内容 &lt;nav&gt; 定义文档内的导航链接 &lt;section&gt; 定义文档中的节 &lt;summary&gt; 定义 &lt;details&gt;元素的可见标题 &lt;time&gt; 定义日期/时间 例如下面这段代码:12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--页眉--&gt; &lt;header&gt;&lt;/header&gt; &lt;!--导航--&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!--主内容--&gt; &lt;main&gt; &lt;!--文章--&gt; &lt;article&gt; &lt;!--节--&gt; &lt;section&gt; &lt;!-- 表单 --&gt; &lt;form&gt; &lt;!-- 围绕表单的边框 --&gt; &lt;fieldset&gt; &lt;!-- fieldset 元素的标题 --&gt; &lt;legend&gt;Personalia:&lt;/legend&gt; &lt;!-- input标注 --&gt; &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt; &lt;!-- 重置按钮 --&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/fieldset&gt;&gt; &lt;/form&gt; &lt;/section&gt; &lt;/article&gt; &lt;!-- 页面内容之外的内容 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;!--页脚--&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; Canvas 图形绘制1234&lt;script&gt; var c = document.getElementById(&apos;myCanvas&apos;); var ctx = c.getContext(&apos;2d&apos;)&lt;/script&gt; 绘制基本图形 图形 方法 直线 moveTo(x,y) lineTo(x,y) 闭环 closePath() 矩形 rect(x,y,w,h) 曲线 二次贝塞尔曲线：context.quadraticCurveTo(cpx,cpy,x,y)三次方贝塞尔曲线：bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y) 圆形 arc(x,y,r,sAngle,eAngle,counterclockwise) 线性渐变 createLinearGradient(x0,y0,x1,y1) addColorStop(stop,color) 平移图形 translate(x,y) 缩放效果 scale(scalewidth,scaleheight) 旋转效果 rotate(angle) 颜色 &amp; 阴影 属性 描述 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 图像的应用复制图像：drawImage(img,sx,sy,swidth,sheight,x,y,width,height)裁剪图像：clip()平铺图像：createPattern(image,”repeat|repeat-x|repeat-y|no-repeat”) 属性 描述 img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度。（伸展或缩小图像） height 可选。要使用的图像的高度。（伸展或缩小图像） 文字的应用“被填充的”文本：fillText(text,x,y,maxWidth)绘制文本（无填充）：strokeText(text,x,y,maxWidth) HTML5 代码规范 请使用正确的文档类型&lt;!DOCTYPE html&gt; 使用小写元素名混合大小写名称并不好开发者习惯使用小写名（比如在 XHTML 中）小写更起来更纯净小写更易书写 关闭所有HTML元素 关闭空的HTML元素 使用小写属性名混合属性名并不好开发者习惯于使用小写属性名（比如在 XHTML 中）小写属性名看情况更纯净小写属性名更易书写 属性值加引号如果属性值包含值，则必须使用引号混合样式绝对不好加引号的值更易阅读 必要的属性请始终对图像使用 alt 属性。当图像无法显示时该属性很重要。 空格和等号，精简空格更易阅读。 避免长代码行(80个字符以内) 空格和缩进，请勿毫无理由地增加空行。 不能省略&lt;html&gt;&lt;/html&gt;和&lt;body&gt;&lt;/body&gt;、&lt;head&gt;&lt;/head&gt; 元数据，文档中对语言和字符编码的定义越早越好。 HTML注释短注释应该在单行中书写，并在 &lt;!-- 之后增加一个空格，在 &lt;!--之前增加一个空格 样式表开括号与选择器位于同一行在开括号之前用一个空格使用两个字符的缩进在每个属性与其值之间使用冒号加一个空格在每个逗号或分号之后使用空格在每个属性值对（包括最后一个）之后使用分号只在值包含空格时使用引号来包围值把闭括号放在新的一行，之前不用空格避免每行超过 80 个字符注释：在逗号或分号之后添加空格，是所有书写类型的通用规则。 在HTML中加载JavaScript 通过JavaScript访问HTML元素 使用小写文件名 文件扩展名.html]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
