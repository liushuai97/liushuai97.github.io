<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP报文]]></title>
    <url>%2F2019%2F08%2F30%2FHTTP%E6%8A%A5%E6%96%87%2F</url>
    <content type="text"><![CDATA[HTTP 报文请求报文 HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。 规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。 123&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;&lt;headers&gt;&lt;entity-body&gt; HTTP 定义了与服务器交互的不同方法，最基本的方法有4种，分别是GET，POST，PUT，DELETE。 URL全称是资源描述符，我们可以这样认为：一个URL地址，它用于描述一个网络上的资源，而 HTTP 中的GET，POST，PUT，DELETE就对应着对这个资源的查，增，改，删4个操作。 Get &amp; Post GET 用于信息获取，而且应该是安全的和幂等的。 安全的：意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 幂等的：意味着对同一 URL 的多个请求应该返回同样的结果。 GET 请求报文示例： 12345GET /books/?sex=man&amp;name=Professional HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Connection: Keep-Alive POST 表示可能修改变服务器上的资源的请求。 12345678POST / HTTP/1.1Host: www.example.comUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)Gecko/20050225 Firefox/1.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 40Connection: Keep-Alivesex=man&amp;name=Professional 注意: GET 可提交的数据量受到URL长度的限制，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制； 理论上讲，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制，出于安全考虑，服务器软件在实现时会做一定限制； 参考上面的报文示例，可以发现 GET 和 POST 数据内容是一模一样的，只是位置不同，一个在 URL 里，一个在 HTTP 包的包体里。 POST 提交数据的方式HTTP 协议中规定 POST 提交的数据必须在 body 部分中，但是协议中没有规定数据使用哪种编码方式或者数据格式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。 但是，数据发送出去，还要服务端可以根据 Content-Type 和 Content-Encoding解析成功才有意义。 一般服务端语言都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据，包含了 Content-Type 和消息主体编码方式两部分： application/x-www-form-urlencoded 这是最常见的 POST 数据提交方式。浏览器的原生&lt;form&gt;表单，如果不设置 enctype属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。上个小节当中的例子便是使用了这种提交方式。可以看到 body 当中的内容和 GET 请求是完全相同的。 multipart/form-data 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 &lt;form&gt; 表单的 enctype 等于 multipart/form-data。 举个例子： 12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 &lt;form&gt;表单也只支持这两种方式（通过 &lt;form&gt;元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。 随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，例如 application/json，text/xml，乃至 application/x-protobuf 这种二进制格式。 响应报文HTTP 响应与 HTTP 请求相似，HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 响应正文 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。 下面是一个HTTP响应的例子： 1234567HTTP/1.1 200 OKServer:Apache Tomcat/5.0.12Date:Mon,6Oct2003 13:23:42 GMTContent-Length:112&lt;html&gt;... 条件 GETHTTP 条件 GET 是 HTTP 协议为了减少不必要的带宽浪费，提出的一种方案。 HTTP 条件 GET 使用的时机？客户端之前已经访问过某网站，并打算再次访问该网站。 HTTP 条件 GET 使用的方法？客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。 下面是一个具体的发送接受报文示例： 客户端发送请求： 1234GET / HTTP/1.1 Host: www.sina.com.cn:80 If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT Connection: Close 第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件。 12345678HTTP/1.0 304 Not Modified Date: Thu, 04 Feb 2010 12:38:41 GMT Content-Type: text/html Expires: Thu, 04 Feb 2010 12:39:41 GMT Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT Age: 28 X-Cache: HIT from sy32-21.sina.com.cn Connection: close 如果服务器端资源已经更新的话，就返回正常的响应。 会话跟踪 什么是会话？ 客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话。 什么是会话跟踪？ 会话跟踪指的是对同一个用户对服务器的连续的请求和接受响应的监视。 为什么需要会话跟踪？ 浏览器与服务器之间的通信是通过HTTP协议进行通信的，而HTTP协议是”无状态”的协议，它不能保存客户的信息，即一次响应完成之后连接就断开了，下一次的请求需要重新连接，这样就需要判断是否是同一个用户，所以才有会话跟踪技术来实现这种要求。 会话跟踪常用的方法: URL 重写：URL(统一资源定位符)是Web上特定页面的地址，URL重写的技术就是在URL结尾添加一个附加数据以标识该会话,把会话ID通过URL的信息传递过去，以便在服务器端进行识别不同的用户。 隐藏表单域：将会话ID添加到HTML表单元素中提交到服务器，此表单元素并不在客户端显示 Cookie：Cookie 是Web 服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将 Cookie 发送到客户端,在客户端可以进行保存,客户端可以采用两种方式来保存这个 Cookie 对象，以便下次使用。一种方式是保存在客户端内存中，称为临时 Cookie，浏览器关闭后这个 Cookie 对象将消失。另外一种方式是保存在客户机的磁盘上，称为永久 Cookie。以后客户端只要访问该网站，就会将这个 Cookie 再次发送到服务器上，前提是这个 Cookie 在有效期内，这样就实现了对客户的跟踪。（Cookie 是可以被客户端禁用的。） Session：每一个用户都有一个不同的 session，各个用户之间是不能共享的，是每个用户所独享的，在 session 中可以存放信息。在服务器端会创建一个 session 对象，产生一个 sessionID 来标识这个 session 对象，然后将这个 sessionID 放入到 Cookie 中发送到客户端，下一次访问时，sessionID 会发送到服务器，在服务器端进行识别不同的用户。Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。 跨站攻击 CSRF（Cross-site request forgery，跨站请求伪造）CSRF(XSRF) 顾名思义，是伪造请求，冒充用户在站内的正常操作。 例如，一论坛网站的发贴是通过 GET 请求访问，点击发贴之后 JS 把发贴内容拼接成目标 URL 并访问：http://example.com/bbs/create_post.php?title=标题&amp;content=内容那么，我们只需要在论坛中发一帖，包含一链接：http://example.com/bbs/create_post.php?title=我是脑残&amp;content=哈哈只要有用户点击了这个链接，那么他们的帐户就会在不知情的情况下发布了这一帖子。可能这只是个恶作剧，但是既然发贴的请求可以伪造，那么删帖、转帐、改密码、发邮件全都可以伪造。 如何防范 CSRF 攻击？可以注意以下几点： 关键操作只接受 POST 请求 验证码 CSRF 攻击的过程，往往是在用户不知情的情况下构造网络请求。所以如果使用验证码，那么每次操作都需要用户进行互动，从而简单有效的防御了CSRF攻击。 但是如果你在一个网站作出任何举动都要输入验证码会严重影响用户体验，所以验证码一般只出现在特殊操作里面，或者在注册时候使用。 检测 Referer 常见的互联网页面与页面之间是存在联系的，比如你在www.baidu.com 应该是找不到通往www.google.com的链接的，再比如你在论坛留言，那么不管你留言后重定向到哪里去了，之前的那个网址一定会包含留言的输入框，这个之前的网址就会保留在新页面头文件的 Referer 中。通过检查 Referer 的值，我们就可以判断这个请求是合法的还是非法的，但是问题出在服务器不是任何时候都能接受到 Referer 的值，所以 Referer Check 一般用于监控 CSRF 攻击的发生，而不用来抵御攻击。 Token 目前主流的做法是使用 Token 抵御 CSRF 攻击。下面通过分析 CSRF 攻击来理解为什么 Token 能够有效CSRF 攻击要成功的条件在于攻击者能够预测所有的参数从而构造出合法的请求。所以根据不可预测性原则，我们可以对参数进行加密从而防止 CSRF 攻击。 另一个更通用的做法是保持原有参数不变，另外添加一个参数 Token，其值是随机的。这样攻击者因为不知道 Token 而无法构造出合法的请求进行攻击。 Token 使用原则： Token 要足够随机————只有这样才算不可预测 Token 是一次性的，即每次请求成功后要更新Token————这样可以增加攻击难度，增加预测难度 Token 要注意保密性————敏感操作使用 post，防止 Token 出现在 URL 中 注意：过滤用户输入的内容不能阻挡 csrf，我们需要做的是过滤请求的来源。 XSS（Cross Site Scripting，跨站脚本攻击）XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。 运行预期之外的脚本带来的后果有很多中，可能只是简单的恶作剧——一个关不掉的窗口： 123while (true) &#123; alert(&quot;你关不掉我~&quot;);&#125; 也可以是盗号或者其他未授权的操作。 XSS 是实现 CSRF 的诸多途径中的一条，但绝对不是唯一的一条。一般习惯上把通过 XSS 来实现的 CSRF 称为 XSRF。 如何防御 XSS 攻击？理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞，漏洞的危害取决于攻击代码的威力，攻击代码也不局限于 script。防御 XSS 攻击最简单直接的方法，就是过滤用户的输入。 如果不需要用户输入 HTML，可以直接对用户的输入进行 HTML escape 。下面一小段脚本： &lt;script&gt;window.location.href=”http://www.baidu.com”;&lt;/script&gt; 经过 escape 之后就成了： &amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.baidu.com&amp;quot;&amp;lt;/script&amp;gt; 它现在会像普通文本一样显示出来，变得无毒无害，不能执行了。 当我们需要用户输入 HTML 的时候，需要对用户输入的内容做更加小心细致的处理。仅仅粗暴地去掉 script 标签是没有用的，任何一个合法 HTML 标签都可以添加 onclick 一类的事件属性来执行 JavaScript。更好的方法可能是，将用户的输入使用 HTML 解析库进行解析，获取其中的数据。然后根据用户原有的标签属性，重新构建 HTML 元素树。构建的过程中，所有的标签、属性都只从白名单中拿取。 参考资料： https://hit-alibaba.github.io/interview/basic/network/HTTP.html]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP/HTTPS协议]]></title>
    <url>%2F2019%2F08%2F30%2FHTTP-HTTPS%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP状态码 1xx（临时响应） 2xx（成功）：表示成功处理了请求的状态码。 3xx（重定向）：要完成请求，需要进一步操作。通常，这些状态码用来重定向。建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。 4xx（请求错误）：这些状态码表示请求可能出错，妨碍了服务器的处理。 5xx（服务器错误）：这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 状态码列表 状态码 描述 100（继续） 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 200（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对robots.txt文件显示此状态码，则表示已成功检索到该文件。 201（已创建） 请求成功并且服务器创建了新的资源。 202（已接受） 服务器已接受请求，但尚未处理。 203（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容） 服务器成功处理了请求，但没有返回任何内容。 205（重置内容） 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 206（部分内容） 服务器成功处理了部分 GET 请求。 300（多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 302（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 303（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304（未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。 305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 &lt;a href=answer.py?answer=&gt;301&lt;/a&gt; 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 400（错误请求） 服务器不理解请求的语法。 401（未授权） 请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止） 服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。 404（未找到） 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。 405（方法禁用） 禁用请求中指定的方法。 406（不接受） 无法使用请求的内容特性响应请求的网页。 407（需要代理授权） 此状态码与 &lt;a href=answer.py?answer=35128&gt;401（未授权）&lt;/a&gt;类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时） 服务器等候请求时发生超时。 409（冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除） 如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 411（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型） 请求的格式不受请求页面的支持。 416（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态码。 417（未满足期望值） 服务器未满足”期望”请求标头字段的要求。 500（服务器内部错误） 服务器遇到错误，无法完成请求。 501（尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 作用域访问对象 对象名称 描述 PageScope 与页面作用域page中的属性相关的Map类 requestScope 与请求作用域request中的属性相关的Map类 sessionScope 与会话作用域session中的属性相关的Map类 applicationScope 与应用程序作用域application中的属性相关的Map类 参数访问的对象 对象名称 描述 Param 按照参数名称访问单一请求的Map对象 paramValues 按照参数名称访问数组请求的Map对象 Jsp隐式对象 对象名称 描述 PageContext 提供页面信息的内置对象的访问]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议]]></title>
    <url>%2F2019%2F08%2F30%2FTCP-IP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。 TCP/IP协议的优点 TCP/IP协议不依赖于任何特定的计算机硬件或操作系统，提供开放的协议标准，即使不考虑Internet，TCP/IP协议也获得了广泛的支持。所以TCP/IP协议成为一种联合各种硬件和软件的实用系统。 TCP/IP协议并不依赖于特定的网络传输硬件，所以TCP/IP协议能够集成各种各样的网络。用户能够使用以太网（Ethernet）、令牌环网（Token Ring Network）、拨号线路（Dial-up line）、X.25网以及所有的网络传输硬件。 统一的网络地址分配方案，使得整个TCP/IP设备在网中都具有惟一的地址 标准化的高层协议，可以提供多种可靠的用户服务。 TCP/IP协议的缺点 在服务、接口与协议的区别上就不是很清楚。一个好的软件工程应该将功能与实现方法区分开来，TCP/IP恰恰没有很好地做到这点，就使得TCP/IP参考模型对于使用新的技术的指导意义是不够的。TCP/IP参考模型不适合于其他非TCP/IP协议簇。 主机-网络层（网络接口层）本身并不是实际的一层，它定义了网络层与数据链路层的接口。物理层与数据链路层的划分是必要和合理的，一个好的参考模型应该将它们区分开，而TCP/IP参考模型却没有做到这点。 TCP传输的三次握手为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。 用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。 握手过程中使用了TCP的标志：SYN和ACK。发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 PS：若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 断开TCP连接的四次挥手 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 为什么连接的时候是三次握手，关闭的时候却是四次挥手？因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP]]></title>
    <url>%2F2019%2F08%2F30%2FTCP-IP%2F</url>
    <content type="text"><![CDATA[应用层（Application Layer）应用层(Application Layer)包含所有的高层协议。 应用层是所有用户所面向的应用程序的统称。ICP/IP协议族在这一层面有着很多协议来支持不同的应用，如我们进行万维网（WWW）访问用到了HTTP协议、DNS用于把主机名映射到网络地址、文件传输用FTP协议、电子邮件发送用SMTP、域名的解析用DNS协议、 远程登录用Telnet协议等等，都是属于TCP/IP应用层的. NNTP用于新闻的发布、检索和获取； 包括：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。 简单说来：应用层是应用程序间沟通的层，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等。 TCP/IP 是用于因特网 (Internet) 的通信协议。通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。 TCP/IP 是供已连接因特网的计算机进行通信的通信协议。 TCP/IP 指传输控制协议/网际协议 (Transmission Control Protocol / Internet Protocol)。 TCP/IP 定义了电子设备（比如计算机）如何连入因特网，以及数据如何在它们之间传输的标准。 TCP/IP 中包含一系列用于处理数据通信的协议： TCP (传输控制协议) - 应用程序之间通信 UDP (用户数据包协议) - 应用程序之间的简单通信 IP (网际协议) - 计算机之间的通信 ICMP (因特网消息控制协议) - 针对错误和状态 DHCP (动态主机配置协议) - 针对动态寻址 TCP 用于应用程序之间的通信。当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。 这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。 UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。 IP 用于计算机之间的通信。IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。 通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。 IP 负责将每个包路由至它的目的地。 TCP/IPTCP/IP 意味着 TCP 和 IP 在一起协同工作。 TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。 IP 负责计算机之间的通信。 TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。 IP 负责将包发送至接受者。 HTTP - 超文本传输协议HTTP 负责 web 服务器与 web 浏览器之间的通信。 HTTP 用于从 web 客户端（浏览器）向 web 服务器发送请求，并从 web 服务器向 web 客户端返回内容（网页）。 HTTPS - 安全的 HTTPHTTPS 负责在 web 服务器和 web 浏览器之间的安全通信。 作为有代表性的应用，HTTPS 会用于处理信用卡交易和其他的敏感数据。 SSL - 安全套接字层SSL 协议用于为安全数据传输加密数据。 SMTP - 简易邮件传输协议SMTP 用于电子邮件的传输。 SMTP 协议用于传输电子邮件。SMTP 负责把邮件发送到另一台计算机。 通常情况下，邮件会被送到一台邮件服务器（SMTP 服务器），然后被送到另一台（或几台）服务器，然后最终被送到它的目的地。 SMTP 也可以传送纯文本，但是无法传输诸如图片、声音或者电影之类的二进制数据。 SMTP 使用 MIME 协议通过 TCP/IP 网络来发送二进制数据。MIME 协议会将二进制数据转换为纯文本。 MIME - 多用途因特网邮件扩展MIME 协议使 SMTP 有能力通过 TCP/IP 网络传输多媒体文件，包括声音、视频和二进制数据。 IMAP - 因特网消息访问协议IMAP 用于存储和取回电子邮件。 与 POP 类似，IMAP 协议同样被邮件程序使用。 IMAP 协议与 POP 协议之间的主要差异是：如果 IMAP 连上了邮件服务器，它不会自动地将邮件下载到邮件程序之中。 IMAP 使你有能力在下载邮件之前先通过邮件服务器端查看他们。通过 IMAP，你可以选择下载这些邮件或者仅仅是删除它们。比方说你需要从不同的位置访问邮件服务器，但是仅仅希望回到办公室的时候再下载邮件，IMAP 在这种情况下会很有用。 POP - 邮局协议POP 用于从电子邮件服务器向个人电脑下载电子邮件。 POP 协议被邮件程序用来取回邮件服务器上面的邮件。 假如你的邮件程序使用 POP，那么一旦它连接上邮件服务器，你的所有的邮件都会被下载到邮件程序中（或者称之为邮件客户端）。 FTP - 文件传输协议FTP 负责计算机之间的文件传输。 NTP - 网络时间协议NTP 用于在计算机之间同步时间（钟）。 DHCP - 动态主机配置协议DHCP 用于向网络中的计算机分配动态 IP 地址。 SNMP - 简单网络管理协议SNMP 用于计算机网络的管理。 LDAP - 轻量级的目录访问协议LDAP 用于从因特网搜集关于用户和电子邮件地址的信息。 ICMP - 因特网消息控制协议ICMP 负责网络中的错误处理。 ARP - Address Resolution ProtocolARP - 用于通过 IP 来查找基于 IP 地址的计算机网卡的硬件地址。 RARP - Reverse Address Resolution ProtocolRARP 用于通过 IP 查找基于硬件地址的计算机网卡的 IP 地址。 BOOTP - Boot ProtocolBOOTP 用于从网络启动计算机。 PPTP - 点对点隧道协议PPTP 用于私人网络之间的连接（隧道）。]]></content>
      <categories>
        <category>TCP/IP</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS @media媒体查询]]></title>
    <url>%2F2019%2F08%2F30%2FCSS-media%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[语法1234//语法：@media mediatype and | not | only (media feature) &#123; css-code; &#125;//也可以针对不同的媒体使用不同的stylesheets: &lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet.css&quot;&gt; 标签&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt; width = device-width：宽度等于当前设备的宽度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 标签中引入（CSS2 media）123&lt;link rel=&quot;stylesheet&quot; href=&quot;styleA.css&quot; media=&quot;screen&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styleB.css&quot; media=&quot;screen and (max-width: 800px)&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styleC.css&quot; media=&quot;screen and (max-width: 600px)&quot;&gt; 但是上面这个方法，最大的弊端是他会增加页面http的请求次数，增加了页面负担，我们用CSS3把样式都写在一个文件里面才是最佳的方法。 CSS3 @media1234567891011121314// 等于960px尺寸的代码，以下代码需要写在style标签或者css文件中：@media screen and (max-device-width:960px)&#123; body&#123;background:red;&#125;&#125;// 当浏览器尺寸大于960px时候的代码了：@media screen and (min-width:960px)&#123; body&#123;background:orange;&#125;&#125;// 混合使用上面的用法：@media screen and (min-width:960px) and (max-width:1200px)&#123; body&#123;background:yellow;&#125;&#125; Media所有参数汇总以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释： width:浏览器可视宽度。 height:浏览器可视高度。 device-width:设备屏幕的宽度。 device-height:设备屏幕的高度。 orientation:检测设备目前处于横向还是纵向状态。 aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio:检测设备的宽度和高度的比例。 color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色） color-index:检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid:检测输出的设备是网格的还是位图设备。 媒体类型 all 所有媒体 braille 盲文触觉设备 embossed 盲文打印机 print 手持设备 projection 打印预览 screen 彩屏设备 speech ‘听觉’类似的媒体类型 tty 不适用像素的设备 tv 电视 关键字 and not not关键字是用来排除某种制定的媒体类型 only only用来定某种特定的媒体类型 -很多时候是用来对那些不支持媒体特性但却支持媒体类型的设备 常用的几种屏幕宽度设定：123456789101112131415@media screen and (min-width: 1200px) &#123; css-code;&#125;@media screen and(min-width: 960px) and (max-width: 1199px) &#123; css-code;&#125;@media screen and(min-width: 768px) and (max-width: 959px) &#123; css-code;&#125;@media screen and(min-width: 480px) and (max-width: 767px) &#123; css-code;&#125;@media screen and (max-width: 479px) &#123; css-code;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 渐变]]></title>
    <url>%2F2019%2F08%2F30%2FCSS3-%E6%B8%90%E5%8F%98%2F</url>
    <content type="text"><![CDATA[CSS3 线性渐变CSS3 Gradient 分为 linear-gradient（线性渐变）和 radial-gradient（径向渐变）。 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向 径向渐变（Radial Gradients）- 由它们的中心定义 语法 background: linear-gradient(direction, color-stop1, color-stop2, ...); 线性渐变 - 从上到下（默认情况下） 123456#grad &#123; background: -webkit-linear-gradient(red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, blue); /* 标准的语法 */&#125; 线性渐变 - 从左到右 123456#grad &#123; background: -webkit-linear-gradient(left, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to right, red , blue); /* 标准的语法 */&#125; 线性渐变 - 对角 123456#grad &#123; background: -webkit-linear-gradient(left top, red , blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(bottom right, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(bottom right, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(to bottom right, red , blue); /* 标准的语法 */&#125; 使用角度 background: linear-gradient(angle, color-stop1, color-stop2); 123456#grad &#123; background: -webkit-linear-gradient(180deg, red, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(180deg, red, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(180deg, red, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(180deg, red, blue); /* 标准的语法 */&#125; 使用多个颜色结点 123456#grad &#123; background: -webkit-linear-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-linear-gradient(red, green, blue); /* Opera 11.1 - 12.0 */ background: -moz-linear-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: linear-gradient(red, green, blue); /* 标准的语法 */&#125; 使用透明度（transparent） 123456#grad &#123; background: -webkit-linear-gradient(left,rgba(255,0,0,0),rgba(255,0,0,1)); /* Safari 5.1 - 6 */ background: -o-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Opera 11.1 - 12*/ background: -moz-linear-gradient(right,rgba(255,0,0,0),rgba(255,0,0,1)); /* Firefox 3.6 - 15*/ background: linear-gradient(to right, rgba(255,0,0,0), rgba(255,0,0,1)); /* 标准的语法 */&#125; 重复的线性渐变 repeating-linear-gradient() 函数用于重复线性渐变： 12345678910#grad &#123; /* Safari 5.1 - 6.0 */ background: -webkit-repeating-linear-gradient(red, yellow 10%, green 20%); /* Opera 11.1 - 12.0 */ background: -o-repeating-linear-gradient(red, yellow 10%, green 20%); /* Firefox 3.6 - 15 */ background: -moz-repeating-linear-gradient(red, yellow 10%, green 20%); /* 标准的语法 */ background: repeating-linear-gradient(red, yellow 10%, green 20%);&#125; CSS3 径向渐变为了创建一个径向渐变，你也必须至少定义两种颜色结点。颜色结点即你想要呈现平稳过渡的颜色。同时，你也可以指定渐变的中心、形状（圆形或椭圆形）、大小。默认情况下，渐变的中心是 center（表示在中心点），渐变的形状是 ellipse（表示椭圆形），渐变的大小是 farthest-corner（表示到最远的角落）。 background: radial-gradient(center, shape size, start-color, ..., last-color); 径向渐变 - 颜色结点均匀分布（默认情况下） 123456#grad &#123; background: -webkit-radial-gradient(red, green, blue); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red, green, blue); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red, green, blue); /* Firefox 3.6 - 15 */ background: radial-gradient(red, green, blue); /* 标准的语法 */&#125; 径向渐变 - 颜色结点不均匀分布 123456#grad &#123; background: -webkit-radial-gradient(red 5%, green 15%, blue 60%); /* Safari 5.1 - 6.0 */ background: -o-radial-gradient(red 5%, green 15%, blue 60%); /* Opera 11.6 - 12.0 */ background: -moz-radial-gradient(red 5%, green 15%, blue 60%); /* Firefox 3.6 - 15 */ background: radial-gradient(red 5%, green 15%, blue 60%); /* 标准的语法 */&#125; 设置形状 shape 参数定义了形状。它可以是值 circle 或 ellipse。其中，circle 表示圆形，ellipse 表示椭圆形。默认值是 ellipse。 不同尺寸大小关键字的使用 size 参数定义了渐变的大小。它可以是以下四个值： closest-side farthest-side closest-corner farthest-corner 重复的径向渐变 repeating-radial-gradient() 函数用于重复径向渐变]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 动画原理]]></title>
    <url>%2F2019%2F08%2F29%2FCSS3-%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[2D/3D 旋转动画的概念：https://zhuanlan.zhihu.com/p/19855108 1234567891011121314151617181920212223242526272829div &#123; /* background-image: -webkit-linear-gradient(92deg,#f35626,#feab3a); */ width: 10px; height: 100px; margin: 0 auto; text-align: center; color: rgba(0, 0, 0, 0); background-color: #f35626; background-clip: text; /* -webkit-text-fill-color:transparent; */&#125;div:hover &#123; height: 300px; width: 600px; text-align: center; background-color: wheat; color: rgb(66, 66, 66); /* transition: 2s height ease, 2s background-color linear, 2s 2s width ease-in, 4s 4s color; */ /** 只对block级元素生效 */ /** 动画持续时长 */ transition-duration: 2s,2s,2s,4s; /** 动画渐变的属性 */ transition-property: height, background-color, width, color; /** 延迟播放动画 */ transition-delay: 0s,0s,2s,4s; /** 动画过渡函数 */ transition-timing-function: ease,linear,ease-in,normal;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html &#123; font-size: 14px; &#125; .flex &#123; position: fixed; width: 100%; height: 100%; display: flex; flex-direction: row; flex-wrap: wrap; align-items: center; align-content: center; justify-content: center; overflow: hidden; &#125; .box &#123; width: 100px; height: 100px; border: 1px solid black; background-color: #fff; /* 2D属性 translate移动(x,y) scale缩放(x,y) rotate角度(deg) skew倾斜转换(deg,deg)*/ transform: translate(20px,20px) scale(1.1,1.2) rotate(20deg) skew(20deg,40deg); -webkit-transform: translate(20px,20px) scale(1.1,1.2) rotate(20deg) skew(20deg,40deg); /* 设置旋转元素的基点位置 */ transform-origin: 10% 20%; -webkit-transform-origin: 10% 20%; /* 效果开始时间 */ transition-delay: 1s; /* 效果持续时间 */ transition-duration: 3s; /* 持续时间效果 */ transition-timing-function: cubic-bezier(0.075, 0.82, 0.165, 1); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 弹性盒子 --&gt; &lt;div class=&quot;flex&quot;&gt; &lt;!-- 绝对居中 --&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3D效果直接在属性后面添加3d，属性值相对性变成(x,y,z)三维坐标 3D加速 适用情况 通过-webkit-transform:transition3d/translateZ开启GPU硬件加速的适用范围： 使用很多大尺寸图片(尤其是PNG24图)进行动画的页面。 页面有很多大尺寸图片并且进行了css缩放处理，页面可以滚动时。 使用background-size:cover设置大尺寸背景图，并且页面可以滚动时。 编写大量DOM元素进行CSS3动画时(transition/transform/keyframes/absTop&amp;Left) 使用很多PNG图片拼接成CSS Sprite时 CSS3动画与关键帧 Animation &amp; @keyframes123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html &#123; font-size: 14px; &#125; .flex &#123; position: fixed; width: 100%; height: 100%; display: flex; flex-direction: row; flex-wrap: wrap; align-items: center; align-content: center; justify-content: center; overflow: hidden; &#125; .box &#123; position: relative; width: 100px; height: 100px; border: 1px solid transparent; background-color: #000; /* 开启3D加速 */ transform: translate3d(0, 0, 0); /* 动画名称 */ animation-name: do; /* 动画持续时间 */ animation-duration: 5s; /* 动画开始时间 */ /* animation-delay: 1s; */ /* 动画播放次数 */ animation-iteration-count: infinite; /* 动画播放速率 */ animation-timing-function:cubic-bezier(0.755, 0.05, 0.855, 0.06); /* 动画是否保留属性值 */ animation-fill-mode: forwards; &#125; /* 关键帧 */ @keyframes do &#123; 10% &#123; border-radius: 10%; &#125; 20% &#123; border-radius: 20%; transform: rotate(30deg); &#125; 30% &#123; border-radius: 30%; transform: rotate(90deg); &#125; 40% &#123; border-radius: 40%; transform: rotate(180deg); &#125; 50% &#123; border-radius: 50%; &#125; 60% &#123; border-radius: 40%; transform: rotate(180deg); &#125; 70% &#123; border-radius: 30%; transform: rotate(90deg); &#125; 80% &#123; border-radius: 20%; transform: rotate(30deg); &#125; 90% &#123; border-radius: 10%; &#125; 100% &#123; border-radius: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 弹性盒子 --&gt; &lt;div class=&quot;flex&quot;&gt; &lt;!-- 绝对居中 --&gt; &lt;div class=&quot;box&quot;&gt; &lt;/div&gt; &lt;div class=&quot;turn&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116* &#123; padding: 0; margin: 0;&#125;body&#123; background: rgb(17, 75, 122); color: #fff;&#125;.box&#123; text-align: center;&#125;.title&#123; position: relative; top: -45px; animation-name: title; animation-delay: 1s; animation-duration: 3s; animation-timing-function: ease-in-out; animation-fill-mode: forwards;&#125;@keyframes title&#123; 0%&#123; top: -45px; &#125; 100%&#123; top: 200px; &#125;&#125;.content&#123; max-width: 960px; margin: auto; padding: 30px; position: relative; top: 200px; left: -100%; text-align: left; font-size: 14px; line-height: 2; text-indent: 24px; animation-name: content; animation-delay: 2s; animation-duration: 3s; animation-timing-function: linear; animation-fill-mode: forwards;&#125;@keyframes content&#123; 0% &#123; left: -100%; &#125; 100% &#123; left: 0; &#125;&#125;.btn&#123; position: relative; top: 220px; display: inline-block; font-size: 14px; text-indent: 0; line-height: 2; padding: 0.5rem 1rem; border: 1px solid #fff; text-decoration: none; color: #fff; opacity: 0; animation-name: btn; animation-delay: 5s; animation-duration: 2s; animation-timing-function: linear; animation-fill-mode: forwards; transition-property: transform; transition-duration: 2s; transition-timing-function: linear;&#125;.btn:hover&#123; transform: rotateY(180deg);&#125;@keyframes btn&#123; 0% &#123; opacity: 0; &#125; 100% &#123; opacity: 1; &#125;&#125;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/transitions.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;h1 id=&quot;title&quot; class=&quot;title&quot;&gt;Welcome to page&lt;/h1&gt; &lt;div id=&quot;content&quot; class=&quot;content&quot;&gt; 《哈姆雷特》（英语：Hamlet）又名《王子复仇记》，是莎士比亚于1599年至1602年间的一部悲剧作品，是他最负盛名和被人引用最多的剧本。习惯上将本剧与《麦克白》、《李尔王》和《奥赛罗》一起，并称为莎士比亚的“四大悲剧”。 戏剧中叔叔克劳迪谋害了哈姆雷特国王，篡了王位，并娶了国王的遗孀葛簇特；王子哈姆雷特因此为父王之死向叔叔复仇。剧本细致入微地刻画了伪装的、真实的疯癫 —— 从悲痛欲绝到假装愤怒 —— 探索了背叛、复仇、乱伦、堕落等主题。 &lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;btn&quot;&gt;Read More&lt;/a&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3 盒模型]]></title>
    <url>%2F2019%2F08%2F29%2FCSS3-%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[CSS盒模型所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。 CSS盒模型本质上是一个盒子，它包括：边距，边框，填充，和实际内容。 盒子模型(Box Model)： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;!-- Margin(外边距) - 清除边框外的区域，外边距是透明的。（margin的长度是允许出现负值的）注意：当以百分比来设置长度时，不管是宽度还是高度，都是按照父元素的宽度百分比计算的（即便是计算上下外边距也是按照父元素的宽度百分比计算的） --&gt; &lt;div class=&quot;margin&quot;&gt; &lt;!-- Border(边框) - 围绕在内边距和内容外的边框。 --&gt; &lt;div class=&quot;border&quot;&gt; &lt;!-- Padding(内边距) - 清除内容周围的区域，内边距是透明的。（padding的长度是不允许出现负值的）和margin一样，当以百分比来设置长度时，不管是宽度还是高度，都是按照父元素的宽度百分比计算的。 --&gt; &lt;div class=&quot;padding&quot;&gt; &lt;!-- Content(内容) - 盒子的内容，显示文本和图像。 --&gt; &lt;div class=&quot;content&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局圣杯布局和双飞翼布局达到的效果基本相同，都是侧边两栏宽度固定，中间栏宽度自适应。 主要的不同之处就是在解决中间部分被挡住的问题时，采取的解决办法不一样，圣杯布局是在父元素上设置了padding-left和padding-right，在给左右两边的内容设置position为relative，通过左移和右移来使得左右两边的内容得以很好的展现，而双飞翼则是在center这个div中再加了一个div来放置内容，在给这个新的div设置margin-left和margin-right 。 双飞翼布局要求 header和footer各自占领屏幕所有宽度，高度固定。 中间的container是一个三栏布局。 三栏布局两侧宽度固定不变，中间部分自动填充整个区域。 中间部分的高度是三栏中最高的区域的高度。 布局实现 left、center、right三种都设置左浮动 设置center宽度为100% 设置负边距，left设置负边距为100%，right设置负边距为自身宽度 设置content的margin值为左右两个侧栏留出空间，margin值大小为left和right宽度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;style&gt; body &#123; min-width: 550px; font-weight: bold; font-size: 20px; &#125; #header, #footer &#123; background: rgba(29, 27, 27, 0.726); text-align: center; height: 60px; line-height: 60px; &#125; #container &#123; overflow: hidden; &#125; .column &#123; text-align: center; height: 300px; line-height: 300px; &#125; #left, #right, #center &#123; float: left; &#125; #center &#123; width: 100%; background: rgb(206, 201, 201); &#125; #left &#123; width: 200px; margin-left: -100%; background: rgba(95, 179, 235, 0.972); &#125; #right &#123; width: 150px; margin-left: -150px; background: rgb(231, 105, 2); &#125; .content &#123; margin: 0 150px 0 200px; &#125;&lt;/style&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt;#header&lt;/div&gt; &lt;div id=&quot;container&quot;&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt; &lt;div class=&quot;content&quot;&gt;#center&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;#left&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;#right&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;#footer&lt;/div&gt;&lt;/body&gt; CSS3 弹性盒子模型(Flex Box Model)弹性盒子是 CSS3 的一种新的布局模式。 CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。 引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。 属性 描述 flex-direction 指定弹性容器中子元素排列方式 flex-wrap 设置弹性盒子的子元素超出父容器时是否换行 flex-flow flex-direction 和 flex-wrap 的简写 align-items 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式 align-content 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 justify-content 设置弹性盒子元素在主轴（横轴）方向上的对齐方式 flex-direction 属性： 决定项目的方向。注意：如果元素不是弹性盒对象的元素，则 flex-direction 属性不起作用。 row 默认值。元素将水平显示，正如一个行一样。 row-reverse 与 row 相同，但是以相反的顺序。 column 元素将垂直显示，正如一个列一样。 column-reverse 与 column 相同，但是以相反的顺序。 flex-wrap 属性： flex-wrap 属性规定flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。 nowrap 默认值。规定元素不拆行或不拆列。 wrap 规定元素在必要的时候拆行或拆列。 wrap-reverse 规定元素在必要的时候拆行或拆列，但是以相反的顺序。 flex-flow 属性： flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; display: flex; height: 100px; background-color: black; flex-direction: row; flex-wrap: wrap; align-items: center; justify-content: space-between; &#125; .item &#123; background-color: blanchedalmond; color: blueviolet; font-size: 14px; width: 40px; height: 40px; text-align: center; line-height: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;item&quot; style=&quot;order: 10&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex-grow: 0.3&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex-shrink: 8&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex-basis: 20px&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;flex:0.3 1 10px&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;align-self:flex-start&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;7&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; align-items属性： align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。 stretch 默认值。项目被拉伸以适应容器。 center 项目位于容器的中心。 flex-start 项目位于容器的开头。 flex-end 项目位于容器的结尾。 baseline 项目位于容器的基线上。 justify-content属性 justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。 flex-start 默认值。项目位于容器的开头。 flex-end 项目位于容器的结尾。 center 项目位于容器的中心。 space-between 项目位于各行之间留有空白的容器内。 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 弹性子元素属性 order 设置弹性盒子的子元素排列顺序。 flex-grow 设置或检索弹性盒子元素的扩展比率。 flex-shrink 指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。 flex-basis 用于设置或检索弹性盒伸缩基准值。 flex 设置弹性盒子的子元素如何分配空间。 align-self 在弹性子元素上使用。覆盖容器的 align-items 属性。 FCFC的全称是：Formatting Contexts，是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 BFC(Block Formatting Contexts)意为“块级格式化上下文”。就是页面上的一个渲染区域，容器内的子元素不会对外面的元素布局产生影响，反之亦然。 BFC的布局规则: 内部的盒子会在垂直方向，一个个地放置 盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的上下margin会发生重叠 每个元素的左边，与包含的盒子的左边相接触，即使存在浮动也是如此 BFC的区域不会与float重叠 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此 计算BFC的高度时，浮动元素也参与计算 如何生成BFC： 根元素或其它包含它的元素 float的值不为none overflow的值不为visible position的值不为relative和static display的值为table-cell,table-caption和inline-block中的任何一个 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 块格式化上下文对于定位与清除浮动很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 IFC(Inline Formatting Contexts)意为“内联格式化上下文”,IFC中，盒子依次水平放置，从包含块的顶部开始 FFC(Flex Formatting Contexts)意为“自适应格式化上下文”,display值为flex或者inline-flex的元素将会生成自适应容器。flex box由伸缩容器和伸缩子元素组成。通过设置元素display:flex/inline-flex可以得到伸缩容器，前者为块级元素，后者为行内元素。伸缩容器外元素不受影响。 GFC(GridLayout Formatting Contexts)意为“网格布局格式化上下文”当一个元素设置为display:grid的时候，此元素将获得一个独立的渲染区域，可以在网格容器上定义网格行和列，为每一个网格定义位置和空间。GFC和table的区别在于GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 基础]]></title>
    <url>%2F2019%2F08%2F28%2FCSS-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[CSS基础知识CSS 指层叠样式表 (Cascading Style Sheets)，是一种用来表现 HTML 文档样式的语言，样式定义如何显示 HTML 元素，是能够真正做到网页表现与结构分离的一种样式设计语言。 外部样式表可以极大提高工作效率 外部样式表通常存储在CSS文件中 多个样式定义可层叠为一 层叠次序 浏览器缺省设置 外部样式表 内部样式表(位于&lt;head&gt;标签内部) 内联样式表(在HTML元素内部) 选择器优先级 内联样式的权重为1000 ID选择器的权重为100 类选择器的权重为10 元素选择器的权重为1 权重计算永不进位 CSS语法CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器的分组，用都好将需要分组的选择器分开 集成及其问题，子元素从父元素继承属性有些浏览器不支持其继承，可以用组选择器 !important定义和用法提升指定样式规则的应用优先权。 div{color:#f00!important;color:#000;} comment定义和用法/* 这里是注释内容 */ @import定义和用法指定导入的外部样式表及目标媒体。 &lt;url&gt;：使用绝对或相对地址指定导入的外部样式表文件。可以是url(url)或者直接是一个url &lt;media_query_list&gt;：指定媒体类型和查询条件。 123@import url(example.css) screen and (min-width:800px);@import url(example.css) screen and (width:800px),(color);@import url(example.css) screen and (min-device-width:500px) and (max-device-width:1024px); @charset定义和用法在外部样式表文件内使用。指定该样式表使用的字符编码。 &lt;charset&gt;：字符编码。如：@charset “utf-8”; @media定义和用法指定样式表规则用于指定的媒体类型和查询条件 媒体类型 描述 all 所有浏览器-用于所有媒体设备类型 aural Opera-用于语音和音乐合成器 braille Opera-用于触觉反馈设备 handheld Chrome,Safari,Opera-用于小型或手持设备 print 所有浏览器-用于打印机 projection Opera-用于投影图像，如幻灯片 screen 所有浏览器-用于计算机显示器 tty Opera-用于使用固定间距字符格的设备。如电传打字机和终端 tv Opera-用于电视类设备 embossed Opera-用于凸点字符（盲文）印刷设备 123456789@media all and (width:1024px)&#123; body&#123;color:#f00;&#125;&#125;@media all and (device-height:800px)&#123; … &#125;@media all and (orientation:landscape)&#123; … &#125;@media all and (device-aspect-ratio:16/10)&#123; … &#125;@media all and (min-color:1)&#123; … &#125;@media all and (monochrome:0)&#123; … &#125;@media all and (grid:0)&#123; … &#125; @font-face定义和用法设置嵌入HTML文档的字体。 &lt;identifier&gt;：字体名称 &lt;url&gt;：此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径 &lt;string&gt;：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype, opentype，embedded-opentype, svg等 &lt;font&gt;：定义字体相关样式 12345678@font-face &#123; font-family: &apos;diyfont&apos;; src: url(&apos;diyfont.eot&apos;); /* IE9+ */ src: url(&apos;diyfont.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;diyfont.woff&apos;) format(&apos;woff&apos;), /* chrome、firefox */ url(&apos;diyfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/ url(&apos;diyfont.svg#fontname&apos;) format(&apos;svg&apos;); /* iOS 4.1- */&#125; @page定义和用法设置页面容器的版式，方向，边空等。 &lt;label&gt;：页面标识符 &lt;pseudo-class&gt;：打印伪类:first, :left, :right @page:first{margin:300px;} @keyframes定义和用法指定动画名称和动画效果。@keyframes定义的动画名称用来被animation-name所使用。定义动画时，简单的动画可以直接使用关键字from和to，即从一种状态过渡到另一种状态： 12345678@keyframes testanimations&#123; 0%&#123;transform:translate(0,0);&#125; 20%&#123;transform:translate(20,20);&#125; 40%&#123;transform:translate(40,0);&#125; 60%&#123;transform:translate(60,20);&#125; 80%&#123;transform:translate(80,0);&#125; 100%&#123;transform:translate(100,20);&#125;&#125; CSS 函数 名称 描述 counter() 插入计数器，counter()只能被使用在content属性上。li:before{counter-increment:item;content:counter(item)&quot;.&quot;;color:#f00;} attr() 插入元素的属性值。div{width:attr(width, px, auto);} calc() 用于动态计算长度值。任何长度值都可以使用calc()函数进行计算。calc()函数支持+, -, *, /, mod运算，以后还可能加入对min()/max()等运算。.test{width:-moz-calc(100% - 50px);width:calc(100% - 50px);background:#eee;} min() 用于比较数值的大小并取出最小的那个。div{width:min(10% + 20px, 300px);} max() 用于比较数值的大小并取出最大的那个。div{width:max(10% + 20px, 300px);} cycle() 允许子孙元素使用取值序列中的值循环替换继承而来的值。li &gt; ul{list-style-type:toggle(disk,circle,square,box);} Image 属性 描述 linear-gradient() 用线性渐变创建图像。 radial-gradient() 用径向渐变创建图像。 repeating-linear-gradient() 用重复的线性渐变创建图像。 repeating-radial-gradient() 用重复的径向渐变创建图像。 CSS单位CSS 的单位对于 CSS 的值有是一个直接影响的。因为 CSS 的单位直接对 CSS 的值的计算是有直接影响的，在 CSS 中单位的之间有一个关系如下所示： 单位 描述 角度单位&lt;angle&gt; deg：度grad：梯度rad：弧度turn：圈 字体单位&lt;length&gt; em：相对于父元素rem：相对于根元素ch：数字“0”的宽度ex：相对长度单位。相对于字符“x”的高度。通常为字体高度的一半。 频率单位&lt;frequency&gt; Hz：赫兹KHz：千赫兹 整数单位&lt;length&gt; px：相对长度单位，像素 长度单位&lt;length&gt; cm：厘米（Centimeters）。绝对长度单位。mm：毫米（Millimeters）。绝对长度单位。in：英寸（Inches）。绝对长度单位。pt：点（Points）。绝对长度单位。pc：派卡（Picas）。绝对长度单位。相当于我国新四号铅字的尺寸。px：相对长度单位。像素（Pixels）。 百分比单位 %：百分比 分辨率单位&lt;resolution&gt; dpi：每英寸包含点的数量（dots per inch）普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx），打印时一般会需要更大的dpi；dpcm：每厘米包含点的数量（dots per centimeter）dppx：每像素包含点的数量（dots per pixel） 时间单位&lt;time&gt; s:秒ms:毫秒 视窗单位&lt;length&gt; vw：相对于视口的宽度。视口被均分为100单位的vwvh：相对于视口的高度。视口被均分为100单位的vhvmax：相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmaxvmin：相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin 单位 描述 相对单位 字体相对单位：em、rem、ch、ex视窗相对单位：vw、vh、vmax、vmin 绝对单位 px、pt、pc、cm、mm、in 角度单位 deg、grad、rad、turn 时间单位 s、ms 分辨率单位 dpi、dpcm、dppx 频率单位 Hz、KHz 绝对单位不受任何屏幕大小或字体的影响。这些单位的显示可能会根据不同的屏幕分辨率而有所不同，因为它们取决于屏幕的DPI（每英寸上的点数）。绝对单位常用于一些物理测量上。在环境输出已知的情形下非常有用。 分辨率术语 术语 描述 720P 1280*720-称为：HD，中文译为“高清” 1080P 1920*1080-称为：FULL HD，中文称为“全高清” 1440P 2560*1440-称为：QHD或Quad HD,即4倍的HD 2160P 3840*2160-称为：4K 4320P 7680*4320-称为：8K 参考地址：https://www.w3cplus.com/css/css-values-and-units.html 颜色值 属性 描述 HEX 颜色值十六进制(HEX)表示,语法如：#rrggbb或#rgb RGB RGB表示方式，语法如：rgb(128,128,128) RGBA 颜色值RGBA表示方式，语法如：rgba(128,128,128,0.5) HSL 颜色值HSL表示方式，HSL(Hue-色调,Saturation-饱和度,Lightness-亮度) HSLA 颜色值HSLA表示方式，HSL(Hue-色调,Saturation-饱和度,Lightness-亮度,Alpha-透明度)语法如：hsla(360,50%,50%,0.5) Transparent 颜色值透明(Transparent)表示方式(RGBA) 元素选择符 选择符 描述 通配选择符* 选定所有对象。 类型选择符E 以文档语言对象类型作为选择符。 ID选择符E#ID 以唯一标识符id属性等于myid的E对象作为选择符。 类选择符E.Class 以class属性包含myclass的E对象作为选择符。 关系选择符 选择符 描述 包含选择符E F 选择所有被E元素包含的F元素。 子选择符E&gt;F 选择所有作为E元素的子元素F。 相邻选择符E+F 选择紧贴在E元素之后F元素。 兄弟选择符E~F 选择E元素后面的所有兄弟元素F。 属性选择符 选择符 描述 E[att] 选择具有att属性的E元素。 E[att=&quot;val&quot;] 选择具有att属性且属性值等于val的E元素。 E[att~=&quot;val&quot;] 选择具有att属性且属性值为一用空格分隔的字词列表，其中一个等于val的E元素。 E[att^=&quot;val&quot;] 选择具有att属性且属性值为以val开头的字符串的E元素。 E[att$=&quot;val&quot;] 选择具有att属性且属性值为以val结尾的字符串的E元素。 E[att*=&quot;val&quot;] 选择具有att属性且属性值为包含val的字符串的E元素。 ```E[att =”val”]``` 伪类选择符 选择符 描述 E:link 设置超链接a在未被访问前的样式。 E:visited 设置超链接a在其链接地址已被访问过时的样式。 E:hover 设置元素在其鼠标悬停时的样式。 E:active 设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 E:focus 设置元素在成为输入焦点（该元素的onfocus事件发生）时的样式。 E:lang(fr) 匹配使用特殊语言的E元素。 E:not(s) 匹配不含有s选择符的元素E。 E:root 匹配E元素在文档的根元素。 E:first-child 匹配父元素的第一个子元素E。 E:last-child 匹配父元素的最后一个子元素E。 E:only-child 匹配父元素仅有的一个子元素E。 E:nth-child(n) 匹配父元素的第n个子元素E。 E:nth-last-child(n) 匹配父元素的倒数第n个子元素E。 E:first-of-type 匹配同类型中的第一个同级兄弟元素E。 E:last-of-type 匹配同类型中的最后一个同级兄弟元素E。 E:only-of-type 匹配同类型中的唯一的一个同级兄弟元素E。 E:nth-of-type(n) 匹配同类型中的第n个同级兄弟元素E。 E:nth-last-of-type(n) 匹配同类型中的倒数第n个同级兄弟元素E。 E:empty 匹配没有任何子元素（包括text节点）的元素E。 E:checked 匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时) E:enabled 匹配用户界面上处于可用状态的元素E。 E:disabled 匹配用户界面上处于禁用状态的元素E。 E:target 匹配相关URL指向的E元素。 @page:first 设置页面容器第一页使用的样式。仅用于@page规则 @page:left 设置页面容器位于装订线左边的所有页面使用的样式。仅用于@page规则 @page:right 设置页面容器位于装订线右边的所有页面使用的样式。仅用于@page规则 伪对象选择符 选择符 描述 E:first-letter/:first-letter 设置对象内的第一个字符的样式。 E:first-line/:first-line 设置对象内的第一行的样式。 E:before/:before 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E:after/:after 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和content属性一起使用 E::placeholder 设置对象文字占位符的样式。 E::selection 设置对象被选择时的颜色。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5地理定位]]></title>
    <url>%2F2019%2F08%2F27%2FHTML5%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[位置定位地理位置（Geolocation）是 HTML5 的重要特性之一，提供了确定用户位置的功能，借助这个特性能够开发基于位置信息的应用。 检测浏览器是否支持123456if (navigator.geolocation) &#123;//console.log(&quot;浏览器支持!&quot;);&#125;else &#123;// console.log(&quot;浏览器不支持!&quot;);&#125; navigator.geolocation用于获取基于浏览器的当前用户地理位置123456789// 1、获取用户当前位置void getCurrentPosition(onSuccess,onError,options);// 2、持续获取当前用户位置int watchCurrentPosition(onSuccess,onError,options);// 3、watchId 为watchCurrentPosition返回的值void clearWatch(watchId);// 取消监控 示例代码PS：也可以调用百度地图、谷歌地图、高德地图等，只需要将HTML5 Geolocation API获取到的值传入到相应的地图接口中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;/&gt;&lt;meta name=&quot;format-detection&quot;content=&quot;telephone=no&quot;&gt;&lt;title&gt;基于浏览器的HTML5地理定位&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;style/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;div id=&quot;info&quot;&gt;&lt;/div&gt; &lt;script src=&quot;http://map.qq.com/api/js?v=2.exp&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script&gt; var clientWidth = document.documentElement.clientWidth, clientHeight = document.documentElement.clientHeight; var container = document.getElementById(&apos;container&apos;); container.style.width = clientWidth + &apos;px&apos;; container.style.height = clientHeight + &apos;px&apos;; function getLocation()&#123; var options=&#123; enableHighAccuracy:true, //boolean 是否要求高精度的地理信息，默认为false maximumAge:1000 //应用程序的缓存时间 &#125; if(navigator.geolocation)&#123; //浏览器支持geolocation navigator.geolocation.getCurrentPosition(onSuccess,onError,options); &#125;else&#123; //浏览器不支持geolocation console.log(&quot;浏览器不支持!&quot;); &#125; &#125; //成功时 function onSuccess(position)&#123; //返回用户位置 //经度 var longitude =position.coords.longitude; //纬度 var latitude = position.coords.latitude; //腾讯地图的中心地理坐标 var center = new qq.maps.LatLng(latitude, longitude); //使用腾讯地图API var map = new qq.maps.Map(document.getElementById(&quot;container&quot;), &#123; //地图的中心地理坐标 center: center, //初始化地图缩放级别 zoom: 16 &#125;); //在地图中创建信息提示窗口 var infoWin = new qq.maps.InfoWindow(&#123; map: map &#125;); //打开信息窗口 infoWin.open(); //设置信息窗口显示区的内容 infoWin.setContent(&apos;&lt;div style=&quot;width:200px;padding:10px;&quot;&gt;&apos;+ &apos;您在这里&lt;br/&gt;纬度：&apos;+ latitude+ &apos;&lt;br/&gt;经度：&apos;+longitude); //设置信息窗口的位置 infoWin.setPosition(center); &#125; //失败时 function onError(error)&#123; switch(error.code)&#123; case error.PERMISSION_DENIED: alert(&quot;用户拒绝对获取地理位置的请求&quot;); break; case error.POSITION_UNAVAILABLE: alert(&quot;位置信息是不可用的&quot;); break; case error.TIMEOUT: alert(&quot;请求用户地理位置超时&quot;); break; case error.UNKNOWN_ERROR: alert(&quot;未知错误&quot;); break; &#125; &#125; window.onload=getLocation; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 服务器发送事件]]></title>
    <url>%2F2019%2F08%2F27%2FHTML5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Server-Sent EventsServer-Sent Events(SSE)用于网页自动获取服务器上更新的数据，它是一个实时性的机制 实时性获取数据 Polling(轮询)：在客户端重复的向服务端发送新请求。如果服务器没有新的数据更动，关闭本次连接。然后客户端在稍等一段时间之后，再次发起新请求，一直重复这样的步骤。 Long-polling(长轮询)：在长轮询中，客户端发送一个请求到服务端。如果服务端没有新的数据更动，那么本次连接将会被保持，直到等待到更新后的数据，返回给客户端并关闭这个连接。 Server-Sent Events：SSE类似于长轮询的机制，但是它在每一次的连接中，不只等待一次数据的更动。客户端发送一个请求到服务端 ，服务端保持这个请求直到一个新的消息准备好，将消息返回至客户端，此时不关闭连接，仍然保持它，供其它消息使用。SSE的一大特色就是重复利用一个连接来处理每一个消息（又称event）。 WebSocker：WebSocket不同于以上的这些技术，因为它提供了一个真正意义上的双向连接。WebSocket是HTML5中非常强大的新特性，已经得到广泛应用。 Server-Sent Events实现在后台获取时间，不断发送给前台。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;获得服务器更新&lt;/h1&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;script&gt; if(typeof(EventSource)!==&quot;undefined&quot;)&#123; var source=new EventSource(&quot;/example/html5/demo_sse.php&quot;); source.onmessage=function(event)&#123; document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;; alert(&quot;提示有新的内容&quot;); this.location.reload(); &#125;; &#125; else &#123; document.getElementById(&quot;result&quot;).innerHTML=&quot;抱歉，您的浏览器不支持 server-sent 事件 ...&quot;; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 服务端代码12345678&lt;?php header(&apos;Content-Type: text/event-stream&apos;); header(&apos;Cache-Control: no-cache&apos;); $time = date(&apos;r&apos;); echo &quot;data: The server time is: &#123;$time&#125;\n\n&quot;; flush();?&gt; EventSource对象 属性 描述 onopen 当通信服务器连接被打开 onmessage 当接收到消息 onerror 当发生错误 其他自动刷新方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 1.页面自动刷新：把如下代码加入&lt;head&gt;区域中 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt;,其中20指每隔20秒刷新一次页面. // 2.页面自动跳转：把如下代码加入&lt;head&gt;区域中 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;20;url=http://www.jb51.net&quot;&gt;// 其中20指隔20秒后跳转到http://www.jb51.net页面 // 3.页面自动刷新js版 &lt;script language=&quot;javascript&quot;&gt; function myrefresh()&#123; window.location.reload(); &#125; setTimeout(&apos;myrefresh()&apos;,1000); //指定1秒刷新一次 &lt;/script&gt; // 4.websocker&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;websocket&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function WebSocketTest() &#123; if (&quot;WebSocket&quot; in window) &#123; alert(&quot;您的浏览器支持 WebSocket!&quot;); // 打开一个 web socket var ws = new WebSocket(&quot;ws://localhost:9998/echo&quot;); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(&quot;发送数据&quot;); alert(&quot;数据发送中...&quot;); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(&quot;数据已接收...&quot;); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(&quot;连接已关闭...&quot;); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(&quot;您的浏览器不支持 WebSocket!&quot;); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;sse&quot;&gt; &lt;a href=&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 Web Worker用法]]></title>
    <url>%2F2019%2F08%2F26%2FHTML5-Web-Worker%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Web Worker的用法简单来说，其实就是在Javascript单线程执行的基础上，开启一个子线程，进行程序处理，而不影响主线程的执行，当子线程执行完毕之后再回到主线程上，在这个过程中并不影响主线程的执行过程。 判断当前浏览器是否支持web worker1234567891011121314151617if (typeof (Worker) != &quot;undefined&quot;) &#123; //浏览器支持web worker if (typeof (w) == &quot;undefined&quot;) &#123; //w是未定义的,还没有开始计数 w = new Worker(&quot;webworker.js&quot;); //创建一个Worker对象,利用Worker的构造函数 &#125; //onmessage是Worker对象的properties w.onmessage = function (event) &#123; //事件处理函数,用来处理后端的web worker传递过来的消息 // do something &#125;;&#125; else &#123; // 浏览器不支持web worker // do something&#125; API 创建新的Worker var worker = new Worker(&quot;worker.js&quot;) 传递参数 worker.postMessage() 接收消息 worker.onMessage = function(msg){} 异常处理 worker.onerror = function(err){} 结束worker worker.terminate() 载入工具类函数 importScripts() 作用域创建一个新的worker时，该代码会运行在一个全新的javascript的环境中（WorkerGlobalScope）运行,是完全和创建worker的脚本隔离，这时我们可以把创建新worker的脚本叫做主线程，而被创建的新的worker叫做子线程。 WorkerGlobalScope是worker的全局对象，所以它包含所有核心javascript全局对象拥有的属性如JSON等，window的一些属性，也拥有类似于XMLHttpRequest()等。 但是我们所开启的新的worker也就是子线程，并不支持操作页面的DOM。 共享线程（SharedWorker）共享线程是为了避免线程的重复创建和销毁过程，降低了系统性能的消耗，共享线程SharedWorker可以同时有多个页面的线程链接。 var worker = new SharedWorker(&quot;sharedworker.js&quot;); 共享线程也使用了message事件监听线程消息，但使用SharedWorker对象的port属性与线程通信如下: worker.port.onmessage = function(msg){}; 同时我们也可以使用SharedWorker对象的port属性向共享线程发送消息如下： worker.port.postMessage(msg); 应用 可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信 可以在worker中通过importScripts(url)加载另外的脚本文件 可以使用 setTimeout(), clearTimeout(), setInterval(), and clearInterval() 可以使用XMLHttpRequest来发送请求 可以访问navigator的部分属性 注意事项 不能跨域加载JS worker内代码不能访问DOM 各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行 不是每个浏览器都支持这个新特性]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5本地存储]]></title>
    <url>%2F2019%2F08%2F26%2FHTML5%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[localStroage &amp; sessionStroageHTML5 提供了本地存储对象 window.localStroage - 存储没有截止日期的数据（localStorage 生命周期是永久，除非主动清除 localStorage 信息，否则这些信息将永远存在。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。） window.sessionStroage - 针对一个 Session 的数据存储（仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为 5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。） 两者区别就是一个作为临时保存，一个长期保存。 之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 localStroage123456789// 1、保存数据到本地// 第一个参数是保存的变量名，第二个是赋给变量的值localStorage.setItem(&apos;Author&apos;, &apos;local&apos;);// 2、从本地存储获取数据localStorage.getItem(&apos;Author&apos;);// 3、从本地存储删除某个已保存的数据localStorage.removeItem(&apos;Author&apos;);// 4、清除所有保存的数据localStorage.clear(); 应用场景实际工作中对 localstorage 的使用一般有以下需求： 缓存一般信息，如搜索页的出发城市，达到城市，非实时定位信息 缓存城市列表数据，这个数据往往比较大 每条缓存信息需要可追踪，比如服务器通知城市数据更新，这个时候在最近一次访问的时候要自动设置过期 每条信息具有过期日期状态，在过期外时间需要由服务器拉取数据 ………… sessionStroage123456789// 1、保存数据到本地// 第一个参数是保存的变量名，第二个是赋给变量的值sessionStorage.setItem(&apos;Author&apos;, &apos;session&apos;);// 2、从本地存储获取数据sessionStorage.getItem(&apos;Author&apos;);// 3、从本地存储删除某个已保存的数据sessionStorage.removeItem(&apos;Author&apos;);// 4、清除所有保存的数据sessionStorage.clear(); 其他隐私模式下可以采用 window.name 模拟 sessionStorage 的方式处理，因为 window.name 是可做保存的，这个也是其解决跨域方案的原因。 postMessage 发送：调用 postMessage 方法的 window 对象是指要接收消息的那一个 window 对象 otherWindow.postMessage(message, targetOrigin, [transfer]); 监听：message 事件 window.addEventListener( &quot;message&quot;, function(event) {alert(event.data);}) 假设在 a.html 里嵌套个&lt;iframe src=&quot;http://www.b.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;,在这两个页面里互相通信 a.com/a.html1234567window.onload = function() &#123; window.addEventListener(&quot;message&quot;, function(event) &#123; alert(event.data); &#125;); //window.frames[0].postMessage(&quot;b data&quot;, &quot;http://www.b.com/b.html&quot;); //调用postMessage方法的window对象是指要接收消息的那一个window对象&#125; b.com/b.html123456window.onload = function() &#123; //window.addEventListener(&quot;message&quot;, function(event) &#123; // alert(event.data); //&#125;); window.parent.postMessage(&quot;a需要的数据&quot;, &quot;http://www.a.com/a.html&quot;);&#125; postMessage是从a窗口发送信息到b窗口，b窗口监听到消息后做出回应； localStorage是在a窗口改变某一个存储值，b窗口监听到了存储值的变化，然后获取该值，进而完成通信的同样的效果。 HTML5 应用缓存在 Html5 中，提供了一种叫 Application Cache 应用程序缓存的技术，通俗解释就是，通过一个文本文件可以告诉浏览器，我这个网页中的资源，哪些本地有就直接用本地，哪些必须要去网络拉取。 其实就是离线资源使用，本地缓存，如果有缓存，就能提升页面访问速度，节省流量，也能减少服务端负载，进而节省带宽费用。 如何实现 HTML5 应用程序缓存？ 创建一个 cache.manifest 文件，并确保文件具有正确的内容 在服务器上设置内容类型 所有的 HTML 文件都指向 cache.manifest cache.manifest1234567891011121314151617CACHE MANIFEST# version1CACHE:index.html404.htmlfavicon.icorobots.txthumans.txtapple-touch-icon.pngcss/main.cssimg/pho-cat.jpgFALLBACK:online.js local.jsNETWORK:* 注意事项： 第一行必须是”CACHE DMANIFEST”文字，以把本文件的作用告知浏览器，即对本地缓存中的资源文件进行具体设置。 在 manifest 文件中，可以加上注释来进行一些必要说明或解释。注释行以”#”文字开头。 在 CACHE 之后的部分为列出我们需要缓存的文件。 在 FALLBACK 之后的部分每一行中指定两个资源文件，第一个资源文件为能够在线访问时使用的资源文件，第二个资源文件为不能在线访问时使用的备用资源文件。 在 NETWORK 之后可以指定在线白名单，即列出我们不希望离线存储的文件，因为通常它们的内容需要互联网访问才有意义。 另外，在此部分我们可以使用快捷方式：通配符* 这将告诉浏览器，应用服务器中获取没有在显示部分中提到的任何文件或 URL。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML基础]]></title>
    <url>%2F2019%2F08%2F25%2FHTML%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[HTML 基础 HTML 文档元信息 &lt;meta/&gt; 的重要性&lt;meta/&gt; 可分为两大部分：[ http-equiv ] 和 [ name ] 变量 [ http-equiv ]http-equiv相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助浏览器正确地显示网页内容。 值 描述 content-type 设定页面使用的字符集&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html; charset=&quot;utf-8&quot;&gt;UTF-8：世界通用的语言编码GB2312：编码是简体中文ISO-8859-1：编码是英文 X-UA-Compatible IE8的专用标记，用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式，以此来解决部分兼容问题&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot;&gt;以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8/9都会以IE7引擎来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot;&gt;以上代码告诉IE浏览器，IE8/9都会以IE8引擎来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge,chrome=1&quot;&gt;以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1则可以激活Chrome Frame expires 设定网页的过期时间&lt;meta http-equiv=&quot;expires&quot;content=&quot;Fri,12Jan200118:18:18GMT&quot;&gt;必须使用GMT的时间格式 refresh 自动刷新并指向新页面&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2;URL=https://www.baidu.com&quot;&gt; set-cookie 如果网页过期，那么自动删除本地cookie&lt;meta http-equiv=&quot;Set-Cookie&quot;content=&quot;cookie value=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt;必须使用GMT的时间格式 windows-target 强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;&gt; cache-control 缓存机制&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt;Public：指示响应可被任何缓存区缓存。Private：指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。no-cache：指示请求或响应消息不能缓存。no-store：用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。max-age：指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。min-fresh：指示客户机可以接收响应时间小于当前时间加上指定时间的响应。max-stale：指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 [ name ]name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 值 描述 author 标注网页的作者&lt;meta name=&quot;author&quot; content=&quot;value&quot; /&gt; keywords 页面关键词，用于被搜索引擎收录&lt;meta name=&quot;keywords&quot; content=&quot;value1,value2&quot;&gt; description 页面描述，用于搜索引擎收录&lt;meta name=&quot;description&quot; content=&quot;value&quot;&gt; viewport 用于控制页面缩放&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt; renderer 指定双核浏览器默认以何种方式渲染页面&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;webkit：默认webkit内核ie-comp：默认IE兼容模式ie-stand：默认IE标准模式 generator 说明网站的采用的什么软件制作&lt;meta name=&quot;generator&quot; content=&quot;Microsoft&quot;/&gt; revised 网页文档的修改时间&lt;meta name=&quot;revised&quot; content=&quot;WebName, MM/DD/YYYY&quot;/&gt; robots 用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引&lt;meta name=&quot;robots&quot; content=&quot;all&quot;/&gt;all：文件将被检索，且页面上的链接可以被查询none：文件将不被检索，且页面上的链接不可以被查询index：文件将被检索noindex：页面上的链接可以被查询follow：文件将不被检索，但页面上的链接可以被查询nofollow：文件将不被检索，页面上的链接可以被查询 copyright 网站版权信息&lt;meta name=&quot;copyright&quot; content=&quot;本页版权XXX所有。All Rights Reserved&quot; /&gt; HTML 块级元素 &amp; 内联元素 &amp; 置换元素 类型 描述 块级元素 div、header、nav、article、aside、section、footer、p、h1~h6、ul、ol… 块级元素特点： 独占一行 行高和边距可变 可以容纳块级元素和内联元素 display: block / table; 类型 描述 内联元素 span、img、label、input、button…. 内联元素特点： 与其他元素在同一行上 行高和边距不可变 只可容纳内联元素 display: inline / inline-block; 置换元素一个内容不受 CSS 视觉格式化模型控制，CSS 渲染模型并不考虑对此内容的渲染，且元素本身一般拥有固有尺寸（宽度，高度，宽高比）的元素，浏览器会根据置换元素的标签和属性，来决定元素的具体显示内容。 置换元素与一般行内元素的区别在于：置换元素拥有内在尺寸，可以设置宽高，其性质等同于设置了 display: inline-block; 的元素。 常见的有 &lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;等 HTML 语义化 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 标签 语义 &lt;article&gt; 定义文档内的文章 &lt;aside&gt; 定义页面内容之外的内容 &lt;details&gt; 定义用户可查看或隐藏的额外细节 &lt;figcaption&gt; 定义 &lt;figure&gt; 元素的标题 &lt;figure&gt; 定义自包含内容，比如图示、图表、照片、代码清单等等 &lt;footer&gt; 定义文档或节的页脚 &lt;header&gt; 定义文档或节的页眉 &lt;main&gt; 定义文档的主内容 &lt;mark&gt; 定义重要或强调的内容 &lt;nav&gt; 定义文档内的导航链接 &lt;section&gt; 定义文档中的节 &lt;summary&gt; 定义 &lt;details&gt;元素的可见标题 &lt;time&gt; 定义日期/时间 例如下面这段代码:12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--页眉--&gt; &lt;header&gt;&lt;/header&gt; &lt;!--导航--&gt; &lt;nav&gt;&lt;/nav&gt; &lt;!--主内容--&gt; &lt;main&gt; &lt;!--文章--&gt; &lt;article&gt; &lt;!--节--&gt; &lt;section&gt; &lt;!-- 表单 --&gt; &lt;form&gt; &lt;!-- 围绕表单的边框 --&gt; &lt;fieldset&gt; &lt;!-- fieldset 元素的标题 --&gt; &lt;legend&gt;Personalia:&lt;/legend&gt; &lt;!-- input标注 --&gt; &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; value=&quot;male&quot;&gt; &lt;!-- 重置按钮 --&gt; &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/fieldset&gt;&gt; &lt;/form&gt; &lt;/section&gt; &lt;/article&gt; &lt;!-- 页面内容之外的内容 --&gt; &lt;aside&gt;&lt;/aside&gt; &lt;/main&gt; &lt;!--页脚--&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; Canvas 图形绘制1234&lt;script&gt; var c = document.getElementById(&apos;myCanvas&apos;); var ctx = c.getContext(&apos;2d&apos;)&lt;/script&gt; 绘制基本图形 图形 方法 直线 moveTo(x,y) lineTo(x,y) 闭环 closePath() 矩形 rect(x,y,w,h) 曲线 二次贝塞尔曲线：context.quadraticCurveTo(cpx,cpy,x,y)三次方贝塞尔曲线：bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y) 圆形 arc(x,y,r,sAngle,eAngle,counterclockwise) 线性渐变 createLinearGradient(x0,y0,x1,y1) addColorStop(stop,color) 平移图形 translate(x,y) 缩放效果 scale(scalewidth,scaleheight) 旋转效果 rotate(angle) 颜色 &amp; 阴影 属性 描述 fillStyle 设置或返回用于填充绘画的颜色、渐变或模式 strokeStyle 设置或返回用于笔触的颜色、渐变或模式 shadowColor 设置或返回用于阴影的颜色 shadowBlur 设置或返回用于阴影的模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 图像的应用复制图像：drawImage(img,sx,sy,swidth,sheight,x,y,width,height)裁剪图像：clip()平铺图像：createPattern(image,”repeat|repeat-x|repeat-y|no-repeat”) 属性 描述 img 规定要使用的图像、画布或视频。 sx 可选。开始剪切的 x 坐标位置。 sy 可选。开始剪切的 y 坐标位置。 swidth 可选。被剪切图像的宽度。 sheight 可选。被剪切图像的高度。 x 在画布上放置图像的 x 坐标位置。 y 在画布上放置图像的 y 坐标位置。 width 可选。要使用的图像的宽度。（伸展或缩小图像） height 可选。要使用的图像的高度。（伸展或缩小图像） 文字的应用“被填充的”文本：fillText(text,x,y,maxWidth)绘制文本（无填充）：strokeText(text,x,y,maxWidth) HTML5 代码规范 请使用正确的文档类型&lt;!DOCTYPE html&gt; 使用小写元素名混合大小写名称并不好开发者习惯使用小写名（比如在 XHTML 中）小写更起来更纯净小写更易书写 关闭所有HTML元素 关闭空的HTML元素 使用小写属性名混合属性名并不好开发者习惯于使用小写属性名（比如在 XHTML 中）小写属性名看情况更纯净小写属性名更易书写 属性值加引号如果属性值包含值，则必须使用引号混合样式绝对不好加引号的值更易阅读 必要的属性请始终对图像使用 alt 属性。当图像无法显示时该属性很重要。 空格和等号，精简空格更易阅读。 避免长代码行(80个字符以内) 空格和缩进，请勿毫无理由地增加空行。 不能省略&lt;html&gt;&lt;/html&gt;和&lt;body&gt;&lt;/body&gt;、&lt;head&gt;&lt;/head&gt; 元数据，文档中对语言和字符编码的定义越早越好。 HTML注释短注释应该在单行中书写，并在 &lt;!-- 之后增加一个空格，在 &lt;!--之前增加一个空格 样式表开括号与选择器位于同一行在开括号之前用一个空格使用两个字符的缩进在每个属性与其值之间使用冒号加一个空格在每个逗号或分号之后使用空格在每个属性值对（包括最后一个）之后使用分号只在值包含空格时使用引号来包围值把闭括号放在新的一行，之前不用空格避免每行超过 80 个字符注释：在逗号或分号之后添加空格，是所有书写类型的通用规则。 在HTML中加载JavaScript 通过JavaScript访问HTML元素 使用小写文件名 文件扩展名.html]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
