<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随笔</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liushuai97.github.io/"/>
  <updated>2019-11-14T07:15:32.282Z</updated>
  <id>https://liushuai97.github.io/</id>
  
  <author>
    <name>前端菜鸟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>路由 Router</title>
    <link href="https://liushuai97.github.io/2019/11/14/%E8%B7%AF%E7%94%B1-Router/"/>
    <id>https://liushuai97.github.io/2019/11/14/路由-Router/</id>
    <published>2019-11-14T07:12:55.000Z</published>
    <updated>2019-11-14T07:15:32.282Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><h4 id="Router-原理"><a href="#Router-原理" class="headerlink" title="Router 原理"></a>Router 原理</h4><ul><li>路由历史</li><li>路由跳转</li><li>逻辑事件</li></ul><h4 id="常见Router"><a href="#常见Router" class="headerlink" title="常见Router"></a>常见Router</h4><ul><li>页面Router</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.href = &apos;http://www.baidu.com&apos;</span><br></pre></td></tr></table></figure><ul><li>Hash Router</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.location = &apos;#test&apos;</span><br><span class="line">window.hashchange = function () &#123;</span><br><span class="line">  console.log(&apos;current hash:&apos;, window.location.hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>H5路由</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">推进一个状态：history.pushState(&apos;name&apos;,&apos;title&apos;,&apos;#test&apos;)</span><br><span class="line">history.pushState(&apos;name&apos;,&apos;title&apos;,&apos;/usr/index&apos;)</span><br><span class="line">替换一个状态：history.replaceState(&apos;name&apos;,&apos;title&apos;,&apos;/index/test&apos;)</span><br><span class="line">window.onpopstate = function (e) &#123;</span><br><span class="line">  console.log(&apos;h5 router change&apos;,e.state);</span><br><span class="line">&#125;</span><br><span class="line">window.onpopstate = function () &#123;</span><br><span class="line">  console.log(window.location.href);</span><br><span class="line">  console.log(window.location.pathname);</span><br><span class="line">  console.log(window.location.hash);</span><br><span class="line">  console.log(window.location.search);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;Router-原理&quot;&gt;&lt;a href=&quot;#Router-原理&quot; class=&quot;headerlink&quot; title=&quot;Router 原理
      
    
    </summary>
    
    
      <category term="HTML" scheme="https://liushuai97.github.io/categories/HTML/"/>
    
    
      <category term="HTML" scheme="https://liushuai97.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>React语法</title>
    <link href="https://liushuai97.github.io/2019/11/13/React%E8%AF%AD%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/11/13/React语法/</id>
    <published>2019-11-13T09:01:24.000Z</published>
    <updated>2019-11-14T07:15:09.764Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">import &apos;./index.scss&apos;</span><br><span class="line"></span><br><span class="line">let style = &#123;&#125;;</span><br><span class="line">let name = &apos;Li&apos;;</span><br><span class="line">let names = [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;];</span><br><span class="line">let flag = false;</span><br><span class="line"></span><br><span class="line">let jsx = (&lt;div className=&quot;jsx&quot; style=&#123;style&#125;&gt;</span><br><span class="line">            &#123;/* 条件判断 */&#125;</span><br><span class="line">            &#123;</span><br><span class="line">              flag ? &lt;p&gt;i am &#123;name&#125;&lt;/p&gt; : &lt;p&gt;i am not &#123;name&#125;&lt;/p&gt;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;/* 变量使用 */&#125;</span><br><span class="line">            jsx...&#123;name&#125;</span><br><span class="line">            &#123;/* 数组循环 */&#125;</span><br><span class="line">            &#123;</span><br><span class="line">              names.map((name, index)=&gt; &lt;p key=&#123;index&#125;&gt;i am &#123;name&#125;&lt;/p&gt;)</span><br><span class="line">            &#125;</span><br><span class="line">          &lt;/div&gt;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(jsx,document.getElementById(&apos;app&apos;));</span><br></pre></td></tr></table></figure><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">// 基础组件</span><br><span class="line">function Componetns() &#123;</span><br><span class="line">  return &lt;h1&gt;i am li&lt;/h1&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6写法</span><br><span class="line">class ES6Compontnts extends React.Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;i am li&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Componetns/&gt;</span><br><span class="line">    &lt;ES6Compontnts/&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="state-amp-props用法"><a href="#state-amp-props用法" class="headerlink" title="state &amp; props用法"></a>state &amp; props用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">class ES6Compontnts extends React.Component&#123;</span><br><span class="line">  constructor (props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name: &apos;li&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        name: &apos;Reson test&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">    return &lt;h1&gt;i am &#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ES6Compontnts name=&quot;zhang&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">class Component extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name: &apos;zhang&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    // 为了在回调中使用 `this`，这个绑定是必不可少的</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.setState(state =&gt; (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">          &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125;</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Component/&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">// 生命周期</span><br><span class="line">// Initialization: 组件初始化  setup props and state</span><br><span class="line">// Mounting: 挂载阶段  componentWillMount render componentDidMount</span><br><span class="line">// Updating：运行阶段  </span><br><span class="line">// props &#123;</span><br><span class="line">//   componentWillReceiveProps </span><br><span class="line">//   shouldComponentUpdate </span><br><span class="line">//   componentWillUpdate </span><br><span class="line">//   render </span><br><span class="line">//   componentDidUpdate</span><br><span class="line">// &#125;</span><br><span class="line">// states&#123;</span><br><span class="line">//   shouldComponentUpdate</span><br><span class="line">//   componentWillUpdate</span><br><span class="line">//   render</span><br><span class="line">//   componentDidMount</span><br><span class="line">// &#125;</span><br><span class="line">// Unmounting：卸载阶段  componentWillUnmount</span><br><span class="line">// Error Handling: 错误处理</span><br><span class="line">class Component extends React.Component&#123;</span><br><span class="line">  // 构造函数</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      data: &apos;张三&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;初始化数据: constructor&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    console.log(&apos;渲染：render&apos;);</span><br><span class="line">    // return 只有一个根元素</span><br><span class="line">    return &lt;p&gt;</span><br><span class="line">              App: &#123;this.props.data&#125;</span><br><span class="line">              &lt;button onClick=&#123;()=&gt;&#123;this.handlClick()&#125;&#125;&gt;更新组件&#123;this.state.data&#125;&lt;/button&gt;</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  // 挂载时</span><br><span class="line">  // 在组件已经被渲染到 DOM 中后运行</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    console.log(&apos;挂载时: componentDidMount&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 处理点击事件</span><br><span class="line">  handlClick() &#123;</span><br><span class="line">    console.log(&apos;更新数据&apos;);</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      name: &apos;李四&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 将要接收父组件传来的props</span><br><span class="line">  componentWillReceiveProps()&#123;</span><br><span class="line">    console.log(&apos;将要接收父组件传来的props: componentWillReceiveProps&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 子组件是否应该更新</span><br><span class="line">  shouldComponentUpdate()&#123;</span><br><span class="line">    console.log(&apos;子组件是否应该更新: shouldComponentUpdate&apos;);</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  // 组件将要更新</span><br><span class="line">  componentWillUpdate()&#123;</span><br><span class="line">    console.log(&apos;组件将要更新: componentWillUpdate&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 组件更新完成</span><br><span class="line">  componentDidUpdate()&#123;</span><br><span class="line">    console.log(&apos;组件更新完成: componentDidUpdate&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 卸载时</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    console.log(&apos;卸载时: componentWillUnmount&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends React.Component&#123;</span><br><span class="line">  // 构造函数</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      data: &apos;old 张三&apos;,</span><br><span class="line">      hasChild: true</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;初始化数据: constructor&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  onPropsChange()&#123;</span><br><span class="line">    console.log(&apos;更新Props&apos;)</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      data: &apos;new 张三&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  onDel() &#123;</span><br><span class="line">    console.log(&apos;销毁子组件&apos;);</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      hasChild: false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          this.state.hasChild ? &lt;Component data=&#123;this.state.data&#125;/&gt; : null</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;&#123;this.onPropsChange()&#125;&#125;&gt;改变Props&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;&#123;this.onDel()&#125;&#125;&gt;销毁子组件&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App/&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;JSX语法&quot;&gt;&lt;a href=&quot;#JSX语法&quot; class=&quot;headerlink&quot; title=&quot;JSX语法&quot;&gt;&lt;/a&gt;JSX语法&lt;
      
    
    </summary>
    
    
      <category term="React" scheme="https://liushuai97.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://liushuai97.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>浏览器本地存储</title>
    <link href="https://liushuai97.github.io/2019/11/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>https://liushuai97.github.io/2019/11/13/浏览器本地存储/</id>
    <published>2019-11-13T02:00:23.000Z</published>
    <updated>2019-11-13T02:01:56.949Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 本地存储</span><br><span class="line">  // cookie</span><br><span class="line">  // 用户端保存请求信息的机制</span><br><span class="line">  // 分号分隔的多个key-value字段</span><br><span class="line">  // 存储在本地的加密文件里</span><br><span class="line">  // 域名和路径的限制</span><br><span class="line"></span><br><span class="line">  // name:cookie 名称</span><br><span class="line">  // domain:cookie 生效的域名</span><br><span class="line">  // path: cookie 生效的路径</span><br><span class="line">  // expires: cookie 过期时间</span><br><span class="line">  // HttpOnly: 用户端不可更改</span><br><span class="line"></span><br><span class="line">  // 浏览器端查看cookie</span><br><span class="line">  document.cookie</span><br><span class="line"></span><br><span class="line">  // cookie添加</span><br><span class="line">  document.cookie = &apos;name=Reson;domain=happymmall.com;path=/index.html;expires:Wed, 13 Nov 2020 01:44:49 GMT&apos;</span><br><span class="line"></span><br><span class="line">  // cookie修改</span><br><span class="line">  document.cookie = &apos;name=Reson1;domain=happymmall.com;path=/index.html&apos;</span><br><span class="line"></span><br><span class="line">  // cookie删除 设定过期时间</span><br><span class="line">  document.cookie = &apos;name=Reson1;domain=happymmall.com;path=/index.html;expires:Wed, 13 Nov 2008 01:44:49 GMT&apos;</span><br><span class="line"></span><br><span class="line">  // session</span><br><span class="line">  // 服务端保存请求信息的机制</span><br><span class="line">  // sessionld通常存放在cookie里</span><br><span class="line">  // 会话由浏览器控制，会话结束，session失效</span><br><span class="line"></span><br><span class="line">  // localStorage</span><br><span class="line">  // H5新特性</span><br><span class="line">  // 有域名限制，不存在作用域概念</span><br><span class="line">  // 只有key-value</span><br><span class="line">  // 没有过期时间</span><br><span class="line">  // 浏览器关闭后不消失</span><br><span class="line"></span><br><span class="line">  // 添加localStorage</span><br><span class="line">  window.localStorage.setItem(&apos;name&apos;,&apos;Rosen&apos;);</span><br><span class="line">  window.localStorage.setItem(&apos;name&apos;,JSON.stringify(&#123;name: &apos;Rosen&apos;&#125;));</span><br><span class="line"></span><br><span class="line">  // 查看localStorage</span><br><span class="line">  window.localStorage.getItem(&apos;name&apos;);</span><br><span class="line"></span><br><span class="line">  // 删除localStorage</span><br><span class="line">  window.localStorage.removeItem(&apos;name&apos;);</span><br><span class="line"></span><br><span class="line">  // sessionStorage</span><br><span class="line">  // 和localStorage极其相似</span><br><span class="line">  // 浏览器关闭后消失</span><br><span class="line">  </span><br><span class="line">  // 添加localStorage</span><br><span class="line">  window.sessionStorage.setItem(&apos;name&apos;,&apos;Rosen&apos;);</span><br><span class="line">  window.sessionStorage.setItem(&apos;name&apos;,JSON.stringify(&#123;name: &apos;Rosen&apos;&#125;));</span><br><span class="line"></span><br><span class="line">  // 查看localStorage</span><br><span class="line">  window.sessionStorage.getItem(&apos;name&apos;);</span><br><span class="line"></span><br><span class="line">  // 删除localStorage</span><br><span class="line">  window.sessionStorage.removeItem(&apos;name&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="HTML" scheme="https://liushuai97.github.io/categories/HTML/"/>
    
    
      <category term="HTML" scheme="https://liushuai97.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>ES6语法笔记</title>
    <link href="https://liushuai97.github.io/2019/11/13/ES6%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://liushuai97.github.io/2019/11/13/ES6语法笔记/</id>
    <published>2019-11-13T01:25:48.000Z</published>
    <updated>2019-11-13T01:26:18.851Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // let定义变量  const 定义常量</span><br><span class="line">  let a = 1;</span><br><span class="line">  a = 2</span><br><span class="line">  console.log(a);</span><br><span class="line"></span><br><span class="line">  const pi = 3.1415926;</span><br><span class="line">  // pi = 4;</span><br><span class="line">  console.log(pi);</span><br><span class="line">  // 不能重复定义</span><br><span class="line">  // let a = 3</span><br><span class="line">  // console.log(a);</span><br><span class="line"></span><br><span class="line">  // const pi = 10;</span><br><span class="line">  // console.log(19);</span><br><span class="line">  // 块级作用域</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    var b = 3</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(b);</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    let c = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  // console.log(c);</span><br><span class="line">  // 不存在变量提升</span><br><span class="line">  let arr = [1, 2, 3, 4, 5, 6, 7, 8];</span><br><span class="line">  for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  console.log(i);</span><br><span class="line"></span><br><span class="line">  for (let j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  // console.log(j);</span><br><span class="line">  // -------------------------------------</span><br><span class="line">  // 箭头函数</span><br><span class="line">  // 参数 =&gt; 表达式/语句</span><br><span class="line">  let value = 2;</span><br><span class="line">  let double = x =&gt; 2 * x;</span><br><span class="line">  let treble = x =&gt; &#123;</span><br><span class="line">    return 3 * x;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&apos;double&apos;, double(value));</span><br><span class="line">  console.log(&apos;treble&apos;, treble(value));</span><br><span class="line">  // 继承外层作用域</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    commFun: function () &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;,</span><br><span class="line">    arrowFun: () =&gt; &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.commFun();</span><br><span class="line">  obj.arrowFun();</span><br><span class="line">  // 不能用作构造函数</span><br><span class="line">  let Obj = function () &#123; &#125;</span><br><span class="line">  let obj = new Obj();</span><br><span class="line">  let Animal = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  let animal = new Animal();</span><br><span class="line">  // 没有prototype属性</span><br><span class="line">  let constFm = function () &#123; &#125;</span><br><span class="line">  let pontFm = () =&gt; &#123; &#125;</span><br><span class="line">  console.log(constFm.prototype);</span><br><span class="line">  console.log(pontFm.prototype);</span><br><span class="line">  // -------------------------------------</span><br><span class="line">  // 模板字符串</span><br><span class="line">  // 反引号标记`</span><br><span class="line">  let str = `</span><br><span class="line">    &lt;div class=&quot;title&quot;&gt;</span><br><span class="line">      &lt;h1&gt;测试标题一&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `;</span><br><span class="line">  // document.querySelector(&apos;body&apos;).innerHTML = str;</span><br><span class="line">  // 支持多行字符串</span><br><span class="line">  // 支持变量和表达式</span><br><span class="line">  let name = &apos;Rosen&apos;;</span><br><span class="line">  str += `$&#123;name&#125;`;</span><br><span class="line">  // document.querySelector(&apos;body&apos;).innerHTML = str;</span><br><span class="line"></span><br><span class="line">  let getName = () =&gt; &#123;</span><br><span class="line">    return &apos;Rosen title&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  str += `$&#123;getName()&#125;`;</span><br><span class="line">  // document.querySelector(&apos;body&apos;).innerHTML = str;</span><br><span class="line"></span><br><span class="line">  let names = [&apos;tim&apos;, &apos;dodo&apos;]</span><br><span class="line"></span><br><span class="line">  str += `</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      $&#123;names.map(name =&gt;</span><br><span class="line">    `&lt;li&gt;Hi, i am $&#123;name&#125;&lt;/li&gt;`</span><br><span class="line">  ).join(&apos; &apos;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  `</span><br><span class="line">  document.querySelector(&apos;body&apos;).innerHTML = str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Promise</span><br><span class="line">  // Promise对象 </span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步函数</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: &apos;http://happymmall.com/user/get_user_info.do&apos;,</span><br><span class="line">      type: &apos;post&apos;,</span><br><span class="line">      // 关键词：resolve,reject,then</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;,</span><br><span class="line">      error(err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">      console.log(&apos;success:&apos;, res);</span><br><span class="line">    &#125;,</span><br><span class="line">    (err) =&gt; &#123;</span><br><span class="line">      console.log(&apos;error:&apos;, err);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  // 链式Promise</span><br><span class="line">  let promiseFn1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步函数</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: &apos;http://happymmall.com/user/get_user_info.do&apos;,</span><br><span class="line">      type: &apos;post&apos;,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;,</span><br><span class="line">      error(err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  let promiseFn2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步函数</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: &apos;http://happymmall.com/user/get_cart_prodouct_count.do&apos;,</span><br><span class="line">      type: &apos;post&apos;,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;,</span><br><span class="line">      error(err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  promiseFn1.then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;promiseFn1 success&apos;)</span><br><span class="line">    return promiseFn2;</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;promiseFn2 success&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 面向对象-类</span><br><span class="line">  // 关键词：class</span><br><span class="line">  // 语法糖，对应function</span><br><span class="line">  // 构造函数：constructor</span><br><span class="line">  class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">      this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">      return this.name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let animal = new Animal(&apos;animal title&apos;);</span><br><span class="line">  console.log(animal.getName());</span><br><span class="line"></span><br><span class="line">  // 面向对象-类的继承</span><br><span class="line">  // extends：类的继承</span><br><span class="line">  // super：调用父类的构造函数 </span><br><span class="line">  class Animal2 &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      this.name = &apos;张三&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">      return this.name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Cart extends Animal2 &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      super();</span><br><span class="line">      this.name = &apos;cart&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let animal2 = new Animal2();</span><br><span class="line">  let cart = new Cart();</span><br><span class="line"></span><br><span class="line">  console.log(animal2.getName());</span><br><span class="line">  console.log(cart.getName());</span><br><span class="line"></span><br><span class="line">  // 面向对象-对象</span><br><span class="line">  // 对象里属性的简写</span><br><span class="line">  // 对象里方法的简写</span><br><span class="line">  // 属性名可以为表达式</span><br><span class="line">  // 其他扩展</span><br><span class="line">  var name = &quot;Reson&quot;,</span><br><span class="line">    age = 18;</span><br><span class="line"></span><br><span class="line">  // old</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">      return this.name</span><br><span class="line">    &#125;,</span><br><span class="line">    getAge: function () &#123;</span><br><span class="line">      return this.age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // news</span><br><span class="line">  let name1 = &quot;Reson&quot;,</span><br><span class="line">    age1 = 18;</span><br><span class="line"></span><br><span class="line">  let obj1 = &#123;</span><br><span class="line">    // 变量名可以用作对象属性名</span><br><span class="line">    name1,</span><br><span class="line">    age1,</span><br><span class="line">    // 对象方法可以简写</span><br><span class="line">    getName() &#123;</span><br><span class="line">      return this.name1</span><br><span class="line">    &#125;,</span><br><span class="line">    // 表达式作为属性方法名</span><br><span class="line">    [&apos;get&apos; + &apos;Age&apos;]() &#123;</span><br><span class="line">      return this.age1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Object对象的扩展</span><br><span class="line">  Object.keys(obj1);</span><br><span class="line">  Object.assign(&#123; a: 1 &#125;, &#123; a: 2, b: 2 &#125;)  // 浅拷贝</span><br><span class="line"></span><br><span class="line">  // ES6模块化</span><br><span class="line">  // 解决一个复杂问题时，自上而下逐层把系统划分成若干模块的过程</span><br><span class="line">  // CommonJS,AMD,CMD</span><br><span class="line">  // 关键词 export import</span><br><span class="line"></span><br><span class="line">  // 基本指令：let const</span><br><span class="line">  // 箭头函数：value =&gt; return value + 1</span><br><span class="line">  // 模板字符串： `Hell $&#123;name&#125;`</span><br><span class="line">  // promise: Promise, resolve, reject, then</span><br><span class="line">  // 面向对象： class, extends, super, constructor</span><br><span class="line">  // 模块化：export, import, as, default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题16</title>
    <link href="https://liushuai97.github.io/2019/11/01/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9816/"/>
    <id>https://liushuai97.github.io/2019/11/01/JavaScript-自测题16/</id>
    <published>2019-11-01T05:33:07.000Z</published>
    <updated>2019-11-06T06:37:19.415Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><h4 id="理解元编程"><a href="#理解元编程" class="headerlink" title="理解元编程"></a>理解元编程</h4><p>Symbol、Reflect 和 Proxy 是属于 ES6 元编程范畴的，能“介入”的对象底层操作进行的过程中，并加以影响。元编程中的 元 的概念可以理解为 程序 本身。</p><p>“元编程就是改变程序原本的运行方式”</p><p>Javascript 中，eval、new Function()便是两个可以用来进行元编程的特性。</p><h4 id="ES6-下的元编程：Symbol"><a href="#ES6-下的元编程：Symbol" class="headerlink" title="ES6 下的元编程：Symbol"></a>ES6 下的元编程：Symbol</h4><p>Symbols 是 ES6 一个全新的 API，它是实现了的反射（Reflection within implementation）—— 你将 Symbols 应用到你已有的类和对象上去改变它们的行为。</p><p>Symbols 是新的原始类型（primitive）。就像是 Number、String、和 Boolean 一样。Symbols 具有一个 Symbol 函数用于创建 Symbol。与别的原始类型不同，Symbols 没有字面量语法（例如，String 有 ”）—— 创建 Symbol 的唯一方式是使用类似构造函数而又非构造函数的 Symbol 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Symbol(); // symbol</span><br><span class="line">console.log(Symbol()); // 输出 &quot;Symbol()&quot; 至控制台</span><br><span class="line">assert(typeof Symbol() === &apos;symbol&apos;)</span><br><span class="line">// 类似构造函数而又非构造函数的 Symbol 函数</span><br><span class="line">new Symbol(); // TypeError: Symbol is not a constructor</span><br></pre></td></tr></table></figure><h4 id="Symbols-能被用作对象的-key"><a href="#Symbols-能被用作对象的-key" class="headerlink" title="Symbols 能被用作对象的 key"></a>Symbols 能被用作对象的 key</h4><p>Symbols 能用作对象的 key （类似字符串 key），这意味着你可以分配无限多的具有唯一性的 Symbols 到一个对象上，这些 key 保证不会和现有的字符串 key 冲突，或者和其他 Symbol key 冲突。</p><p>并且，继续划重点，Symbols key 无法通过 for in、for of 或者 Object.getOwnPropertyNames 获得 —— 获得它们的唯一方式是 Object.getOwnPropertySymbols。</p><p>这意味着 Symbols 能够给对象提供一个隐藏层，帮助对象实现了一种全新的目的 —— 属性不可迭代，也不能够通过现有的反射工具获得，并且能被保证不会和对象任何已有属性冲突。</p><p>但是，这里也有个例外：Symbol.for()</p><p>JavaScript 也有另一个创建 Symbol 的方式来轻易地实现 Symbol 的获得和重用：Symbol.for()。该方法在 “全局 Symbol 注册中心” 创建了一个 Symbol。额外注意的一点：这个注册中心也是跨域的，意味着 iframe 或者 service worker 中的 Symbol 会与当前 frame Symbol 相等</p><ol><li>Symbols 无法通过现有的反射工具读取。</li></ol><p>你需要一个新的方法 Object.getOwnPropertySymbols() 来访问对象上的 Symbols，这让 Symbol 适合存储那些你不想让别人直接获得的信息。</p><ol start="2"><li>Symbols 不是私有的。</li></ol><p>作为双刃剑的另一面 —— 对象上所有的 Symbols 都可以直接通过 Object.getOwnPropertySymbols() 获得 —— 这不利于我们使用 Symbol 存储一些真正需要私有化的值。</p><ol start="3"><li>Symbols 不总是唯一的。</li></ol><p>Symbol.for() 将为你返回一个不唯一的 Symbol。不要总认为 Symbol 具有唯一性，除非你自己能够保证它的唯一性。</p><h4 id="Symbol的作用"><a href="#Symbol的作用" class="headerlink" title="Symbol的作用"></a>Symbol的作用</h4><ol><li><p>作为一个可替换字符串或者整型使用的唯一值</p></li><li><p>作为一个对象中放置元信息（metadata）的场所（记住，Symbols 不是私有的）</p></li><li><p>给予开发者在 API 中为对象添加钩子（hook）的能力</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从 API 的 Symbols 常量中获得这个充满魔力的 Inspect Symbol</span><br><span class="line">var inspect = console.Symbols.INSPECT; // 这是一个 Symbols 对象</span><br><span class="line"></span><br><span class="line">var myVeryOwnObject = &#123;&#125;;</span><br><span class="line">console.log(myVeryOwnObject); // 日志 `&#123;&#125;`</span><br><span class="line"></span><br><span class="line">myVeryOwnObject[inspect] = function () &#123; return &apos;DUUUDE&apos;; &#125;;</span><br><span class="line">console.log(myVeryOwnObject); // 日志输出 `DUUUDE`</span><br></pre></td></tr></table></figure><p>钩子实现大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log = function (…items) &#123;</span><br><span class="line">  var output = &apos;&apos;;</span><br><span class="line">  for(const item of items) &#123;</span><br><span class="line">    if (typeof item[console.Symbols.INSPECT] === &apos;function&apos;) &#123;</span><br><span class="line">        output += item[console.Symbols.INSPECT](item);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        output += console.inspect[typeof item](item);</span><br><span class="line">    &#125;</span><br><span class="line">    output += &apos;  &apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  process.stdout.write(output + &apos;\n&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PS：钩子是什么？</li></ul><p>提供一个可以影响默认的(或原有的)流程(机制)的时机</p><p>通常就是：一个库、一个框架、一个系统或一种语言，提供一个对外公开的接口，通过这个接口，用户能够影响库、框架、系统或程序的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const arr = [4, 5, 6, 7, 8, 9];</span><br><span class="line">//定义一个尽在奇数索引地方生产值</span><br><span class="line">arr[Symbol.iterator] = function* () &#123;</span><br><span class="line">    let idx = 1;</span><br><span class="line">    console.table(this);</span><br><span class="line">    do &#123;</span><br><span class="line">        yield this[idx];</span><br><span class="line">    &#125; while ((idx += 2) &lt; this.length)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (const v of arr) &#123;</span><br><span class="line">    console.log(&apos;v&apos;, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    age: 27</span><br><span class="line">&#125;;</span><br><span class="line">const validator = &#123;</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">        console.log(target);</span><br><span class="line">        if (typeof value !== &quot;number&quot; || Number.isNaN(value)) &#123;</span><br><span class="line">            throw new TypeError(&quot;年龄必须是一个数字&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(person, validator);</span><br><span class="line">proxy.age = &quot;🇨🇳&quot;;</span><br><span class="line">console.log(123);</span><br></pre></td></tr></table></figure><h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>为操作对象而提供的新API</p><ul><li><p>将Object对象的属于语言内部的方法放到Reflect对象上，即从Reflect对象上拿Object对象内部方法。</p></li><li><p>将用 老Object方法 报错的情况，改为返回false</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Tree() &#123;</span><br><span class="line">    return new Proxy(&#123;&#125;, handler);</span><br><span class="line">&#125;</span><br><span class="line">const handler = &#123;</span><br><span class="line">    get(target, key, receiver) &#123;</span><br><span class="line">        if (!(key in target)) &#123;</span><br><span class="line">            //自动创建一个树</span><br><span class="line">            target[key] = Tree();</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.get(target, key, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tree = Tree();</span><br><span class="line">tree.yideng.student.a = &quot;小牛🐂&quot;;</span><br><span class="line">console.log(tree);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;理解元编程&quot;&gt;&lt;a href=&quot;#理解元编程&quot; class=&quot;headerlink&quot; title=&quot;理解元编程&quot;&gt;&lt;/a&gt;理解元编程&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题15</title>
    <link href="https://liushuai97.github.io/2019/11/01/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9815/"/>
    <id>https://liushuai97.github.io/2019/11/01/JavaScript-自测题15/</id>
    <published>2019-11-01T02:41:39.000Z</published>
    <updated>2019-11-01T03:00:51.043Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  const b = 2;</span><br><span class="line">  function test()&#123;&#125;</span><br><span class="line">  test = 3;</span><br><span class="line">  console.log(typeof test);   // number</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(typeof test);  // function</span><br><span class="line">console.log(b); // b is not defined</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number</span><br><span class="line">1</span><br><span class="line">function</span><br><span class="line">Uncaught ReferenceError: b is not defined</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>test = 3 console.log(type test)为：number</li><li>var a 不存在块级作用域限制，所以 console.log(a)为：1</li><li>test() 函数声明被提升，所以外部console.log(typeof test)为：function</li><li>const b 存在块级作用域限制，所以 b is not defined</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题14</title>
    <link href="https://liushuai97.github.io/2019/11/01/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9814/"/>
    <id>https://liushuai97.github.io/2019/11/01/JavaScript-自测题14/</id>
    <published>2019-11-01T01:30:56.000Z</published>
    <updated>2019-11-01T02:42:34.668Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Object.prototype.a = &apos;a&apos;;</span><br><span class="line">  Function.prototype.a = &apos;a1&apos;;</span><br><span class="line">  function Person()&#123;&#125;;</span><br><span class="line">  var yideng = new Person();</span><br><span class="line">  console.log(Person.a);</span><br><span class="line">  console.log(yideng.a);</span><br><span class="line">  console.log(1..a);</span><br><span class="line">  console.log(1.a);</span><br><span class="line">  console.log(yideng.__proto__.__proto__.constructor.constructor.constructor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a1</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">Uncaught SyntaxError: Invalid or unexpected token  数据格式错误</span><br><span class="line">ƒ Function() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>Person.a 是function Person()函数，所以结果为：a1</li><li>yideng 是 new Person()对象，所以结果为：a</li><li>1..a 是Number(1).a，也是对象，所以结果为：a，特殊转换 +1 1.</li><li>1.a 报错</li><li><code>yideng.__proto__.__proto__.constructor</code> 是Persoon()对象的<strong>proto</strong>下的constructor 内置函数，结果为：ƒ Function() { [native code] }</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题13</title>
    <link href="https://liushuai97.github.io/2019/10/31/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9813/"/>
    <id>https://liushuai97.github.io/2019/10/31/JavaScript-自测题13/</id>
    <published>2019-10-31T08:14:26.000Z</published>
    <updated>2019-11-01T02:42:27.993Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  function test()&#123;</span><br><span class="line">    var a = &quot;yideng&quot;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">      eval(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  test()();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>没有被GC回收</p><p>解析：</p><p>eval(“”)改变了词法作用域，影响了执行上下文，导致a无法回收，但是又没有引用，所以形成野指针</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题12</title>
    <link href="https://liushuai97.github.io/2019/10/31/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9812/"/>
    <id>https://liushuai97.github.io/2019/10/31/JavaScript-自测题12/</id>
    <published>2019-10-31T07:36:38.000Z</published>
    <updated>2019-10-31T08:27:21.789Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  function fn()&#123;</span><br><span class="line">    console.log(this.length); </span><br><span class="line">  &#125;</span><br><span class="line">  var yideng = &#123; </span><br><span class="line">    length: 5,</span><br><span class="line">    method: function()&#123;</span><br><span class="line">      &quot;use strict&quot;;</span><br><span class="line">      fn();</span><br><span class="line">      arguments[0]();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const result = yideng.method.bind(null); </span><br><span class="line">  result(fn,1,3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>fn() this指向window this.length指向iframe为1</li><li>arguments[0] 调用fn()，此时this指向arguments，this.length就是3</li></ol><p>附加题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> function yideng(a,b,c)&#123;</span><br><span class="line">  console.log(this.length);</span><br><span class="line">  console.log(this.callee.length);</span><br><span class="line"> &#125;</span><br><span class="line"> function fn(d)&#123;</span><br><span class="line">   arguments[0](10,20,30,40,50);</span><br><span class="line"> &#125;</span><br><span class="line"> fn(yideng,10,20,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>fn(yideng,10,20,30) 调用yideng() this指向arguments this.length为4</li><li>this.callee.length指向fn(d)为1</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题11</title>
    <link href="https://liushuai97.github.io/2019/10/31/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9811/"/>
    <id>https://liushuai97.github.io/2019/10/31/JavaScript-自测题11/</id>
    <published>2019-10-31T07:19:02.000Z</published>
    <updated>2019-10-31T07:35:20.011Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  console.log(typeof yideng(a));</span><br><span class="line">  var flag = true;</span><br><span class="line">  if(!flag)&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if(flag)&#123;</span><br><span class="line">    function yideng(a)&#123;</span><br><span class="line">      yideng = a;</span><br><span class="line">      console.log(&apos;yideng1&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(typeof yideng(a));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    function yideng(a) &#123;</span><br><span class="line">      yideng = a;</span><br><span class="line">      console.log(&apos;yideng2&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br><span class="line">yideng is not a function</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>a声明未赋值</li><li>yideng()被限制在块级作用域内，无法检测类型</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程概念</title>
    <link href="https://liushuai97.github.io/2019/10/25/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>https://liushuai97.github.io/2019/10/25/函数式编程概念/</id>
    <published>2019-10-25T05:14:09.000Z</published>
    <updated>2019-10-31T01:51:26.531Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:07 GMT+0800 (GMT+08:00) --><h4 id="函数式编程特性"><a href="#函数式编程特性" class="headerlink" title="函数式编程特性"></a>函数式编程特性</h4><ul><li>与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。</li><li>最主要的特征是，函数是第一等公民。</li><li>强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。</li><li>只有纯的、没有副作用的函数，才是合格的函数。</li></ul><h4 id="范畴论"><a href="#范畴论" class="headerlink" title="范畴论"></a>范畴论</h4><p>函数式编程的起源，是一门叫做范畴论（Category Theory）的数学分支。</p><p>“范畴就是使用箭头连接的物体。”</p><p><img src="category.jpg" alt="kyrie irving"></p><p>箭头表示范畴成员之间的关系，正式的名称叫做”态射”（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的”变形”（transformation）。通过”态射”，一个成员可以变形成另一个成员。</p><ul><li>数学模型</li></ul><ol><li>所有成员是一个集合</li><li>变形关系是函数</li></ol><ul><li>范畴与容器</li></ul><ol><li>值（value）</li><li>值的变形关系，也就是函数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor (val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">  addOne (a) &#123;</span><br><span class="line">    return a = a + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><p>对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态的函数，叫做纯函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var xs = [1,2,3,4,5];// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的</span><br><span class="line">xs.slice(0,3);</span><br><span class="line">xs.slice(0,3);</span><br><span class="line">xs.splice(0,3);// Array.splice会对原array造成影响，所以不纯</span><br><span class="line">xs.splice(0,3);</span><br></pre></td></tr></table></figure><h4 id="函数式编程基本的运算"><a href="#函数式编程基本的运算" class="headerlink" title="函数式编程基本的运算"></a>函数式编程基本的运算</h4><p>函数式编程主旨在于将复杂的函数符合成简单的函数（计算理论，或者递归论，或者拉姆达演算）。运算过程尽量写成一系列嵌套的函数调用，函数式编程有两个最基本的运算：合成和柯里化。</p><ul><li>函数的合成</li></ul><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const compose = (f,g) =&gt; &#123;</span><br><span class="line">  return (x) =&gt; &#123;</span><br><span class="line">    return f(g(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>柯里化</li></ul><p>所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 柯里化之前</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2) // 3</span><br><span class="line">// 柯里化之后</span><br><span class="line">function addX(y) &#123;</span><br><span class="line">    return function (x) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">addX(2)(1) // 3</span><br></pre></td></tr></table></figure><p>事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const compose = (f, g) =&gt; (x =&gt; f(g(x)));</span><br><span class="line">var first = arr =&gt; arr[0];</span><br><span class="line">var reverse = arr =&gt; arr.reverse();</span><br><span class="line">var last = compose(first, reverse);</span><br><span class="line">last([1, 2, 3, 4, 5]); // 5</span><br></pre></td></tr></table></figure><ul><li>Point Free</li></ul><p>把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const compose = (f, g) =&gt; (x =&gt; f(g(x)));</span><br><span class="line">  const f = str =&gt; str.toUpperCase().split(&apos; &apos;);</span><br><span class="line"></span><br><span class="line">  var toUpperCase = word =&gt; word.toUpperCase();</span><br><span class="line">  var split = x =&gt; (str =&gt; str.split(x));</span><br><span class="line">  var f = compose(split(&apos; &apos;), toUpperCase);</span><br><span class="line">  console.log(f(&quot;abcd efgh&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明式与命令式代码</li></ul><p>函数式编程的一个明显的好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//命令式</span><br><span class="line">let CEOs = [];</span><br><span class="line">for (var i = 0; i &lt; companies.length; i++) &#123;</span><br><span class="line">    CEOs.push(companies[i].CEO)</span><br><span class="line">&#125;</span><br><span class="line">//声明式</span><br><span class="line">let CEOs = companies.map(c =&gt; c.CEO);</span><br></pre></td></tr></table></figure><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul><li>高阶函数</li></ul><p>高阶函数，就是把函数当参数，把传入的函数做一个封装，然后返回这个封装函数,达到更高程度的抽象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//命令式</span><br><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function math(func, array) &#123;</span><br><span class="line">    return func(array[0], array[1]);</span><br><span class="line">&#125;</span><br><span class="line">math(add, [1, 2]); // 3</span><br></pre></td></tr></table></figure><ul><li>递归与尾递归</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不是尾递归，无法优化</span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">    if (n === 1) return 1;</span><br><span class="line">    return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function factorial(n, total) &#123;</span><br><span class="line">    if (n === 1) return total;</span><br><span class="line">    return factorial(n - 1, n * total);</span><br><span class="line">&#125; //ES6强制使用尾递归</span><br></pre></td></tr></table></figure><h4 id="函子"><a href="#函子" class="headerlink" title="函子"></a>函子</h4><p>函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。</p><p>它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。</p><ul><li>函子的代码实现</li></ul><p>任何具有map方法的数据结构，都可以当作函子的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Functor &#123;</span><br><span class="line">  constructor(val) &#123; </span><br><span class="line">    this.val = val; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(f) &#123;</span><br><span class="line">    return new Functor(f(this.val));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(new Functor(2)).map(function (two) &#123;</span><br><span class="line">  return two + 2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="of方法"><a href="#of方法" class="headerlink" title="of方法"></a>of方法</h4><p>函数式编程一般约定，函子有一个of方法，用来生成新得容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Functor &#123;</span><br><span class="line">  constructor(val) &#123; </span><br><span class="line">    this.val = val; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(f) &#123;</span><br><span class="line">    return new Functor(f(this.val));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Functor.of = function(val) &#123;</span><br><span class="line">  return new Functor(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Functor.of(2).map(function (two) &#123;</span><br><span class="line">  return two + 2;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="maybe函子"><a href="#maybe函子" class="headerlink" title="maybe函子"></a>maybe函子</h4><p>函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。</p><p>Maybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Functor &#123;</span><br><span class="line">  constructor(val) &#123; </span><br><span class="line">    this.val = val; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(f) &#123;</span><br><span class="line">    return new Functor(f(this.val));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Maybe extends Functor &#123;</span><br><span class="line">  map(f) &#123;</span><br><span class="line">    return this.val ? Maybe.of(f(this.val)) : Maybe.of(null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maybe.of(null).map(function (s) &#123;</span><br><span class="line">  return s.toUpperCase();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Either-函子"><a href="#Either-函子" class="headerlink" title="Either 函子"></a>Either 函子</h4><p>条件运算if…else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。</p><p>Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Either extends Functor &#123;</span><br><span class="line">  constructor(left, right) &#123;</span><br><span class="line">    this.left = left;</span><br><span class="line">    this.right = right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(f) &#123;</span><br><span class="line">    return this.right ? </span><br><span class="line">      Either.of(this.left, f(this.right)) :</span><br><span class="line">      Either.of(f(this.left), this.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Either.of = function (left, right) &#123;</span><br><span class="line">  return new Either(left, right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var addOne = function (x) &#123;</span><br><span class="line">  return x + 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Either.of(5, 6).map(addOne);</span><br><span class="line">// Either(5, 7);</span><br></pre></td></tr></table></figure><h4 id="ap-函子"><a href="#ap-函子" class="headerlink" title="ap 函子"></a>ap 函子</h4><p>ap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。ap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  class Functor &#123;</span><br><span class="line">    constructor(val) &#123; </span><br><span class="line">      this.val = val; </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    map(f) &#123;</span><br><span class="line">      return new Functor(f(this.val));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // Maybe空值检测</span><br><span class="line">  class Maybe extends Functor &#123;</span><br><span class="line">    map(f) &#123;</span><br><span class="line">      return this.val ? Maybe.of(f(this.val)) : Maybe.of(null);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Ap extends Functor &#123;</span><br><span class="line">    ap(F) &#123;</span><br><span class="line">      return Ap.of(this.val(F.val));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Ap.of = function(F)&#123;</span><br><span class="line">    return new Ap(F);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Maybe.of = function(f)&#123;</span><br><span class="line">    return new Maybe(f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 柯里化</span><br><span class="line">  function add(x) &#123;</span><br><span class="line">    return function (y) &#123;</span><br><span class="line">      return x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(Ap.of(add(2)).ap(Maybe.of(3)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IO函子"><a href="#IO函子" class="headerlink" title="IO函子"></a>IO函子</h4><p>真正的程序总要去接触肮脏的世界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function readLocalStorage()&#123;</span><br><span class="line">  return window.localStorage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IO 跟前面那几个 Functor 不同的地方在于，它的 __value 是一个函数。它把不纯的操作（比如 IO、网络请求、DOM）包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，IO 包含的是被包裹的操作的返回值。</p><p>IO其实也算是惰性求值。</p><p>IO负责了调用链积累了很多很多不纯的操作，带来的复杂性和不可维护性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Monad extends Functor &#123;</span><br><span class="line">    join() &#123;</span><br><span class="line">        return this.val;</span><br><span class="line">    &#125;</span><br><span class="line">    flatMap(f) &#123;</span><br><span class="line">        return this.map(f).join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class IO extends Monad &#123;</span><br><span class="line">    map(f) &#123;</span><br><span class="line">        return IO.of(compose(f, this.__value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>易调试、热部署、并发</li></ul><ol><li><p>函数式编程中的每个符号都是 const 的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。</p></li><li><p>函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。</p></li><li><p>函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。</p></li></ol><ul><li>单元测试</li></ul><ol><li><p>严格函数式编程的每一个符号都是对直接量或者表达式结果的引用，没有函数产生副作用。因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其他函数使用（如类成员或全局变量）。这意味着函数求值的结果只是其返回值，而惟一影响其返回值的就是函数的参数。</p></li><li><p>这是单元测试者的梦中仙境(wet dream)。对被测试程序中的每个函数，你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。而命令式编程就不能这样乐观了，在 Java 或 C++ 中只检查函数的返回值还不够——我们还必须验证这个函数可能修改了的外部状态。</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:07 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;函数式编程特性&quot;&gt;&lt;a href=&quot;#函数式编程特性&quot; class=&quot;headerlink&quot; title=&quot;函数式编程特性&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="函数式编程" scheme="https://liushuai97.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="函数式编程" scheme="https://liushuai97.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ES6 对象代理</title>
    <link href="https://liushuai97.github.io/2019/10/21/ES6-%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%90%86/"/>
    <id>https://liushuai97.github.io/2019/10/21/ES6-对象代理/</id>
    <published>2019-10-21T07:40:03.000Z</published>
    <updated>2019-10-21T07:56:26.387Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ES3 数据保护</span><br><span class="line">  var Person = function() &#123;</span><br><span class="line">    var data = &#123;</span><br><span class="line">      name: &apos;es3&apos;,</span><br><span class="line">      sex: &apos;male&apos;,</span><br><span class="line">      age: 15</span><br><span class="line">    &#125;</span><br><span class="line">    this.get = function(key) &#123;</span><br><span class="line">      return data[key]</span><br><span class="line">    &#125;</span><br><span class="line">    this.set = function(key, value) &#123;</span><br><span class="line">      if (key !== &apos;sex&apos;) &#123;</span><br><span class="line">        data[key] = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 声明一个实例</span><br><span class="line">  var person = new Person();</span><br><span class="line">  // 读取</span><br><span class="line">  console.table(&#123;name: person.get(&apos;name&apos;), sex: person.get(&apos;sex&apos;), age: person.get(&apos;age&apos;)&#125;);</span><br><span class="line">  // 修改</span><br><span class="line">  person.set(&apos;name&apos;, &apos;es3-cname&apos;);</span><br><span class="line">  console.table(&#123;name: person.get(&apos;name&apos;), sex: person.get(&apos;sex&apos;), age: person.get(&apos;age&apos;)&#125;);</span><br><span class="line">  person.set(&apos;sex&apos;, &apos;female&apos;);</span><br><span class="line">  console.table(&#123;name: person.get(&apos;name&apos;), sex: person.get(&apos;sex&apos;), age: person.get(&apos;age&apos;)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  // ES5 数据保护</span><br><span class="line">  var Person = &#123;</span><br><span class="line">    name: &apos;es5&apos;,</span><br><span class="line">    age: 15</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Person, &apos;sex&apos;, &#123;</span><br><span class="line">    writable: false,</span><br><span class="line">    value: &apos;male&apos;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  console.table(&#123;name: Person.name, age: Person.age, sex: Person.sex&#125;);</span><br><span class="line">  Person.name = &apos;es5-cname&apos;;</span><br><span class="line">  console.table(&#123;name: Person.name, age: Person.age, sex: Person.sex&#125;);</span><br><span class="line">  try &#123;</span><br><span class="line">    Person.sex = &apos;female&apos;;</span><br><span class="line">    console.table(&#123;name: Person.name, age: Person.age, sex: Person.sex&#125;);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ES6</span><br><span class="line">  let Person = &#123;</span><br><span class="line">    name: &apos;es6&apos;,</span><br><span class="line">    sex: &apos;male&apos;,</span><br><span class="line">    age: 15</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  let persoon = new Proxy(Person, &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">      return target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    set (target, key) &#123;</span><br><span class="line">      if(key !== &apos;sex&apos;)&#123;</span><br><span class="line">        target[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  console.table(&#123;</span><br><span class="line">    name: persoon.name,</span><br><span class="line">    sex: person.sex,</span><br><span class="line">    age: person.age</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  try&#123;</span><br><span class="line">    person.sex=&apos;female&apos;;</span><br><span class="line">  &#125;catch(e)&#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 默认参数</title>
    <link href="https://liushuai97.github.io/2019/10/18/ES6-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    <id>https://liushuai97.github.io/2019/10/18/ES6-默认参数/</id>
    <published>2019-10-18T00:21:37.000Z</published>
    <updated>2019-10-18T03:03:23.818Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><p>函数默认参数，在ES6中，可以为函数的采纳数指定默认值。函数默认参数允许在没有值或undefined被传入时使用默认形参。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x,y = &quot;world&quot;)&#123;</span><br><span class="line">  console.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello world</span><br><span class="line">log(&apos;hello&apos;,&apos;china&apos;) // hello china</span><br><span class="line">log(&apos;hello&apos;,&apos;&apos;) // hello</span><br></pre></td></tr></table></figure><h4 id="默认参数使用注意点"><a href="#默认参数使用注意点" class="headerlink" title="默认参数使用注意点"></a>默认参数使用注意点</h4><ol><li>参数变量是默认声明的，所以不能用let或const再次声明。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(x = 5) &#123;</span><br><span class="line">  let x = 1; // Identifier &apos;x&apos; has already been declared</span><br><span class="line">  const x = 2; // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用参数默认值时，函数不能有同名参数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">function foo(x, x, y) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function foo(x, x, y = 1) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// SyntaxError: Duplicate parameter name not allowed in this context</span><br></pre></td></tr></table></figure><ol start="3"><li>显式传入undefined或不传值时使用函数默认参数值，传入’’或null时使用传入的参数值。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test (num = 1)&#123;</span><br><span class="line">  console.log(typeof num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();   // &apos;number&apos; (num is set to 1)</span><br><span class="line">test(undefined); // &apos;number&apos; (num is set to 1 too)</span><br><span class="line"></span><br><span class="line">// test with other falsy values: </span><br><span class="line"></span><br><span class="line">test(&apos;&apos;)  // &apos;string&apos; (num is set to &apos;&apos;)</span><br><span class="line">test(null) // &apos;object&apos; (num is set to null)</span><br></pre></td></tr></table></figure><ol start="4"><li>参数默认值不是传值的，而是字函数被调用时，参数默认值才会被解析。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function append(value, array = [])&#123;</span><br><span class="line">  array.push(value);</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">append(1); // [1]</span><br><span class="line">append(2); // [2], not [1,2]</span><br></pre></td></tr></table></figure><ol start="5"><li>位置在前的默认参数可用于后面的默认参数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function greet (name,greeting,message = greeting + &apos;&apos; + name)&#123;</span><br><span class="line">  return [name,greeting,message];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(&apos;David&apos;, &apos;Hi&apos;) // [&apos;David&apos;, &apos;Hi&apos;, &apos;Hi&apos;, &apos;Hi David&apos;]</span><br><span class="line">greet(&apos;David&apos;, &apos;Hi&apos;, &apos;Happy birthday!&apos;); // [&apos;David&apos;, &apos;Hi&apos;, &apos;Happy Birthday!&apos;]</span><br></pre></td></tr></table></figure><ol start="6"><li>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">function f(x = 1, y) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [1, undefined]</span><br><span class="line">f(2) // [2, undefined])</span><br><span class="line">f(, 1) // 报错</span><br><span class="line">f(undefined, 1) // [1, 1]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">function f(x, y = 5, z) &#123;</span><br><span class="line">  return [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [undefined, 5, undefined]</span><br><span class="line">f(1) // [1, 5, undefined]</span><br><span class="line">f(1, ,2) // 报错</span><br><span class="line">f(1, undefined, 2) // [1, 5, 2]</span><br></pre></td></tr></table></figure><ol start="7"><li>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。后文的 rest 参数也不会计入length属性。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function (a) &#123;&#125;).length // 1</span><br><span class="line">(function (a = 5) &#123;&#125;).length // 0</span><br><span class="line">(function (a, b, c = 5) &#123;&#125;).length // 2</span><br><span class="line"></span><br><span class="line">(function(...args) &#123;&#125;).length // 0</span><br><span class="line"></span><br><span class="line">(function (a = 0, b, c) &#123;&#125;).length // 0</span><br><span class="line">(function (a, b = 1, c) &#123;&#125;).length // 1</span><br></pre></td></tr></table></figure><h4 id="剩余-rest-参数"><a href="#剩余-rest-参数" class="headerlink" title="剩余(rest)参数"></a>剩余(rest)参数</h4><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(...values) &#123;</span><br><span class="line">  let sum = 0;</span><br><span class="line"></span><br><span class="line">  for (var val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) // 10</span><br></pre></td></tr></table></figure><h4 id="rest-参数使用注意点"><a href="#rest-参数使用注意点" class="headerlink" title="rest 参数使用注意点"></a>rest 参数使用注意点</h4><ol><li>rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function f(a, ...b, c) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数的length属性，不包括 rest 参数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(a) &#123;&#125;).length  // 1</span><br><span class="line">(function(...a) &#123;&#125;).length  // 0</span><br><span class="line">(function(a, ...b) &#123;&#125;).length  // 1</span><br></pre></td></tr></table></figure><ol start="3"><li>rest参数可以被解构，这意味着他们的数据可以被解包到不同的变量中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f(...[a, b, c]) &#123;</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1)          // NaN (b and c are undefined)</span><br><span class="line">f(1, 2, 3)    // 6</span><br><span class="line">f(1, 2, 3, 4) // 6 (the fourth parameter is not destructured)</span><br></pre></td></tr></table></figure><h4 id="rest参数和-arguments对象的区别"><a href="#rest参数和-arguments对象的区别" class="headerlink" title="rest参数和 arguments对象的区别"></a>rest参数和 arguments对象的区别</h4><ul><li><p>rest参数只包含那些没有对应形参的实参，而arguments对象包含了传给函数的所有实参。</p></li><li><p>arguments对象不是一个真正的数组，而rest参数是真正的Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。</p></li><li><p>arguments对象还有一些附加的属性 （如callee属性）。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  // ES5\ES3 默认参数的写法</span><br><span class="line">  function f(x, y, z) &#123;</span><br><span class="line">    if (y === undefined) &#123;</span><br><span class="line">      y = 7;</span><br><span class="line">    &#125;</span><br><span class="line">    if (z === undefined) &#123;</span><br><span class="line">      z = 42</span><br><span class="line">    &#125;</span><br><span class="line">    return x + y + z</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(f(1, 3));</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // ES6 默认参数</span><br><span class="line">  function f(x, y = 7, z = 42) &#123;</span><br><span class="line">    return x + y + z</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(f(1, 3));</span><br><span class="line">&#125; &#123;</span><br><span class="line">  function checkParameter() &#123;</span><br><span class="line">    throw new Error(&apos;can\&apos;t be empty&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  function f(x = checkParameter(), y = 7, z = 42) &#123;</span><br><span class="line">    return x + y + z</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(f(1));</span><br><span class="line">  try &#123;</span><br><span class="line">    f()</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125; finally &#123;&#125;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // ES3,ES5 可变参数</span><br><span class="line">  function f() &#123;</span><br><span class="line">    var a = Array.prototype.slice.call(arguments);</span><br><span class="line">    var sum = 0;</span><br><span class="line">    a.forEach(function(item) &#123;</span><br><span class="line">      sum += item * 1;</span><br><span class="line">    &#125;)</span><br><span class="line">    return sum</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(f(1, 2, 3, 6));</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // ES6 可变参数</span><br><span class="line">  // ... 扩展运算符</span><br><span class="line">  function f(...a) &#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    a.forEach(item =&gt; &#123;</span><br><span class="line">      sum += item * 1</span><br><span class="line">    &#125;);</span><br><span class="line">    return sum</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(f(1, 2, 3, 6));</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // ES5 合并数组</span><br><span class="line">  var params = [&apos;hello&apos;, true, 7];</span><br><span class="line">  var other = [1, 2].concat(params);</span><br><span class="line">  console.log(other);</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // ES6 利用扩展运算符合并数组</span><br><span class="line">  var params = [&apos;hello&apos;, true, 7];</span><br><span class="line">  var other = [</span><br><span class="line">    1, 2, ...params</span><br><span class="line">  ];</span><br><span class="line">  console.log(other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;函数默认参数，在ES6中，可以为函数的采纳数指定默认值。函数默认参数允许在没有值或undefined被传入时使用默认形参。&lt;/p&gt;&lt;figure
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 箭头函数</title>
    <link href="https://liushuai97.github.io/2019/10/17/ES6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://liushuai97.github.io/2019/10/17/ES6-箭头函数/</id>
    <published>2019-10-17T06:15:24.000Z</published>
    <updated>2019-10-17T08:39:05.748Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><h4 id="箭头函数基本形式"><a href="#箭头函数基本形式" class="headerlink" title="箭头函数基本形式"></a>箭头函数基本形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let func = （num) =&gt; num;</span><br><span class="line">let func = () =&gt; num;</span><br><span class="line">let sum = (num1,num2) =&gt; num1 + num2;</span><br><span class="line">[1,2,3].map(x =&gt; x * x);</span><br></pre></td></tr></table></figure><h4 id="箭头函数基本特点"><a href="#箭头函数基本特点" class="headerlink" title="箭头函数基本特点"></a>箭头函数基本特点</h4><ul><li>箭头函数this为父作用域的this，不是调用时的this。</li></ul><p>箭头函数的this永远指向其父作用域，任何方法都改变不了，包括call，apply，bind。普通函数的this指向调用它的那个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123; </span><br><span class="line">  name: &apos;jike&apos;, </span><br><span class="line">  init: function () &#123; </span><br><span class="line">    document.body.onclick = () =&gt; &#123; </span><br><span class="line">      alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// init是function，以person.init()调用</span><br><span class="line">// this指向person本身</span><br><span class="line">// onclick是箭头函数，其内部的this，就是父作用域的this，就是person，能得到name。</span><br><span class="line">person.init();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    name:&apos;jike&apos;,</span><br><span class="line">    init:() =&gt; &#123;</span><br><span class="line">        document.body.onclick = () =&gt; &#123;</span><br><span class="line">            alert(this.name);             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// init()箭头函数，其内部的this为全局window</span><br><span class="line">// onclick的this也就是init函数的this，也是window，得到的this.name就为undefined。</span><br><span class="line">person.init();</span><br></pre></td></tr></table></figure><ul><li>箭头函数不能作为构造函数，不能使用new。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//构造函数如下：</span><br><span class="line">function Person(p)&#123;</span><br><span class="line">    this.name = p.name;</span><br><span class="line">&#125;</span><br><span class="line">//如果用箭头函数作为构造函数，则如下</span><br><span class="line">var Person = (p) =&gt; &#123;</span><br><span class="line">    this.name = p.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于this必须是对象实例，而箭头函数是没有实例的，此处的this指向别处，不能产生person实例，自相矛盾。</span><br></pre></td></tr></table></figure><ul><li>箭头函数没有arguments，caller，callee</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let B = (b)=&gt;&#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">B(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined</span><br><span class="line"></span><br><span class="line">let C = (...c) =&gt; &#123;</span><br><span class="line">  console.log(c);</span><br><span class="line">&#125;</span><br><span class="line">C(3,82,32,11323);  // [3, 82, 32, 11323]</span><br></pre></td></tr></table></figure><ul><li>箭头函数通过call和apply调用，不会改变this指向，只会传入参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let obj2 = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    b: function(n) &#123;</span><br><span class="line">        let f = (n) =&gt; n + this.a;</span><br><span class="line">        return f(n);</span><br><span class="line">    &#125;,</span><br><span class="line">    c: function(n) &#123;</span><br><span class="line">        let f = (n) =&gt; n + this.a;</span><br><span class="line">        let m = &#123;</span><br><span class="line">            a: 20</span><br><span class="line">        &#125;;</span><br><span class="line">        return f.call(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj2.b(1));  // 11</span><br><span class="line">console.log(obj2.c(1)); // 11</span><br></pre></td></tr></table></figure><ul><li>箭头函数没有原型属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = ()=&gt;&#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b()&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a.prototype);  // undefined</span><br><span class="line">console.log(b.prototype);   // &#123;constructor: ƒ&#125;</span><br></pre></td></tr></table></figure><ul><li><p>箭头函数不能作为Generator函数，不能使用yield关键字</p></li><li><p>箭头函数返回对象时，要加一个小括号</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var func = () =&gt; (&#123; foo: 1 &#125;); //正确</span><br><span class="line">var func = () =&gt; &#123; foo: 1 &#125;;   //错误</span><br></pre></td></tr></table></figure><ul><li>箭头函数在ES6 class中声明的方法为实例方法，不是原型方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//deom1</span><br><span class="line">class Super&#123;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        //do some thing here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//通过Super.prototype可以访问到sayName方法，这种形式定义的方法，都是定义在prototype上</span><br><span class="line">var a = new Super()</span><br><span class="line">var b = new Super()</span><br><span class="line">a.sayName === b.sayName //true</span><br><span class="line">//所有实例化之后的对象共享prototypy上的sayName方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//demo2</span><br><span class="line">class Super&#123;</span><br><span class="line">    sayName =()=&gt;&#123;</span><br><span class="line">        //do some thing here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//通过Super.prototype访问不到sayName方法，该方法没有定义在prototype上</span><br><span class="line">var a = new Super()</span><br><span class="line">var b = new Super()</span><br><span class="line">a.sayName === b.sayName //false</span><br><span class="line">//实例化之后的对象各自拥有自己的sayName方法，比demo1需要更多的内存空间</span><br></pre></td></tr></table></figure><ul><li>多重箭头函数就是一个高阶函数，相当于内嵌函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const add = x =&gt; y =&gt; y + x;</span><br><span class="line">//相当于</span><br><span class="line">function add(x)&#123;</span><br><span class="line">  return function(y)&#123;</span><br><span class="line">    return y + x;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头函数常见错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: () =&gt; console.log(this.foo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.bar()  //undefined</span><br><span class="line"></span><br><span class="line">// bar函数中的this指向父作用域，而a对象没有作用域，因此this不是a，打印结果为undefined</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  this.foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.prototype.bar = () =&gt; console.log(this.foo)</span><br><span class="line"></span><br><span class="line">let a = new A()</span><br><span class="line">a.bar()  //undefined</span><br><span class="line"></span><br><span class="line">// 原型上使用箭头函数，this指向是其父作用域，并不是对象a，因此得不到预期结果。</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;箭头函数基本形式&quot;&gt;&lt;a href=&quot;#箭头函数基本形式&quot; class=&quot;headerlink&quot; title=&quot;箭头函数基本形式&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 作用域</title>
    <link href="https://liushuai97.github.io/2019/10/17/ES6-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://liushuai97.github.io/2019/10/17/ES6-作用域/</id>
    <published>2019-10-17T03:33:07.000Z</published>
    <updated>2019-10-17T06:13:41.703Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><h4 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h4><p>任何编程语言都有作用域的概念，简单来说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p><p>JavaScript的作用域是靠函数来形成的，也就是说一个函数的变量在函数外不可以访问。</p><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>任何地方都能访问到的对象拥有全局作用域。</p><ol><li>函数外面定义的变量拥有全局作用域</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var n = 2;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn());  // 1</span><br><span class="line">console.log(n); // 2</span><br><span class="line">console.log(a); //报错 a is not defined</span><br></pre></td></tr></table></figure><ol start="2"><li>未定义直接赋值的变量自动声明为拥有全局作用域</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var n = 2;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  a = 1;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn());  // 1</span><br><span class="line">console.log(n); // 2</span><br><span class="line">console.log(a); // 1</span><br></pre></td></tr></table></figure><ol start="3"><li>window对象的属性拥有全局作用</li></ol><h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><p>局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所以在一些地方会把这种作用域成为函数作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var n = 2;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn());  // 1</span><br><span class="line">console.log(n); // 2</span><br><span class="line">console.log(a); //报错 a is not defined</span><br><span class="line"></span><br><span class="line">// a是函数内部声明并赋值，拥有局部作用域，只能带函数fn内部使用，在fn外部使用就会报错，这就是局部作用域的特性，外部无法访问。</span><br></pre></td></tr></table></figure><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>通俗的讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。</p><ol><li><p>当执行函数时，总是先从函数内部找寻局部变量。</p></li><li><p>如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，一次向上。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  function fn1()&#123;</span><br><span class="line">    var a = 20;</span><br><span class="line">    console.log(a); // 20</span><br><span class="line">  &#125;</span><br><span class="line">  function fn2()&#123;</span><br><span class="line">    console.log(a); // 10</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn1();</span><br><span class="line">  fn2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line">console.log(a) // 1</span><br></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>提到作用域就不得不提到闭包，简单来讲，闭包外部函数能够读取内部函数的变量。</p><p>优点：闭包可以形成独立的空间，永久的保存局部变量。</p><p>缺点：保存中间值的状态缺点是容易造成内存泄漏，因为闭包中的局部变量永远不会被回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var n = 999;</span><br><span class="line">  nAdd = function () &#123;</span><br><span class="line">    n += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result = f1();</span><br><span class="line"></span><br><span class="line">result(); // 999</span><br><span class="line">nAdd(); // 执行 n += 1</span><br><span class="line">result(); // 1000</span><br></pre></td></tr></table></figure><h4 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h4><p>ES6引入了块级作用域，明确允许在块级作用域中声明函数，let和const命令都涉及块级作用域。块级作用域允许声明函数只在使用大括号的情况下成立，如果未使用大括号，会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// ES5 中作用域</span><br><span class="line">var callbacks = []</span><br><span class="line">for (var i = 0; i &lt;= 2; i++) &#123;</span><br><span class="line">    callbacks[i] = function() &#123;</span><br><span class="line">        return i * 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.table([</span><br><span class="line">    callbacks[0](),</span><br><span class="line">    callbacks[1](),</span><br><span class="line">    callbacks[2](),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">;((function() &#123;</span><br><span class="line">    const foo = function() &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;foo()===1&quot;, foo() === 1)</span><br><span class="line">    ;((function() &#123;</span><br><span class="line">        const foo = function() &#123;</span><br><span class="line">            return 2</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;foo()===2&quot;, foo() === 2)</span><br><span class="line">    &#125;)())</span><br><span class="line">&#125;)())</span><br><span class="line"></span><br><span class="line">// ES6中块级作用域</span><br><span class="line">const callbacks2 = []</span><br><span class="line">for (let j = 0; j &lt;= 2; j++) &#123;</span><br><span class="line">    callbacks2[j] = function() &#123;</span><br><span class="line">        return j * 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.table([</span><br><span class="line">    callbacks2[0](),</span><br><span class="line">    callbacks2[1](),</span><br><span class="line">    callbacks2[2](),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;foo()===1&quot;, foo() === 1)</span><br><span class="line">    &#123;</span><br><span class="line">        function foo() &#123;</span><br><span class="line">            return 2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        console.log(&quot;foo()===2&quot;, foo() === 2)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;foo()===1&quot;, foo() === 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;什么是作用域？&quot;&gt;&lt;a href=&quot;#什么是作用域？&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域？&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 常量</title>
    <link href="https://liushuai97.github.io/2019/10/16/ES6-%E5%B8%B8%E9%87%8F/"/>
    <id>https://liushuai97.github.io/2019/10/16/ES6-常量/</id>
    <published>2019-10-16T03:02:31.000Z</published>
    <updated>2019-10-16T06:11:17.861Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><p>我们都知道一个程序的运行过程主要分为三个步骤：编译-&gt;链接-&gt;执行，传统OO语言里还有两个重要特性就是静态和常量。但在ES6之前是没有常量这个定义的，只有所谓的变量，也就是表示一些经常变化的数据。</p><h4 id="什么是常量？"><a href="#什么是常量？" class="headerlink" title="什么是常量？"></a>什么是常量？</h4><ul><li>常量，表示是一些固定不变的数据。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// ES5 中常量的写法，自定义的常量通常用大写字母，但这只是一种约定，无意中改了也不易发现。如果没必要做的这么严谨，或团队对这潜规则都心知肚明，那用大写字母就OK了。</span><br><span class="line"></span><br><span class="line">Object.defineProperty(window, &quot;PI2&quot;, &#123;</span><br><span class="line">    value: 3.1415926,</span><br><span class="line">    writable: false,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(window.PI2)</span><br><span class="line"></span><br><span class="line">// ES6 的常量写法</span><br><span class="line"></span><br><span class="line">const PI = 3.1415926</span><br><span class="line">console.log(PI)</span><br><span class="line"></span><br><span class="line">// PI = 4</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;我们都知道一个程序的运行过程主要分为三个步骤：编译-&amp;gt;链接-&amp;gt;执行，传统OO语言里还有两个重要特性就是静态和常量。但在ES6之前是没
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Linux基本命令</title>
    <link href="https://liushuai97.github.io/2019/10/14/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://liushuai97.github.io/2019/10/14/Linux基本命令/</id>
    <published>2019-10-14T06:39:59.000Z</published>
    <updated>2019-10-14T07:05:01.195Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:07 GMT+0800 (GMT+08:00) --><h4 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>arch</code></td><td>显示机器的处理器架构</td></tr><tr><td><code>uname -m</code></td><td>显示机器的处理器架构</td></tr><tr><td><code>uname -r</code></td><td>显示正在使用的内核版本</td></tr><tr><td><code>dmidecode -q</code></td><td>显示硬件系统部件 - (SMBIOS / DMI)</td></tr><tr><td><code>hdparm -i /dev/hda</code></td><td>罗列一个磁盘的架构特性</td></tr><tr><td><code>hdparm -tT /dev/sda</code></td><td>在磁盘上执行测试性读取操作</td></tr><tr><td><code>cat /proc/cpuinfo</code></td><td>显示CPU info的信息</td></tr><tr><td><code>cat /proc/interrupts</code></td><td>显示中断</td></tr><tr><td><code>cat /proc/meminfo</code></td><td>校验内存使用</td></tr><tr><td><code>cat /proc/swaps</code></td><td>显示哪些swap被使用</td></tr><tr><td><code>cat /proc/version</code></td><td>显示内核的版本</td></tr><tr><td><code>cat /proc/net/dev</code></td><td>显示网络适配器及统计</td></tr><tr><td><code>cat /proc/mounts</code></td><td>显示已加载的文件系统</td></tr><tr><td><code>lspci -tv</code></td><td>罗列 PCI 设备</td></tr><tr><td><code>lsusb -tv</code></td><td>显示 USB 设备</td></tr><tr><td><code>date</code></td><td>显示系统日期</td></tr><tr><td><code>cal 2007</code></td><td>显示2007年的日历表</td></tr><tr><td><code>date 041217002007.00</code></td><td>设置日期和时间 - 月日时分年.秒</td></tr><tr><td><code>clock -w</code></td><td>将时间修改保存到 BIOS</td></tr></tbody></table><h4 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>shutdown -h now</code></td><td>关闭系统</td></tr><tr><td><code>init 0</code></td><td>关闭系统</td></tr><tr><td><code>telinit 0</code></td><td>关闭系统</td></tr><tr><td><code>shutdown -h hours:minutes &amp;</code></td><td>按预定时间关闭系统</td></tr><tr><td><code>shutdown -c</code></td><td>取消按预定时间关闭系统</td></tr><tr><td><code>shutdown -r now</code></td><td>重启</td></tr><tr><td><code>reboot</code></td><td>重启</td></tr><tr><td><code>logout</code></td><td>注销</td></tr></tbody></table><h4 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>cd /home</code></td><td>进入<code>/home</code>目录</td></tr><tr><td><code>cd ..</code></td><td>返回上一级目录</td></tr><tr><td><code>cd ../..</code></td><td>返回上两级目录</td></tr><tr><td><code>cd</code></td><td>进入个人的主目录</td></tr><tr><td><code>cd ~user1</code></td><td>进入个人的主目录</td></tr><tr><td><code>cd -</code></td><td>返回上次所在的目录</td></tr><tr><td><code>pwd</code></td><td>显示工作路径</td></tr><tr><td><code>ls</code></td><td>查看目录中的文件</td></tr><tr><td><code>ls -F</code></td><td>查看目录中的文件</td></tr><tr><td><code>ls -l</code></td><td>显示文件和目录的详细资料</td></tr><tr><td><code>ls -a</code></td><td>显示隐藏文件</td></tr><tr><td><code>ls *[0-9]*</code></td><td>显示包含数字的文件名和目录名</td></tr><tr><td><code>tree</code></td><td>显示文件和目录由根目录开始的树形结构</td></tr><tr><td><code>lstree</code></td><td>显示文件和目录由根目录开始的树形结构</td></tr><tr><td><code>mkdir dir1</code></td><td>创建一个叫做 ‘dir1’ 的目录’</td></tr><tr><td><code>mkdir dir1 dir2</code></td><td>同时创建两个目录</td></tr><tr><td><code>mkdir -p /tmp/dir1/dir2</code></td><td>创建一个目录树</td></tr><tr><td><code>rm -f file1</code></td><td>删除一个叫做 ‘file1’ 的文件’</td></tr><tr><td><code>rmdir dir1</code></td><td>删除一个叫做 ‘dir1’ 的目录’</td></tr><tr><td><code>rm -rf dir1</code></td><td>删除一个叫做 ‘dir1’ 的目录并同时删除其内容</td></tr><tr><td><code>rm -rf dir1 dir2</code></td><td>同时删除两个目录及它们的内容</td></tr><tr><td><code>mv dir1 new_dir</code></td><td>重命名/移动 一个目录</td></tr><tr><td><code>cp file1 file2</code></td><td>复制一个文件</td></tr><tr><td><code>cp dir/* .</code></td><td>复制一个目录下的所有文件到当前工作目录</td></tr><tr><td><code>cp -a /tmp/dir1 .</code></td><td>复制一个目录到当前工作目录</td></tr><tr><td><code>cp -a dir1 dir2</code></td><td>复制一个目录</td></tr><tr><td><code>ln -s file1 lnk1</code></td><td>创建一个指向文件或目录的软链接</td></tr><tr><td><code>ln file1 lnk1</code></td><td>创建一个指向文件或目录的物理链接</td></tr><tr><td><code>touch -t 0712250000 file1</code></td><td>修改一个文件或目录的时间戳 - (YYMMDDhhmm)</td></tr></tbody></table><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>find / -name file1</code></td><td>从 ‘/‘ 开始进入根文件系统搜索文件和目录</td></tr><tr><td><code>find / -user user1</code></td><td>搜索属于用户 ‘user1’ 的文件和目录</td></tr><tr><td><code>find /home/user1 -name \*.bin</code></td><td>在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件</td></tr><tr><td><code>find /usr/bin -type f -atime +100</code></td><td>搜索在过去100天内未被使用过的执行文件</td></tr><tr><td><code>find /usr/bin -type f -mtime -10</code></td><td>搜索在10天内被创建或者修改过的文件</td></tr><tr><td><code>find / -name \*.rpm -exec chmod 755 &#39;{}&#39; \</code></td><td>搜索以 ‘.rpm’ 结尾的文件并定义其权限</td></tr><tr><td><code>find / -xdev -name \*.rpm</code></td><td>搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备</td></tr><tr><td><code>locate \*.ps</code></td><td>寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令</td></tr><tr><td><code>whereis halt</code></td><td>显示一个二进制文件、源码或man的位置</td></tr><tr><td><code>which halt</code></td><td>显示一个二进制文件或可执行文件的完整路径</td></tr></tbody></table><h4 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>mount /dev/hda2 /mnt/hda2</code></td><td>挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在</td></tr><tr><td><code>umount /dev/hda2</code></td><td>卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出</td></tr><tr><td><code>fuser -km /mnt/hda2</code></td><td>当设备繁忙时强制卸载</td></tr><tr><td><code>umount -n /mnt/hda2</code></td><td>运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用</td></tr><tr><td><code>mount /dev/fd0 /mnt/floppy</code></td><td>挂载一个软盘</td></tr><tr><td><code>mount /dev/cdrom /mnt/cdrom</code></td><td>挂载一个cdrom或dvdrom</td></tr><tr><td><code>mount /dev/hdc /mnt/cdrecorder</code></td><td>挂载一个cdrw或dvdrom</td></tr><tr><td><code>mount /dev/hdb /mnt/cdrecorder</code></td><td>挂载一个cdrw或dvdrom</td></tr><tr><td><code>mount -o loop file.iso /mnt/cdrom</code></td><td>挂载一个文件或ISO镜像文件</td></tr><tr><td><code>mount -t vfat /dev/hda5 /mnt/hda5</code></td><td>挂载一个Windows FAT32文件系统</td></tr><tr><td><code>mount /dev/sda1 /mnt/usbdisk</code></td><td>挂载一个usb 捷盘或闪存设备</td></tr><tr><td><code>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share</code></td><td>挂载一个windows网络共享</td></tr></tbody></table><h4 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>df -h</code></td><td>显示已经挂载的分区列表</td></tr><tr><td>`ls -lSr</td><td>more`</td></tr><tr><td><code>du -sh dir1</code></td><td>估算目录 ‘dir1’ 已经使用的磁盘空间’</td></tr><tr><td>`du -sk *</td><td>sort -rn`</td></tr><tr><td>`rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’</td><td>sort -k1,1n`</td></tr><tr><td>`dpkg-query -W -f=’${Installed-Size;10}t${Package}n’</td><td>sort -k1,1n`</td></tr></tbody></table><h4 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>groupadd group_name</code></td><td>创建一个新用户组</td></tr><tr><td><code>groupdel group_name</code></td><td>删除一个用户组</td></tr><tr><td><code>groupmod -n new_group_name old_group_name</code></td><td>重命名一个用户组</td></tr><tr><td><code>useradd -c &quot;Name Surname &quot; -g admin -d /home/user1 -s /bin/bash user1</code></td><td>创建一个属于 “admin” 用户组的用户</td></tr><tr><td><code>useradd user1</code></td><td>创建一个新用户</td></tr><tr><td><code>userdel -r user1</code></td><td>删除一个用户 ( ‘-r’ 排除主目录)</td></tr><tr><td><code>usermod -c &quot;User FTP&quot; -g system -d /ftp/user1 -s /bin/nologin user1</code></td><td>修改用户属性</td></tr><tr><td><code>passwd</code></td><td>修改口令</td></tr><tr><td><code>passwd user1</code></td><td>修改一个用户的口令 (只允许root执行)</td></tr><tr><td><code>chage -E 2005-12-31 user1</code></td><td>设置用户口令的失效期限</td></tr><tr><td><code>pwck</code></td><td>检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户</td></tr><tr><td><code>grpck</code></td><td>检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组</td></tr><tr><td><code>newgrp group_name</code></td><td>登陆进一个新的群组以改变新创建文件的预设群组</td></tr></tbody></table><h4 id="文件的权限-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的权限-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>ls -lh</code></td><td>显示权限</td></tr><tr><td>`ls /tmp</td><td>pr -T5 -W$COLUMNS`</td></tr><tr><td><code>chmod ugo+rwx directory1</code></td><td>设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</td></tr><tr><td><code>chmod go-rwx directory1</code></td><td>删除群组(g)与其他人(o)对目录的读写执行权限</td></tr><tr><td><code>chown user1 file1</code></td><td>改变一个文件的所有人属性</td></tr><tr><td><code>chown -R user1 directory1</code></td><td>改变一个目录的所有人属性并同时改变改目录下所有文件的属性</td></tr><tr><td><code>chgrp group1 file1</code></td><td>改变文件的群组</td></tr><tr><td><code>chown user1:group1 file1</code></td><td>改变一个文件的所有人和群组属性</td></tr><tr><td><code>find / -perm -u+s</code></td><td>罗列一个系统中所有使用了SUID控制的文件</td></tr><tr><td><code>chmod u+s /bin/file1</code></td><td>设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</td></tr><tr><td><code>chmod u-s /bin/file1</code></td><td>禁用一个二进制文件的 SUID位</td></tr><tr><td><code>chmod g+s /home/public</code></td><td>设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</td></tr><tr><td><code>chmod g-s /home/public</code></td><td>禁用一个目录的 SGID 位</td></tr><tr><td><code>chmod o+t /home/public</code></td><td>设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</td></tr><tr><td><code>chmod o-t /home/public</code></td><td>禁用一个目录的 STIKY 位</td></tr></tbody></table><h4 id="文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消"><a href="#文件的特殊属性-使用-“-”-设置权限，使用-“-“-用于取消" class="headerlink" title="文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消"></a>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>chattr +a file1</code></td><td>只允许以追加方式读写文件</td></tr><tr><td><code>chattr +c file1</code></td><td>允许这个文件能被内核自动压缩/解压</td></tr><tr><td><code>chattr +d file1</code></td><td>在进行文件系统备份时，dump程序将忽略这个文件</td></tr><tr><td><code>chattr +i file1</code></td><td>设置成不可变的文件，不能被删除、修改、重命名或者链接</td></tr><tr><td><code>chattr +s file1</code></td><td>允许一个文件被安全地删除</td></tr><tr><td><code>chattr +S file1</code></td><td>一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</td></tr><tr><td><code>chattr +u file1</code></td><td>若文件被删除，系统会允许你在以后恢复这个被删除的文件</td></tr><tr><td><code>lsattr</code></td><td>显示特殊的属性</td></tr></tbody></table><h4 id="打包和压缩文件"><a href="#打包和压缩文件" class="headerlink" title="打包和压缩文件"></a>打包和压缩文件</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>bunzip2 file1.bz2</code></td><td>解压一个叫做 ‘file1.bz2’的文件</td></tr><tr><td><code>bzip2 file1</code></td><td>压缩一个叫做 ‘file1’ 的文件</td></tr><tr><td><code>gunzip file1.gz</code></td><td>解压一个叫做 ‘file1.gz’的文件</td></tr><tr><td><code>gzip file1</code></td><td>压缩一个叫做 ‘file1’的文件</td></tr><tr><td><code>gzip -9 file1</code></td><td>最大程度压缩</td></tr><tr><td><code>rar a file1.rar test_file</code></td><td>创建一个叫做 ‘file1.rar’ 的包</td></tr><tr><td><code>rar a file1.rar file1 file2 dir1</code></td><td>同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’</td></tr><tr><td><code>rar x file1.rar</code></td><td>解压rar包</td></tr><tr><td><code>unrar x file1.rar</code></td><td>解压rar包</td></tr><tr><td><code>tar -cvf archive.tar file1</code></td><td>创建一个非压缩的 tarball</td></tr><tr><td><code>tar -cvf archive.tar file1 file2 dir1</code></td><td>创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件</td></tr><tr><td><code>tar -tf archive.tar</code></td><td>显示一个包中的内容</td></tr><tr><td><code>tar -xvf archive.tar</code></td><td>释放一个包</td></tr><tr><td><code>tar -xvf archive.tar -C /tmp</code></td><td>将压缩包释放到 /tmp目录下</td></tr><tr><td><code>tar -cvfj archive.tar.bz2 dir1</code></td><td>创建一个bzip2格式的压缩包</td></tr><tr><td><code>tar -jxvf archive.tar.bz2</code></td><td>解压一个bzip2格式的压缩包</td></tr><tr><td><code>tar -cvfz archive.tar.gz dir1</code></td><td>创建一个gzip格式的压缩包</td></tr><tr><td><code>tar -zxvf archive.tar.gz</code></td><td>解压一个gzip格式的压缩包</td></tr><tr><td><code>zip file1.zip file1</code></td><td>创建一个zip格式的压缩包</td></tr><tr><td><code>zip -r file1.zip file1 file2 dir1</code></td><td>将几个文件和目录同时压缩成一个zip格式的压缩包</td></tr><tr><td><code>unzip file1.zip</code></td><td>解压一个zip格式压缩包</td></tr></tbody></table><h4 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>yum install package_name</code></td><td>下载并安装一个rpm包</td></tr><tr><td><code>yum localinstall package_name.rpm</code></td><td>将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</td></tr><tr><td><code>yum update package_name.rpm</code></td><td>更新当前系统中所有安装的rpm包</td></tr><tr><td><code>yum update package_name</code></td><td>更新一个rpm包</td></tr><tr><td><code>yum remove package_name</code></td><td>删除一个rpm包</td></tr><tr><td><code>yum list</code></td><td>列出当前系统中安装的所有包</td></tr><tr><td><code>yum search package_name</code></td><td>在rpm仓库中搜寻软件包</td></tr><tr><td><code>yum clean packages</code></td><td>清理rpm缓存删除下载的包</td></tr><tr><td><code>yum clean headers</code></td><td>删除所有头文件</td></tr><tr><td><code>yum clean all</code></td><td>删除所有缓存的包和头文件</td></tr></tbody></table><h4 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>cat file1</code></td><td>从第一个字节开始正向查看文件的内容</td></tr><tr><td><code>tac file1</code></td><td>从最后一行开始反向查看一个文件的内容</td></tr><tr><td><code>more file1</code></td><td>查看一个长文件的内容</td></tr><tr><td><code>less file1</code></td><td>类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作</td></tr><tr><td><code>head -2 file1</code></td><td>查看一个文件的前两行</td></tr><tr><td><code>tail -2 file1</code></td><td>查看一个文件的最后两行</td></tr><tr><td><code>tail -f /var/log/messages</code></td><td>实时查看被添加到一个文件中的内容</td></tr></tbody></table><h4 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>dos2unix filedos.txt fileunix.txt</code></td><td>将一个文本文件的格式从MSDOS转换成UNIX</td></tr><tr><td><code>unix2dos fileunix.txt filedos.txt</code></td><td>将一个文本文件的格式从UNIX转换成MSDOS</td></tr><tr><td><code>recode ..HTML &lt; page.txt &gt; page.html</code></td><td>将一个文本文件转换成html</td></tr><tr><td>`recode -l</td><td>more`</td></tr></tbody></table><h4 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h4><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td><code>ifconfig eth0</code></td><td>显示一个以太网卡的配置</td></tr><tr><td><code>ifup eth0</code></td><td>启用一个 ‘eth0’ 网络设备</td></tr><tr><td><code>ifdown eth0</code></td><td>禁用一个 ‘eth0’ 网络设备</td></tr><tr><td><code>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</code></td><td>控制IP地址</td></tr><tr><td><code>ifconfig eth0 promisc</code></td><td>设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)</td></tr><tr><td><code>dhclient eth0</code></td><td>以dhcp模式启用 ‘eth0’</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:07 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;系统信息&quot;&gt;&lt;a href=&quot;#系统信息&quot; class=&quot;headerlink&quot; title=&quot;系统信息&quot;&gt;&lt;/a&gt;系统信息&lt;/h4&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://liushuai97.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://liushuai97.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境目录</title>
    <link href="https://liushuai97.github.io/2019/10/14/Linux%E7%8E%AF%E5%A2%83%E7%9B%AE%E5%BD%95/"/>
    <id>https://liushuai97.github.io/2019/10/14/Linux环境目录/</id>
    <published>2019-10-14T06:07:14.000Z</published>
    <updated>2019-10-14T06:35:17.774Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><h4 id="Linux下的目录都是做什么⽤的"><a href="#Linux下的目录都是做什么⽤的" class="headerlink" title="Linux下的目录都是做什么⽤的?"></a>Linux下的目录都是做什么⽤的?</h4><p><img src="menu.png" alt="kyrie irving"></p><ul><li><code>/bin</code></li></ul><p>系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单⼈维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有: cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。</p><ul><li><code>/boot</code></li></ul><p>主要放置开机会使用到的档案，包括Linux核⼼档案以及开机选单与开机所需设定档等等。Linux kernel常⽤的档名为:vmlinuz，如果使⽤的是grub这个开机管理程式，则还会存在/boot/grub/这个⽬录。</p><ul><li><code>/dev</code></li></ul><p>在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个⽬录当中。只要通过存取这个⽬录下的某个档案，就等于存取某个装置。比较重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp, / dev/hd, /dev/sd*等等</p><ul><li><code>/etc</code></li></ul><p>系统主要的设定档⼏乎都放置在这个目录内，例如⼈员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让⼀般使⽤者查阅的，但是只有root有权⼒修改。 FHS建议不要放置可执⾏档(binary)在这个⽬目录中。 ⽐较重要的档案有:/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的⽬录有:/etc/init.d/ :所有服务的预设启动 script都是放在这里的，例如要启动或者关闭iptables的话: /etc/init.d/iptables start、/etc/init.d/ iptables stop/etc/xinetd.d/ :这就是所谓的super daemon管理的 各项服务的设定档目录。/etc/X11/ :与X Window有关的各种设定档都在这⾥，尤其是xorg.conf或XF86Config这两个X Server的设定档。</p><ul><li><code>/home</code></li></ul><p>这是系统预设的使⽤者家⽬录(home directory)。 在你新增⼀个⼀般使⽤者帐号时， 预设的使⽤者家⽬录都会规范到这⾥来。⽐较重要的是，家⽬录有两种代号： ~ ：代 表当前使⽤者的家⽬录，⽽ ~guest：则代表⽤户名为guest的家⽬录。</p><ul><li><code>/lib</code></li></ul><p>系统的函式库⾮常的多，⽽/lib放置的则是在开机时会⽤到的函式库，以及在/bin 或/sbin底下的指令会呼叫的函式库⽽已 。什么是函式库呢？你可以将他想象成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执⾏之意。 尤其重要的 是/lib/modules/这个⽬录，因为该⽬录会放置核⼼相关的模组(驱动程式)。</p><ul><li><code>/media</code></li></ul><p>media是媒体的英⽂，顾名思义，这个/media底下放置的就是可移除的装置。 包括软 碟、光碟、DVD等等装置都暂时挂载于此。 常⻅的档名有：/media/ﬂoppy, /media/cdrom等等。</p><ul><li><code>/mnt</code></li></ul><p>如果你想要暂时挂载某些额外的装置，⼀般建议你可以放置到这个⽬录中。在很早时候，这个⽬录的⽤途与/media相同啦。 只是有了/media之后，这个⽬录就⽤来暂时挂载⽤了。</p><ul><li><code>/opt</code></li></ul><p>这个是给第三⽅协⼒软体放置的⽬录。什么是第三⽅协⼒软体啊？举例来说，KDE这 个桌⾯管理系统是⼀个独⽴的计画，不过他可以安装到Linux系统中，因此KDE的软体 就建议放置到此⽬录下了。另外，如果你想要⾃⾏安装额外的软体(⾮原本的 distribution提供的)，那么也能够将你的软体安装到这⾥来。不过，以前的Linux系统中，我们还是习惯放置在/usr/local⽬录下。</p><ul><li><code>/root</code></li></ul><p>系统管理员(root)的家⽬录。 之所以放在这⾥，是因为如果进⼊单⼈维护模式⽽仅挂载根⽬录时，该⽬录就能够拥有root的家⽬录，所以我们会希望root的家⽬录与根⽬录放置在同⼀个分区中。</p><ul><li><code>/sbin</code></li></ul><p>Linux有⾮常多指令是⽤来设定系统环境的，这些指令只有root才能够利⽤来设定系统，其他使⽤者最多只能⽤来查询⽽已。放在/sbin底下的为开机过程中所需要的，⾥⾯包括了开机、修复、还原系统所需要的指令。⾄于某些伺服器软体程式，⼀般则放置到/usr/sbin/当中。⾄于本机⾃⾏安装的软体所产⽣的系统执⾏档(system binary)， 则放置到/usr/local/sbin/当中了。常⻅的指令包括：fdisk, fsck, ifconﬁg, init, mkfs等等。</p><ul><li><code>/srv</code></li></ul><p>srv可以视为service的缩写，是⼀些⽹路服务启动之后，这些服务所需要取⽤的资料⽬录。常⻅的服务例如WWW, FTP等等。 举例来说，WWW是服器需要的⽹⻚资料就可以放置在/srv/www/⾥⾯。呵呵，看来平时我们编写的代码应该放到这⾥了。</p><ul><li><code>/tmp</code></li></ul><p>这是让⼀般使⽤者或者是正在执⾏的程序暂时放置档案的地⽅。这个⽬录是任何⼈都能够存取的，所以你需要定期的清理⼀下。当然，重要资料不可放置在此⽬录啊。 因为FHS甚⾄建议在开机时，应该要将/tmp下的资料都删除。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;Linux下的目录都是做什么⽤的&quot;&gt;&lt;a href=&quot;#Linux下的目录都是做什么⽤的&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://liushuai97.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://liushuai97.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>HTML DOM Attribute 对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/10/08/HTML-DOM-Attribute-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/10/08/HTML-DOM-Attribute-对象属性与方法/</id>
    <published>2019-10-08T00:18:46.000Z</published>
    <updated>2019-10-08T00:42:47.904Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><h4 id="Attr对象"><a href="#Attr对象" class="headerlink" title="Attr对象"></a>Attr对象</h4><p>在HTMl DOM中，Attr对象表示HTML属性<br>HTML属性始终属于HTML元素</p><h4 id="NamedNodeMap对象"><a href="#NamedNodeMap对象" class="headerlink" title="NamedNodeMap对象"></a>NamedNodeMap对象</h4><p>在HTML DOM中，NamedNodeMap对象表示元素属性节点的无序集合。<br>NamedNodeMap中的节点可通过名称或索引（数字）来访问。</p><h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><table><thead><tr><th align="center">属性 / 方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">attr.isId</td><td>如果属性是 id 类型，则返回 true，否则返回 false。</td></tr><tr><td align="center">attr.name</td><td>返回属性的名称。</td></tr><tr><td align="center">attr.value</td><td>设置或返回属性的值。</td></tr><tr><td align="center">attr.specified</td><td>如果已指定属性，则返回 true，否则返回 false。</td></tr><tr><td align="center">nodemap.getNamedItem()</td><td>从 NamedNodeMap 返回指定的属性节点。</td></tr><tr><td align="center">nodemap.item()</td><td>返回 NamedNodeMap 中位于指定下标的节点。</td></tr><tr><td align="center">nodemap.length</td><td>返回 NamedNodeMap 中的节点数。</td></tr><tr><td align="center">nodemap.removeNamedItem()</td><td>移除指定的属性节点。</td></tr><tr><td align="center">nodemap.setNamedItem()</td><td>设置指定的属性节点（通过名称）。</td></tr></tbody></table><h4 id="DOM4-警告！"><a href="#DOM4-警告！" class="headerlink" title="DOM4 警告！"></a>DOM4 警告！</h4><p>在W3C DOM Core中，Attr(attribute)对象从Node对象继承所有属性和方法。<br>在DOM4中，Attr对象不再从Node继承。<br>为了保证未来的代码安全，您应该避免在属性对象上使用节点对象的属性和方法：</p><table><thead><tr><th align="center">属性 / 方法</th><th>避免的理由</th></tr></thead><tbody><tr><td align="center">attr.appendChild()</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.attributes</td><td>属性没有属性。</td></tr><tr><td align="center">attr.baseURI</td><td>使用 document.baseURI 代替。</td></tr><tr><td align="center">attr.childNodes</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.cloneNode()</td><td>使用 attr.value 代替。</td></tr><tr><td align="center">attr.firstChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.hasAttributes()</td><td>属性没有属性。</td></tr><tr><td align="center">attr.hasChildNodes</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.insertBefore()</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.isEqualNode()</td><td>没有意义。</td></tr><tr><td align="center">attr.isSameNode()</td><td>没有意义。</td></tr><tr><td align="center">attr.isSupported()</td><td>始终为 true。</td></tr><tr><td align="center">attr.lastChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.nextSibling</td><td>属性没有同级节点。</td></tr><tr><td align="center">attr.nodeName</td><td>使用 attr.name 代替。</td></tr><tr><td align="center">attr.nodeType</td><td>始终为 2 (ATTRIBUTE_NODE)。</td></tr><tr><td align="center">attr.nodeValue</td><td>使用 attr.value 代替。</td></tr><tr><td align="center">attr.normalize()</td><td>属性无法被正常化。</td></tr><tr><td align="center">attr.ownerDocument</td><td>始终是您的 HTML 文档。</td></tr><tr><td align="center">attr.ownerElement</td><td>这是您用来访问该属性的 HTML 元素。</td></tr><tr><td align="center">attr.parentNode</td><td>这是您用来访问该属性的 HTML 元素。</td></tr><tr><td align="center">attr.previousSibling</td><td>属性没有同级节点。</td></tr><tr><td align="center">attr.removeChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.replaceChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.textContent</td><td>使用 attr.value 代替。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;Attr对象&quot;&gt;&lt;a href=&quot;#Attr对象&quot; class=&quot;headerlink&quot; title=&quot;Attr对象&quot;&gt;&lt;/a&gt;Att
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTML DOM Element 对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/10/08/HTML-DOM-Element-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/10/08/HTML-DOM-Element-对象属性与方法/</id>
    <published>2019-10-08T00:05:24.000Z</published>
    <updated>2019-10-08T00:14:12.675Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --><p>除了Document对象之外，Element对象就要算是Web变成中最常用的对象了。Element用于变现xml或html元素，提供了对元素标签名、子节点及特性的访问。</p><p>Element对象具有以下特征：</p><ul><li>nodeType的值为1</li><li>nodeName的值为元素的标签名</li><li>nodeValue的值为null</li><li>parentNode可能是Document或Element</li><li>其子节点可能是Element、Text、Comment、ProcessingInstruction、CDATASection或EntityReference.</li></ul><p>HTML DOM节点，在HTMLDOM（文档对象模型）中，每个部分都是节点：</p><ul><li>文档本身是文档节点</li><li>所有HTML元素是元素节点</li><li>所有HTML属性是属性节点</li><li>HTML元素内的文本是文本节点</li><li>注释是注释节点</li></ul><p>Element对象</p><p>在HTML DOM中，Element对象表示HTML元素。<br>Element对象可以拥有类型为元素节点、文本节点、注释节点的子节点。<br>NodeList对象百事节点列表，比如HTMl元素的子节点集合。<br>元素也可以拥有属性。属性是属性节点。</p><h4 id="Element对象属性和方法"><a href="#Element对象属性和方法" class="headerlink" title="Element对象属性和方法"></a>Element对象属性和方法</h4><table><thead><tr><th align="center">属性 / 方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">element.accessKey</td><td>设置或返回元素的快捷键。</td></tr><tr><td align="center">element.appendChild()</td><td>向元素添加新的子节点，作为最后一个子节点。</td></tr><tr><td align="center">element.attributes</td><td>返回元素属性的 NamedNodeMap。</td></tr><tr><td align="center">element.childNodes</td><td>返回元素子节点的 NodeList。</td></tr><tr><td align="center">element.className</td><td>设置或返回元素的 class 属性。</td></tr><tr><td align="center">element.clientHeight</td><td>返回元素的可见高度。</td></tr><tr><td align="center">element.clientWidth</td><td>返回元素的可见宽度。</td></tr><tr><td align="center">element.cloneNode()</td><td>克隆元素。</td></tr><tr><td align="center">element.compareDocumentPosition()</td><td>比较两个元素的文档位置。</td></tr><tr><td align="center">element.contentEditable</td><td>设置或返回元素的文本方向。</td></tr><tr><td align="center">element.dir</td><td>设置或返回元素的内容是否可编辑。</td></tr><tr><td align="center">element.firstChild</td><td>返回元素的首个子。</td></tr><tr><td align="center">element.getAttribute()</td><td>返回元素节点的指定属性值。</td></tr><tr><td align="center">element.getAttributeNode()</td><td>返回指定的属性节点。</td></tr><tr><td align="center">element.getElementsByTagName()</td><td>返回拥有指定标签名的所有子元素的集合。</td></tr><tr><td align="center">element.getFeature()</td><td>返回实现了指定特性的 API 的某个对象。</td></tr><tr><td align="center">element.getUserData()</td><td>返回关联元素上键的对象。</td></tr><tr><td align="center">element.hasAttribute()</td><td>如果元素拥有指定属性，则返回true，否则返回 false。</td></tr><tr><td align="center">element.hasAttributes()</td><td>如果元素拥有属性，则返回 true，否则返回 false。</td></tr><tr><td align="center">element.hasChildNodes()</td><td>如果元素拥有子节点，则返回 true，否则 false。</td></tr><tr><td align="center">element.id</td><td>设置或返回元素的 id。</td></tr><tr><td align="center">element.innerHTML</td><td>设置或返回元素的内容。</td></tr><tr><td align="center">element.insertBefore()</td><td>在指定的已有的子节点之前插入新节点。</td></tr><tr><td align="center">element.isContentEditable</td><td>设置或返回元素的内容。</td></tr><tr><td align="center">element.isDefaultNamespace()</td><td>如果指定的 namespaceURI 是默认的，则返回 true，否则返回 false。</td></tr><tr><td align="center">element.isEqualNode()</td><td>检查两个元素是否相等。</td></tr><tr><td align="center">element.isSameNode()</td><td>检查两个元素是否是相同的节点。</td></tr><tr><td align="center">element.isSupported()</td><td>如果元素支持指定特性，则返回 true。</td></tr><tr><td align="center">element.lang</td><td>设置或返回元素的语言代码。</td></tr><tr><td align="center">element.lastChild</td><td>返回元素的最后一个子元素。</td></tr><tr><td align="center">element.namespaceURI</td><td>返回元素的 namespace URI。</td></tr><tr><td align="center">element.nextSibling</td><td>返回位于相同节点树层级的下一个节点。</td></tr><tr><td align="center">element.nodeName</td><td>返回元素的名称。</td></tr><tr><td align="center">element.nodeType</td><td>返回元素的节点类型。</td></tr><tr><td align="center">element.nodeValue</td><td>设置或返回元素值。</td></tr><tr><td align="center">element.normalize()</td><td>合并元素中相邻的文本节点，并移除空的文本节点。</td></tr><tr><td align="center">element.offsetHeight</td><td>返回元素的高度。</td></tr><tr><td align="center">element.offsetWidth</td><td>返回元素的宽度。</td></tr><tr><td align="center">element.offsetLeft</td><td>返回元素的水平偏移位置。</td></tr><tr><td align="center">element.offsetParent</td><td>返回元素的偏移容器。</td></tr><tr><td align="center">element.offsetTop</td><td>返回元素的垂直偏移位置。</td></tr><tr><td align="center">element.ownerDocument</td><td>返回元素的根元素（文档对象）。</td></tr><tr><td align="center">element.parentNode</td><td>返回元素的父节点。</td></tr><tr><td align="center">element.previousSibling</td><td>返回位于相同节点树层级的前一个元素。</td></tr><tr><td align="center">element.removeAttribute()</td><td>从元素中移除指定属性。</td></tr><tr><td align="center">element.removeAttributeNode()</td><td>移除指定的属性节点，并返回被移除的节点。</td></tr><tr><td align="center">element.removeChild()</td><td>从元素中移除子节点。</td></tr><tr><td align="center">element.replaceChild()</td><td>替换元素中的子节点。</td></tr><tr><td align="center">element.scrollHeight</td><td>返回元素的整体高度。</td></tr><tr><td align="center">element.scrollLeft</td><td>返回元素左边缘与视图之间的距离。</td></tr><tr><td align="center">element.scrollTop</td><td>返回元素上边缘与视图之间的距离。</td></tr><tr><td align="center">element.scrollWidth</td><td>返回元素的整体宽度。</td></tr><tr><td align="center">element.setAttribute()</td><td>把指定属性设置或更改为指定值。</td></tr><tr><td align="center">element.setAttributeNode()</td><td>设置或更改指定属性节点。</td></tr><tr><td align="center">element.setIdAttribute()</td><td>无</td></tr><tr><td align="center">element.setIdAttributeNode()</td><td>无</td></tr><tr><td align="center">element.setUserData()</td><td>把对象关联到元素上的键。</td></tr><tr><td align="center">element.style</td><td>设置或返回元素的 style 属性。</td></tr><tr><td align="center">element.tabIndex</td><td>设置或返回元素的 tab 键控制次序。</td></tr><tr><td align="center">element.tagName</td><td>返回元素的标签名。</td></tr><tr><td align="center">element.textContent</td><td>设置或返回节点及其后代的文本内容。</td></tr><tr><td align="center">element.title</td><td>设置或返回元素的 title 属性。</td></tr><tr><td align="center">element.toString()</td><td>把元素转换为字符串。</td></tr><tr><td align="center">nodelist.item()</td><td>返回 NodeList 中位于指定下标的节点。</td></tr><tr><td align="center">nodelist.length</td><td>返回 NodeList 中的节点数。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Nov 14 2019 15:16:06 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;除了Document对象之外，Element对象就要算是Web变成中最常用的对象了。Element用于变现xml或html元素，提供了对元素标签
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
