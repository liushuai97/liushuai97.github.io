<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随笔</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liushuai97.github.io/"/>
  <updated>2019-11-27T07:33:45.987Z</updated>
  <id>https://liushuai97.github.io/</id>
  
  <author>
    <name>前端菜鸟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP协议（下）</title>
    <link href="https://liushuai97.github.io/2019/11/27/HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://liushuai97.github.io/2019/11/27/HTTP协议（下）/</id>
    <published>2019-11-27T02:14:51.000Z</published>
    <updated>2019-11-27T07:33:45.987Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><h4 id="密码学入门"><a href="#密码学入门" class="headerlink" title="密码学入门"></a>密码学入门</h4><p>密码学的处理对象是数字和字符串。</p><p>散列是一种数据一旦转换为其他形式将永远无法恢复的加密技术，例如：MD5</p><p>加密：</p><ul><li>对称加密（AES、DES、3DES）</li><li>非对称加密（RSA）</li></ul><p>密钥交换算法</p><p>Diffie-Hellman算法是一种注明的密钥协商算法，这种算法可以使得信息交换的双方通过公开的非安全的网络协商生成安全的共享密钥</p><ul><li>Alice与Bob确定两个大素数n和g，这两个数不用保密</li><li>Alice选择另一个大随机数x，并计算A如下：A=gx mod n</li><li>Alice将A发给Bob</li><li>Bob选择另一个大随机数y，并计算B如下：B=gy mod n</li><li>Bob将B发给Alice</li><li>计算秘密密钥K1如下：K1= Bx mod n</li><li>计算秘密密钥K2如下：K2= Ag mod n</li></ul><p>K1-K2，因此Alice和Bob可以用其进行加解密</p><h4 id="证书签发机构（CA）"><a href="#证书签发机构（CA）" class="headerlink" title="证书签发机构（CA）"></a>证书签发机构（CA）</h4><p>CA： CA（certification authority）是数字证书的签发机构，作为权威机构哦，其审核申请者身份后签发数字证书，这样我们只需要效验数字证书即可确定对方的真实身份。</p><p>CA的工作流程：</p><ul><li>服务器example.com将CA请求TLS证书，例如DigiCer</li><li>DigiCert将为example.com创建证书，证书将包含必要的数据，例如服务器名称，服务器的公钥等。</li><li>DigiCert将创建数据（证书）的哈希值，并使用自己的私钥对其进行加密。</li><li>浏览器和操作系统自带DigiCert等权威机构的公钥</li><li>当浏览器收到签名证书时，它将使用公钥从签名生成哈希值，它还将使用证书中指定的散列算法生成数据（证书）的散列。如果两个哈希值匹配，则签名验证成功并且证书是可信的。</li><li>现在浏览器可以使用证书中指定的example.com的公钥继续进行身份验证过程。</li><li>在这里，我们可以将DigiCert称为Root CA</li></ul><h4 id="浏览器如何验证服务器证书的有效性"><a href="#浏览器如何验证服务器证书的有效性" class="headerlink" title="浏览器如何验证服务器证书的有效性"></a>浏览器如何验证服务器证书的有效性</h4><p>证书颁发机构是为服务器创建并签署证书，很少有组织从事这项工作，即DigiCert、Geotrust、Comodo等。如果他们正在为所有服务器签署证书，则必须为所有签名使用相同的私钥，如果它被盗，那么所有的信任都会丢失。为了解决这个问题并增加更多的平均信息量，引入了中间(CAintermediate CA)的概念。</p><p>服务器使用中级证书颁发机构的签名，因此，在于浏览器通信时，服务器将共享两个证书：</p><ol><li>包含服务器的公钥，即实际的服务器证书；</li><li>由Root CA颁发的intermediate CA证书。</li></ol><p>在签名验证期间，浏览器首先使用已经存储在浏览器中的Root CA 的公钥来验证中检证书的数字签名，如果成功，浏览器现在可以信任中间证书及其公钥。现在使用此公钥、浏览器将验证原始服务器证书的签名，该组织可以注册为intermediate CA，以便为其域签署证书。</p><h4 id="SSL-TLS协议"><a href="#SSL-TLS协议" class="headerlink" title="SSL/TLS协议"></a>SSL/TLS协议</h4><p>传输层安全性协议（TLS），及其前身安全套阶层(SSl)是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。</p><p>HTTPS协议的安全性由SSL协议实现，当前使用的TLS协议1.2版本包含了四个核心子协议：握手协议、密钥配置切换协议、应用数据协议及报警协议.</p><ul><li>TLS适用于对称密钥</li><li>对称密钥可以通过安全密钥交换算法共享</li><li>如果请求被截获，密钥交换可能会被欺骗</li><li>使用数字签名进行身份验证</li><li>证书颁发机构和信任链</li></ul><p>HTTPS协议、SSL协议、TLS协议、握手协议的关系</p><ul><li>HTTPS即HTTP over SSL，可理解为基于SSL的HTTP协议。HTTPS协议安全是由SSL协议实现的。</li><li>SSL协议是一种记录协议，扩展性良好，可以很方便的添加子协议。</li><li>握手协议是SSL协议的一个子协议</li><li>TLS协议是SSL协议的后续版本</li></ul><h4 id="HTTPS协议分析"><a href="#HTTPS协议分析" class="headerlink" title="HTTPS协议分析"></a>HTTPS协议分析</h4><p>TLS握手的步骤</p><p><img src="TLS.jpeg" alt="kyrie irving"></p><p>HTTPS的协议本质上就是在HTTP协议连接发起之前，先使用SSL/TLS协议，协调客户端和服务器端，在两端各自产生一个堆成加密算法的秘钥，然后以RSA（对之前生成的秘钥进行非对称加密）的方式安全地传输数据。因为对称加密算法是安全的，所以使用对称加密算法加密的网页也是安全的。</p><p>HTTPS</p><p>非对称加密算法(对称加密算法的秘钥，RSA) + 对称加密算法(加密内容，DES) + 数字证书(防止篡改非对称加密算法的公钥，CA) + HASH算法(防止篡改消息，MD5/SHA1)</p><p>HTTPS 结合使用了 非对称加密算法，对称加密算法，hash算法，分别利用他们的优势，避免他们的缺点。</p><p>利用非对称加密算法获得对称加密算法的秘钥，保证他的安全性；然后实际的网页内容的加密使用的是对称加密算法，利用了对称加密算法速度快的优势，hash算法主要是防止篡改的发生，是一种校验机制，最后数字证书，保证了服务器在将非对称加密算法的公钥传给浏览器时的安全性(不会被中间人篡改)，同时也标志了服务器的身份。</p><h4 id="HTTP2协议分析"><a href="#HTTP2协议分析" class="headerlink" title="HTTP2协议分析"></a>HTTP2协议分析</h4><p>HTTP/2没有改动HTTP的应用语义。HTTP方法、状态代码、URI和标头字段等核心概念一如往常。</p><p>HTTP/2修改数据格式化（分帧）以及在客户端与服务器间传输的方式。这两点统帅全局，通过新的分帧层向我们应用隐藏了所有复杂性。</p><p>由于HTTP/2引入了一个新的二进制分帧层，该层无法与之前的HTTP/1.x服务器和客户端向后兼容，因此协议的主版本提升到HTTP/2。</p><p>HTTP2的特点：</p><ul><li><p>使用二进制格式传输、更高效、更紧凑</p></li><li><p>对报头压缩、降低开销</p></li><li><p>多路复用、一个网络连接实现并行请求。</p></li><li><p>服务器主动推送，减少请求的延迟</p></li><li><p>默认使用加密</p></li></ul><h4 id="HTTP2-二进制分帧"><a href="#HTTP2-二进制分帧" class="headerlink" title="HTTP2 二进制分帧"></a>HTTP2 二进制分帧</h4><p>HTTP/2所有性能增强的核心在于新的二进制分帧层，它定义了如何封装HTTP消息并在客户端与服务器端之间传输。</p><p>这里所谓的“层”指的是为套接字接口与应用可见的高级HTTP API之间一个经过优化的新编码机制。</p><p>HTTP/1.x协议以换行符作为纯文本的分隔符，而HTTP/2将所有传输的信息风格为更小的消息和帧，并采用二进制格式对他们编码。</p><p>客户端和服务器会替我们完成必要的分帧工作。</p><h4 id="HTTP2-多路复用"><a href="#HTTP2-多路复用" class="headerlink" title="HTTP2 多路复用"></a>HTTP2 多路复用</h4><p>在HTTP/1.x中，如果客户端想法器多个并行请求以提升性能，则必须使用多个TCP连接。这种模型也会导致队首阻塞，从而造成底层TCP连接的效率低下。</p><p>将HTTP消息分解为独立的帧，交错发送，然后再另一端重新组装是HTTP2最重要的一项增强，这个机制会在整个网络技术栈中引发一系列连锁反应，而从带来巨大的性能提升。</p><ul><li>并行交错地发送多个请求，请求之间互不影响。</li><li>并行交错地发送多个响应，响应之间互不干扰</li><li>使用一个连接并行发送多个请求和响应。</li><li>不必再为绕过HTTP/1.x限制而做更多工作。</li><li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。</li></ul><h4 id="HTTP2-服务器推送"><a href="#HTTP2-服务器推送" class="headerlink" title="HTTP2 服务器推送"></a>HTTP2 服务器推送</h4><p>HTTP/2新增的另一个强大的新功能，是服务器可以对一个客户端请求发送多个响应，换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户明确地请求。</p><p>HTTP/2打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流。</p><p>服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</p><p>推送资源可以进行以下处理：</p><ul><li>由客户端缓存</li><li>在不同页面之间重用</li><li>与其他资源一起复用</li><li>由服务器设定优先级</li><li>被客户端拒绝</li></ul><h4 id="HTTP2的伪头字段"><a href="#HTTP2的伪头字段" class="headerlink" title="HTTP2的伪头字段"></a>HTTP2的伪头字段</h4><p>伪头部字段是HTTP2内置的几个特殊的以“:”开始的key，用于替换HTTP/1.x中请求行/响应行中的信息，比如请求方法，响应状态码等</p><p>:method 目标URL模式部分（请求）<br>:scheme 目标URL模式部分（请求）<br>:authority 目标URL认证部分（请求）<br>:path 目标URL的路径和查询部分（绝对路径产生式和一个跟着“?”字符的查询产生式）（请求）<br>:status 响应头中的HTTP状态码部分（响应）</p><h4 id="了解HTTP3"><a href="#了解HTTP3" class="headerlink" title="了解HTTP3"></a>了解HTTP3</h4><p>运行在QUIC智商的HTTP协议被称为HTTP/3 （HTTP-over-QUIC）</p><p>QUIC协议基于UDP，正式看中了UDP的速度和效率，同事QUIC业整合了TCP、TLS和HTTP/2的有点，并加以优化。</p><p>特点：</p><ul><li>减少了握手的延迟（1-RTT或0-RTT）</li><li>多路复用、并且没有TCP的阻塞问题</li><li>连接迁移、（主要是客户端）当由wifi转移到4G时，连接不会断开。</li></ul><p>HTTP3与HTTP1.1和HTTP2没有直接关系，也不是HTTP2的扩展</p><p>HTTP3将会是一个全新的WEB协议</p><p>HTTP3目前处于制订和测试阶段</p><h4 id="对首阻塞问题"><a href="#对首阻塞问题" class="headerlink" title="对首阻塞问题"></a>对首阻塞问题</h4><p>HTTP/1.1和HTTP/2都存在对头阻塞问题</p><p>HTTP/2必须使用HTTPS，而HTTPS使用的TLS协议也存在对首阻塞问题。</p><p>QUIC解决队首阻塞问题的方法：</p><ul><li>QUIC的传输单元式Packet，加密单元也是Packet，整个加密、传输、解密都基于Packet，这样就能避免TLS的队首阻塞问题</li><li>QUIC基于UDP，UDP的数据包在接收端没有处理顺序，及时中间丢失一个包，也不会阻塞整条连接，其他资源会被正常处理。</li></ul><h4 id="HTTP与反向代理"><a href="#HTTP与反向代理" class="headerlink" title="HTTP与反向代理"></a>HTTP与反向代理</h4><p>反向代理的用途</p><ul><li>加密和SSL加速</li><li>负载均衡</li><li>缓存静态内容</li><li>压缩</li><li>减速上传</li><li>安全</li><li>外网发布</li></ul><p>Nginx: <a href="http://shouce.jb51.net/nginx/left.html" target="_blank" rel="noopener">http://shouce.jb51.net/nginx/left.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;密码学入门&quot;&gt;&lt;a href=&quot;#密码学入门&quot; class=&quot;headerlink&quot; title=&quot;密码学入门&quot;&gt;&lt;/a&gt;密码学入门&lt;
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://liushuai97.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://liushuai97.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议（上）</title>
    <link href="https://liushuai97.github.io/2019/11/26/HTTP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://liushuai97.github.io/2019/11/26/HTTP协议（上）/</id>
    <published>2019-11-26T00:44:46.000Z</published>
    <updated>2019-11-26T06:22:32.547Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><h4 id="HTTP请求模型"><a href="#HTTP请求模型" class="headerlink" title="HTTP请求模型"></a>HTTP请求模型</h4><ol><li>两端：客户端（Client）、服务端（Server）</li><li>服务器响应</li><li>客户端请求</li></ol><p>浏览器行为与HTTP协议：</p><ol><li>输入网址（判断网络是否连接，是否可以发送互联网请求）</li><li>解析域名（根据域名IP地址查询DNS服务器）</li><li>浏览器发送HTTP请求（传输HTTP数据包）</li><li>服务器处理请求（远端服务器接收HTTP数据包）</li><li>服务器返回HTML响应（接收后响应并返回）</li><li>浏览器处理HTML页面（浏览器渲染）</li><li>继续请求其他资源</li></ol><h4 id="什么是HTTP协议"><a href="#什么是HTTP协议" class="headerlink" title="什么是HTTP协议"></a>什么是HTTP协议</h4><p>HTTP是超文本传输协议，从http服务器传输到本地浏览器的一种传输协议，网站就是基于HTTP协议的，例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。</p><p>HTTP协议是由客户机到服务器的请求（Request）和从服务器到客户机的响应（response）进行约束和规范。</p><h4 id="了解TCP-IP协议栈"><a href="#了解TCP-IP协议栈" class="headerlink" title="了解TCP/IP协议栈"></a>了解TCP/IP协议栈</h4><ol><li>应用层</li></ol><p>为用户提供所需要的各种服务，例如：HTTP、FTP、DNS、SMTP等</p><ol start="2"><li>传输层</li></ol><p>为应用层实体提供端到端的通信功能，保证数据包的顺序传送及数据的完整性。</p><p>该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP）</p><ol start="3"><li>网络层</li></ol><p>主要解决主机到主机的通信问题，IP协议是网际互联网层最重要的协议</p><ol start="4"><li>网络接口层</li></ol><p>负责监视数据在主机和网络之间的交换</p><h4 id="在TCP-IP协议栈中的位置"><a href="#在TCP-IP协议栈中的位置" class="headerlink" title="在TCP/IP协议栈中的位置"></a>在TCP/IP协议栈中的位置</h4><ol><li><p>目前普遍应用版本HTTP1.1</p></li><li><p>正在逐步向HTTP2迁移</p></li><li><p>HTTP默认端口为80</p></li><li><p>HTTPS默认端口为443</p></li></ol><h4 id="HTTP的工作过程"><a href="#HTTP的工作过程" class="headerlink" title="HTTP的工作过程"></a>HTTP的工作过程</h4><p>一次HTTP操作成为一个事务，其工作过程可分为四步：</p><ol><li><p>首先客户机与服务器需要建立连接，只要单机某个超级链接，HTTP的工作开始</p></li><li><p>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户及信息和可能的内容。</p></li><li><p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本、一个成功或错误的代码，后便是MIME信息包括服务器信息，实体信息和可能的内容。</p></li><li><p>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</p></li></ol><p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</p><h4 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h4><p>HTTP请求组成： 请求行、消息报头、请求正文。</p><p>HTTP响应组成： 状态行、消息报头、响应正文。</p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>GET： 请求获取Request-URI所标识的资源</p><p>POST： 在Request-URI所标识的资源后附加新的数据</p><p>HEAD： 请求获取有Request-URI所标识的资源的响应消息报头</p><p>PUT： 请求服务器存储一个资源，并用Request-URI作为其标识</p><p>DELETE：请求服务器删除Request-URI所标识的资源</p><p>TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断。</p><p>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</p><p>OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求</p><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>状态代码有三维数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p><p>1xx：指示信息–标识请求已接收，继续处理</p><p>2xx: 成功–表示请求已被成功接收、理解、接受</p><p>3xx：重定向–要完成请求必须进行更进一步的操作</p><p>4xx：客户端错误–请求有语法错误或请求无法实现</p><p>5xx：服务端错误–服务器未能实现合法的请求</p><h4 id="请求报头域"><a href="#请求报头域" class="headerlink" title="请求报头域"></a>请求报头域</h4><p><img src="Request.png" alt="kyrie irving"></p><h4 id="响应报头域"><a href="#响应报头域" class="headerlink" title="响应报头域"></a>响应报头域</h4><p><img src="response.png" alt="kyrie irving"></p><h4 id="cookies与session"><a href="#cookies与session" class="headerlink" title="cookies与session"></a>cookies与session</h4><p>Cookies是保存在客户端的小段文本，岁客户端点每一个请求发送该URL下的所有cookies到服务器端。</p><p>Session则保存在服务器端，通过唯一的值sessionID来区别每一个用户，SessionID随每个连接请求发送到服务器，服务器根据SessionID来识别客户端，在通过Session的Key获取Session值。</p><h4 id="HTTP缓存机制"><a href="#HTTP缓存机制" class="headerlink" title="HTTP缓存机制"></a>HTTP缓存机制</h4><p>缓存会根据请求保存输出内容的副本，例如HTML页面、图片、文件、当下一个请求来到的时候：若果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。</p><p>缓存的有点：</p><p>减少响应的延迟</p><p>减少网络宽带消耗</p><h4 id="了解缓存策略"><a href="#了解缓存策略" class="headerlink" title="了解缓存策略"></a>了解缓存策略</h4><ol><li><p>强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</p></li><li><p>对比缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p></li><li><p>Etag/If-None-Match策略</p></li><li><p>Last-Modified/If-Modified-Since策略</p></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;HTTP请求模型&quot;&gt;&lt;a href=&quot;#HTTP请求模型&quot; class=&quot;headerlink&quot; title=&quot;HTTP请求模型&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://liushuai97.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="https://liushuai97.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript&amp;QA工程师</title>
    <link href="https://liushuai97.github.io/2019/11/25/JavaScript-QA%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <id>https://liushuai97.github.io/2019/11/25/JavaScript-QA工程师/</id>
    <published>2019-11-25T00:17:05.000Z</published>
    <updated>2019-11-25T08:49:53.191Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><h4 id="测试分层"><a href="#测试分层" class="headerlink" title="测试分层"></a>测试分层</h4><ul><li>单元测试</li></ul><p>单元测试确保基础单元（比如组件、类、函数）没问题</p><ol><li>正确性，保证代码的正确性</li><li>自动化，通过编写测试用例，一次编写，多次运行</li><li>解释性，测试用例用于测试接口、模块的重要性，那么测试用例就会涉及如何使用这些API。</li><li>驱动开发，指导设计，代码被测试的前提是代码本身的可测试性，那么要保证代码的可测试性就要开发中注意API的设计。</li><li>保证重构，互联网行业产品迭代速度很快，迭代后必然存在代码重构的过程，有测试用例做后盾，就可以大胆的进行重构。</li></ol><p>目的：单元测试能够让开发者明确知道代码结果<br>原则：单一职责，接口抽象，层次分离<br>断言库：保证最小单元是否正常运行检测方法<br>测试风格：测试驱动开发（TDD）、行为驱动开发（BDD）是敏捷开发方法论。</p><p>TDD，关注所有功能是否被实现<br>BDD，关注整体行为知否符合整体预期，编写每一行代码都有目的提供一个全面的测试用例集。</p><p>单元测试流程：</p><ol><li>确定测试平台，确定测试平台，代码运行环境等。比如：Node端运行，Chrome运行，推荐Karma</li><li>选择测试框架，mocha，jasmine，jest，ava，辅助的断言库（chai），测试桩（Sinon,testDouble）</li><li>查看测试结果，主要看测试覆盖率。</li></ol><p>单元测试框架：</p><ol><li>better-assert TDD断言库</li><li>should.js BDD断言库</li><li>expect.js BDD断言库</li><li>chai.js TDD、BDD双模</li><li>Jasmine.js BDD断言库</li><li>Node.js 本身继承require(‘assert’)</li><li>Intern 一个大而全的单元测试框架</li><li>QUnit 一个游离在JQuery左右的测试框架</li><li>Macaca 一套完整的自动化测试解决方案</li></ol><ul><li>集成测试</li></ul><p>集成测试确保不同的组件组合在一起没有问题</p><ul><li>自动化测试</li></ul><p>端到端测试是最顶层的测试，即完全作为一个用户一样将程序作为一个完全的黑盒，打开应用程序模式输入，检查功能以及界面是否正确</p><h4 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h4><ul><li><p>性能测试</p></li><li><p>基准测试</p></li></ul><ol><li>面向切面变成AOP无侵入式统计</li><li>Benchmark基准测试方法，它并不是简单地统计执行多少次测试代码后对比时间，它对测试有着严密的抽样过程，执行多少次取决于采样到的数据能够完成统计。根据统计次数计算方差。</li></ol><ul><li>压力测试</li></ul><ol><li>对网络接口做压力测试需要检测的介个常用指标有吞吐率、响应时间和并发数，这些指标反映了服务器并发处理能力。</li><li>PV网站当日访问人数UV独立访问人数。PV每天几十万甚至上百万就需要考虑压力测试。换算公式QPS = PV/t</li><li>常用压力测试工具是ab、siege、http_load</li></ol><ul><li>安全测试</li></ul><p>安全漏洞检查</p><ol><li>XSS</li><li>SQL</li><li>CSRF</li><li>敏感路径、敏感词、敏感图片</li></ol><h4 id="代码检测工具ESLint"><a href="#代码检测工具ESLint" class="headerlink" title="代码检测工具ESLint"></a>代码检测工具ESLint</h4><h4 id="常用测试框架"><a href="#常用测试框架" class="headerlink" title="常用测试框架"></a>常用测试框架</h4><ol><li>单元测试 (karma)</li></ol><p>Karma，karma不是一个测试框架，也不是一个断言库。karma只是启动一个HTTP服务器，并生成HTML文件。所以你可以选择你自己喜欢的测试框架。如Jasmine,Mocha,QUnit等等。</p><p>Jasmine，即是上面所说的JavaScript测试框架。它不依赖于其他任何JavaScript组件，它有干净的语法，Jasmine断言库可以让你简单的写出测试代码，（断言：表示为一些布尔表达式，你可以采用假设的方式，当程序输出的结果是否与假设的结果一致时，断言为真，否则，断言为假）在karma上运行Jasmine可以完成JavaScript的自动化测试、生成覆盖率报告等。</p><ol start="2"><li>e2e测试 (selenium-webdriver)</li></ol><p>Selenium已经支持了大部分主流的浏览器，它是一个用于自动化测试的绝佳工具。</p><p>WebDriver（或者Selenium 2）基本上指的都是特定浏览器控制代码的语言绑定和实现。</p><p>WebDriver引入了一个JSON wire protocol用于将不同的语言和浏览器控制器进行交流。</p><ol start="3"><li>UI测试 || “UI走查” (backstopjs)</li></ol><p>BackstopJS就是一个能够实现css自动化回归测试的工具，和Mocha这种依靠JavaScript判断断言语句正误和PhantomJS以模拟用户操作的测试工具不同，BackstopJS是一个基于比较网站快照的变化的回归测试工具，因此他更适给项目中的样式做回归测试，可以确保我们在重构网站样式的时候样式不发生变化，而且他支持设置多种浏览器尺寸，可以测试响应式布局。</p><ol start="4"><li>接口测试 (mocha &amp;&amp; mochawesome)</li></ol><p>mocha是JavaScript的一种单元测试框架，既可以在浏览器环境下运行，也可以在Node.js环境下运行。</p><p>使用mocha，我们就只需要专注于编写单元测试本身，然后，让mocha去自动运行所有的测试，并给出测试结果。</p><p>mocha的特点主要有：</p><ul><li><p>既可以测试简单的JavaScript函数，又可以测试异步代码，因为异步是JavaScript的特性之一；</p></li><li><p>可以自动运行所有测试，也可以只运行特定的测试；</p></li><li><p>可以支持before、after、beforeEach和afterEach来编写初始化代码。</p></li></ul><p>使用mochawesome模块，可以生成漂亮的HTML格式的报告。</p><p>线上地址：<a href="https://github.com/liushuai97/test" target="_blank" rel="noopener">https://github.com/liushuai97/test</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;测试分层&quot;&gt;&lt;a href=&quot;#测试分层&quot; class=&quot;headerlink&quot; title=&quot;测试分层&quot;&gt;&lt;/a&gt;测试分层&lt;/h4&gt;
      
    
    </summary>
    
    
      <category term="QA" scheme="https://liushuai97.github.io/categories/QA/"/>
    
    
      <category term="QA" scheme="https://liushuai97.github.io/tags/QA/"/>
    
  </entry>
  
  <entry>
    <title>React数据管理</title>
    <link href="https://liushuai97.github.io/2019/11/22/React%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    <id>https://liushuai97.github.io/2019/11/22/React数据管理/</id>
    <published>2019-11-22T07:19:51.000Z</published>
    <updated>2019-11-22T07:28:33.126Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><h4 id="React数据管理"><a href="#React数据管理" class="headerlink" title="React数据管理"></a>React数据管理</h4><ul><li>依靠状态提升来和兄弟元素进行数据交互</li><li>通过发布订阅模式做数据交互</li><li>Redux等数据管理工具</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>状态提升：组件层级扁平化，兄弟组件通信情况很少</li></ul><p><img src="state.png" alt="kyrie irving"></p><ul><li>发布订阅模式：业务规模较小，层级较深的业务</li></ul><p><img src="tip.png" alt="kyrie irving"></p><ul><li>Redux：业务复杂，组件层级较深，兄弟组件通信密切</li></ul><p><img src="store.png" alt="kyrie irving"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;React数据管理&quot;&gt;&lt;a href=&quot;#React数据管理&quot; class=&quot;headerlink&quot; title=&quot;React数据管理
      
    
    </summary>
    
    
      <category term="React" scheme="https://liushuai97.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://liushuai97.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React-Router</title>
    <link href="https://liushuai97.github.io/2019/11/22/React-Router/"/>
    <id>https://liushuai97.github.io/2019/11/22/React-Router/</id>
    <published>2019-11-22T00:42:07.000Z</published>
    <updated>2019-11-22T07:11:06.574Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><p>ReactRouter中提供了以下三大组件：</p><ul><li>路由组件：BrowserRouter（history模式） 和 HashRouter (hash模式)</li><li>路由匹配组件：Route和Switch</li><li>导航组件：Link和NavLink</li></ul><p>当然每个组件下又会有几种不同的子类组件实现。比如： Router组件就针对不同功能和平台对应用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt; 浏览器的路由组件</span><br><span class="line">&lt;HashRouter&gt; URL格式为Hash路由组件</span><br><span class="line">&lt;MemoryRouter&gt; 内存路由组件</span><br><span class="line">&lt;NativeRouter&gt; Native的路由组件</span><br><span class="line">&lt;StaticRouter&gt; 地址不改变的静态路由组件</span><br></pre></td></tr></table></figure><p>注：路由自动跳转，<code>&lt;Redirect&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;</span><br><span class="line">import &#123;</span><br><span class="line">  // HashRouter as Router,</span><br><span class="line">  BrowserRouter as Router,</span><br><span class="line">  Switch,</span><br><span class="line">  Route,</span><br><span class="line">  Link</span><br><span class="line">&#125; from &apos;react-router-dom&apos;</span><br><span class="line"></span><br><span class="line">class A extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Component A</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &#123;/* 参数是：&#123;this.props.match.params.id&#125; */&#125;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route exact path=&#123;`$&#123;this.props.match.path&#125;`&#125; render=&#123;(route)=&gt;&#123;</span><br><span class="line">            return &lt;div&gt;当前组件是不带参数的A组件&lt;/div&gt;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Route exact path=&#123;`$&#123;this.props.match.path&#125;/sub`&#125; render=&#123;(route)=&gt;&#123;</span><br><span class="line">            return &lt;div&gt;当前组件是Sub&lt;/div&gt;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &#123;/* 通配一般放置在最后 */&#125;</span><br><span class="line">          &lt;Route path=&#123;`$&#123;this.props.match.path&#125;/:id`&#125; render=&#123;(route)=&gt;&#123;</span><br><span class="line">            return &lt;div&gt;当前组件是带参数的A组件，参数是：&#123;route.match.params.id&#125;&lt;/div&gt;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;Component B&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Wrapper extends Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link to=&quot;/a&quot;&gt;组件A&lt;/Link&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;Link to=&quot;/a/123&quot;&gt;带参数组件A&lt;/Link&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;Link to=&quot;/a/sub&quot;&gt;Sub&lt;/Link&gt;</span><br><span class="line">        &lt;br/&gt;</span><br><span class="line">        &lt;Link to=&quot;/b&quot;&gt;组件B&lt;/Link&gt;</span><br><span class="line">        &#123;this.props.children&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Wrapper&gt;</span><br><span class="line">    &lt;Route path=&quot;/a&quot; component=&#123;A&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;/b&quot; component=&#123;B&#125;/&gt;</span><br><span class="line">  &lt;/Wrapper&gt;</span><br><span class="line">  &lt;/Router&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;ReactRouter中提供了以下三大组件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;路由组件：BrowserRouter（history模式） 和 HashRo
      
    
    </summary>
    
    
      <category term="React" scheme="https://liushuai97.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://liushuai97.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>路由 Router</title>
    <link href="https://liushuai97.github.io/2019/11/14/%E8%B7%AF%E7%94%B1-Router/"/>
    <id>https://liushuai97.github.io/2019/11/14/路由-Router/</id>
    <published>2019-11-14T07:12:55.000Z</published>
    <updated>2019-11-14T07:15:32.282Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><h4 id="Router-原理"><a href="#Router-原理" class="headerlink" title="Router 原理"></a>Router 原理</h4><ul><li>路由历史</li><li>路由跳转</li><li>逻辑事件</li></ul><h4 id="常见Router"><a href="#常见Router" class="headerlink" title="常见Router"></a>常见Router</h4><ul><li>页面Router</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.href = &apos;http://www.baidu.com&apos;</span><br></pre></td></tr></table></figure><ul><li>Hash Router</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.location = &apos;#test&apos;</span><br><span class="line">window.hashchange = function () &#123;</span><br><span class="line">  console.log(&apos;current hash:&apos;, window.location.hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>H5路由</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">推进一个状态：history.pushState(&apos;name&apos;,&apos;title&apos;,&apos;#test&apos;)</span><br><span class="line">history.pushState(&apos;name&apos;,&apos;title&apos;,&apos;/usr/index&apos;)</span><br><span class="line">替换一个状态：history.replaceState(&apos;name&apos;,&apos;title&apos;,&apos;/index/test&apos;)</span><br><span class="line">window.onpopstate = function (e) &#123;</span><br><span class="line">  console.log(&apos;h5 router change&apos;,e.state);</span><br><span class="line">&#125;</span><br><span class="line">window.onpopstate = function () &#123;</span><br><span class="line">  console.log(window.location.href);</span><br><span class="line">  console.log(window.location.pathname);</span><br><span class="line">  console.log(window.location.hash);</span><br><span class="line">  console.log(window.location.search);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;Router-原理&quot;&gt;&lt;a href=&quot;#Router-原理&quot; class=&quot;headerlink&quot; title=&quot;Router 原理
      
    
    </summary>
    
    
      <category term="HTML" scheme="https://liushuai97.github.io/categories/HTML/"/>
    
    
      <category term="HTML" scheme="https://liushuai97.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>React语法</title>
    <link href="https://liushuai97.github.io/2019/11/13/React%E8%AF%AD%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/11/13/React语法/</id>
    <published>2019-11-13T09:01:24.000Z</published>
    <updated>2019-11-14T07:15:09.764Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">import &apos;./index.scss&apos;</span><br><span class="line"></span><br><span class="line">let style = &#123;&#125;;</span><br><span class="line">let name = &apos;Li&apos;;</span><br><span class="line">let names = [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;];</span><br><span class="line">let flag = false;</span><br><span class="line"></span><br><span class="line">let jsx = (&lt;div className=&quot;jsx&quot; style=&#123;style&#125;&gt;</span><br><span class="line">            &#123;/* 条件判断 */&#125;</span><br><span class="line">            &#123;</span><br><span class="line">              flag ? &lt;p&gt;i am &#123;name&#125;&lt;/p&gt; : &lt;p&gt;i am not &#123;name&#125;&lt;/p&gt;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;/* 变量使用 */&#125;</span><br><span class="line">            jsx...&#123;name&#125;</span><br><span class="line">            &#123;/* 数组循环 */&#125;</span><br><span class="line">            &#123;</span><br><span class="line">              names.map((name, index)=&gt; &lt;p key=&#123;index&#125;&gt;i am &#123;name&#125;&lt;/p&gt;)</span><br><span class="line">            &#125;</span><br><span class="line">          &lt;/div&gt;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(jsx,document.getElementById(&apos;app&apos;));</span><br></pre></td></tr></table></figure><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">// 基础组件</span><br><span class="line">function Componetns() &#123;</span><br><span class="line">  return &lt;h1&gt;i am li&lt;/h1&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ES6写法</span><br><span class="line">class ES6Compontnts extends React.Component&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;i am li&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Componetns/&gt;</span><br><span class="line">    &lt;ES6Compontnts/&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="state-amp-props用法"><a href="#state-amp-props用法" class="headerlink" title="state &amp; props用法"></a>state &amp; props用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">class ES6Compontnts extends React.Component&#123;</span><br><span class="line">  constructor (props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name: &apos;li&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        name: &apos;Reson test&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">    return &lt;h1&gt;i am &#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ES6Compontnts name=&quot;zhang&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">class Component extends React.Component&#123;</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      name: &apos;zhang&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    // 为了在回调中使用 `this`，这个绑定是必不可少的</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.setState(state =&gt; (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">          &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125;</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Component/&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;;</span><br><span class="line"></span><br><span class="line">// 生命周期</span><br><span class="line">// Initialization: 组件初始化  setup props and state</span><br><span class="line">// Mounting: 挂载阶段  componentWillMount render componentDidMount</span><br><span class="line">// Updating：运行阶段  </span><br><span class="line">// props &#123;</span><br><span class="line">//   componentWillReceiveProps </span><br><span class="line">//   shouldComponentUpdate </span><br><span class="line">//   componentWillUpdate </span><br><span class="line">//   render </span><br><span class="line">//   componentDidUpdate</span><br><span class="line">// &#125;</span><br><span class="line">// states&#123;</span><br><span class="line">//   shouldComponentUpdate</span><br><span class="line">//   componentWillUpdate</span><br><span class="line">//   render</span><br><span class="line">//   componentDidMount</span><br><span class="line">// &#125;</span><br><span class="line">// Unmounting：卸载阶段  componentWillUnmount</span><br><span class="line">// Error Handling: 错误处理</span><br><span class="line">class Component extends React.Component&#123;</span><br><span class="line">  // 构造函数</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      data: &apos;张三&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;初始化数据: constructor&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    console.log(&apos;渲染：render&apos;);</span><br><span class="line">    // return 只有一个根元素</span><br><span class="line">    return &lt;p&gt;</span><br><span class="line">              App: &#123;this.props.data&#125;</span><br><span class="line">              &lt;button onClick=&#123;()=&gt;&#123;this.handlClick()&#125;&#125;&gt;更新组件&#123;this.state.data&#125;&lt;/button&gt;</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  // 挂载时</span><br><span class="line">  // 在组件已经被渲染到 DOM 中后运行</span><br><span class="line">  componentDidMount()&#123;</span><br><span class="line">    console.log(&apos;挂载时: componentDidMount&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 处理点击事件</span><br><span class="line">  handlClick() &#123;</span><br><span class="line">    console.log(&apos;更新数据&apos;);</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      name: &apos;李四&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  // 将要接收父组件传来的props</span><br><span class="line">  componentWillReceiveProps()&#123;</span><br><span class="line">    console.log(&apos;将要接收父组件传来的props: componentWillReceiveProps&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 子组件是否应该更新</span><br><span class="line">  shouldComponentUpdate()&#123;</span><br><span class="line">    console.log(&apos;子组件是否应该更新: shouldComponentUpdate&apos;);</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line">  // 组件将要更新</span><br><span class="line">  componentWillUpdate()&#123;</span><br><span class="line">    console.log(&apos;组件将要更新: componentWillUpdate&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 组件更新完成</span><br><span class="line">  componentDidUpdate()&#123;</span><br><span class="line">    console.log(&apos;组件更新完成: componentDidUpdate&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 卸载时</span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    console.log(&apos;卸载时: componentWillUnmount&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class App extends React.Component&#123;</span><br><span class="line">  // 构造函数</span><br><span class="line">  constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      data: &apos;old 张三&apos;,</span><br><span class="line">      hasChild: true</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&apos;初始化数据: constructor&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  onPropsChange()&#123;</span><br><span class="line">    console.log(&apos;更新Props&apos;)</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      data: &apos;new 张三&apos;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  onDel() &#123;</span><br><span class="line">    console.log(&apos;销毁子组件&apos;);</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      hasChild: false</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          this.state.hasChild ? &lt;Component data=&#123;this.state.data&#125;/&gt; : null</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;&#123;this.onPropsChange()&#125;&#125;&gt;改变Props&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;&#123;this.onDel()&#125;&#125;&gt;销毁子组件&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App/&gt;,</span><br><span class="line">  document.getElementById(&apos;app&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;JSX语法&quot;&gt;&lt;a href=&quot;#JSX语法&quot; class=&quot;headerlink&quot; title=&quot;JSX语法&quot;&gt;&lt;/a&gt;JSX语法&lt;
      
    
    </summary>
    
    
      <category term="React" scheme="https://liushuai97.github.io/categories/React/"/>
    
    
      <category term="React" scheme="https://liushuai97.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>浏览器本地存储</title>
    <link href="https://liushuai97.github.io/2019/11/13/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <id>https://liushuai97.github.io/2019/11/13/浏览器本地存储/</id>
    <published>2019-11-13T02:00:23.000Z</published>
    <updated>2019-11-13T02:01:56.949Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 本地存储</span><br><span class="line">  // cookie</span><br><span class="line">  // 用户端保存请求信息的机制</span><br><span class="line">  // 分号分隔的多个key-value字段</span><br><span class="line">  // 存储在本地的加密文件里</span><br><span class="line">  // 域名和路径的限制</span><br><span class="line"></span><br><span class="line">  // name:cookie 名称</span><br><span class="line">  // domain:cookie 生效的域名</span><br><span class="line">  // path: cookie 生效的路径</span><br><span class="line">  // expires: cookie 过期时间</span><br><span class="line">  // HttpOnly: 用户端不可更改</span><br><span class="line"></span><br><span class="line">  // 浏览器端查看cookie</span><br><span class="line">  document.cookie</span><br><span class="line"></span><br><span class="line">  // cookie添加</span><br><span class="line">  document.cookie = &apos;name=Reson;domain=happymmall.com;path=/index.html;expires:Wed, 13 Nov 2020 01:44:49 GMT&apos;</span><br><span class="line"></span><br><span class="line">  // cookie修改</span><br><span class="line">  document.cookie = &apos;name=Reson1;domain=happymmall.com;path=/index.html&apos;</span><br><span class="line"></span><br><span class="line">  // cookie删除 设定过期时间</span><br><span class="line">  document.cookie = &apos;name=Reson1;domain=happymmall.com;path=/index.html;expires:Wed, 13 Nov 2008 01:44:49 GMT&apos;</span><br><span class="line"></span><br><span class="line">  // session</span><br><span class="line">  // 服务端保存请求信息的机制</span><br><span class="line">  // sessionld通常存放在cookie里</span><br><span class="line">  // 会话由浏览器控制，会话结束，session失效</span><br><span class="line"></span><br><span class="line">  // localStorage</span><br><span class="line">  // H5新特性</span><br><span class="line">  // 有域名限制，不存在作用域概念</span><br><span class="line">  // 只有key-value</span><br><span class="line">  // 没有过期时间</span><br><span class="line">  // 浏览器关闭后不消失</span><br><span class="line"></span><br><span class="line">  // 添加localStorage</span><br><span class="line">  window.localStorage.setItem(&apos;name&apos;,&apos;Rosen&apos;);</span><br><span class="line">  window.localStorage.setItem(&apos;name&apos;,JSON.stringify(&#123;name: &apos;Rosen&apos;&#125;));</span><br><span class="line"></span><br><span class="line">  // 查看localStorage</span><br><span class="line">  window.localStorage.getItem(&apos;name&apos;);</span><br><span class="line"></span><br><span class="line">  // 删除localStorage</span><br><span class="line">  window.localStorage.removeItem(&apos;name&apos;);</span><br><span class="line"></span><br><span class="line">  // sessionStorage</span><br><span class="line">  // 和localStorage极其相似</span><br><span class="line">  // 浏览器关闭后消失</span><br><span class="line">  </span><br><span class="line">  // 添加localStorage</span><br><span class="line">  window.sessionStorage.setItem(&apos;name&apos;,&apos;Rosen&apos;);</span><br><span class="line">  window.sessionStorage.setItem(&apos;name&apos;,JSON.stringify(&#123;name: &apos;Rosen&apos;&#125;));</span><br><span class="line"></span><br><span class="line">  // 查看localStorage</span><br><span class="line">  window.sessionStorage.getItem(&apos;name&apos;);</span><br><span class="line"></span><br><span class="line">  // 删除localStorage</span><br><span class="line">  window.sessionStorage.removeItem(&apos;name&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="HTML" scheme="https://liushuai97.github.io/categories/HTML/"/>
    
    
      <category term="HTML" scheme="https://liushuai97.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>ES6语法笔记</title>
    <link href="https://liushuai97.github.io/2019/11/13/ES6%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    <id>https://liushuai97.github.io/2019/11/13/ES6语法笔记/</id>
    <published>2019-11-13T01:25:48.000Z</published>
    <updated>2019-11-13T01:26:18.851Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // let定义变量  const 定义常量</span><br><span class="line">  let a = 1;</span><br><span class="line">  a = 2</span><br><span class="line">  console.log(a);</span><br><span class="line"></span><br><span class="line">  const pi = 3.1415926;</span><br><span class="line">  // pi = 4;</span><br><span class="line">  console.log(pi);</span><br><span class="line">  // 不能重复定义</span><br><span class="line">  // let a = 3</span><br><span class="line">  // console.log(a);</span><br><span class="line"></span><br><span class="line">  // const pi = 10;</span><br><span class="line">  // console.log(19);</span><br><span class="line">  // 块级作用域</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    var b = 3</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(b);</span><br><span class="line">  if (true) &#123;</span><br><span class="line">    let c = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  // console.log(c);</span><br><span class="line">  // 不存在变量提升</span><br><span class="line">  let arr = [1, 2, 3, 4, 5, 6, 7, 8];</span><br><span class="line">  for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  console.log(i);</span><br><span class="line"></span><br><span class="line">  for (let j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  // console.log(j);</span><br><span class="line">  // -------------------------------------</span><br><span class="line">  // 箭头函数</span><br><span class="line">  // 参数 =&gt; 表达式/语句</span><br><span class="line">  let value = 2;</span><br><span class="line">  let double = x =&gt; 2 * x;</span><br><span class="line">  let treble = x =&gt; &#123;</span><br><span class="line">    return 3 * x;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&apos;double&apos;, double(value));</span><br><span class="line">  console.log(&apos;treble&apos;, treble(value));</span><br><span class="line">  // 继承外层作用域</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    commFun: function () &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;,</span><br><span class="line">    arrowFun: () =&gt; &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj.commFun();</span><br><span class="line">  obj.arrowFun();</span><br><span class="line">  // 不能用作构造函数</span><br><span class="line">  let Obj = function () &#123; &#125;</span><br><span class="line">  let obj = new Obj();</span><br><span class="line">  let Animal = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  let animal = new Animal();</span><br><span class="line">  // 没有prototype属性</span><br><span class="line">  let constFm = function () &#123; &#125;</span><br><span class="line">  let pontFm = () =&gt; &#123; &#125;</span><br><span class="line">  console.log(constFm.prototype);</span><br><span class="line">  console.log(pontFm.prototype);</span><br><span class="line">  // -------------------------------------</span><br><span class="line">  // 模板字符串</span><br><span class="line">  // 反引号标记`</span><br><span class="line">  let str = `</span><br><span class="line">    &lt;div class=&quot;title&quot;&gt;</span><br><span class="line">      &lt;h1&gt;测试标题一&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  `;</span><br><span class="line">  // document.querySelector(&apos;body&apos;).innerHTML = str;</span><br><span class="line">  // 支持多行字符串</span><br><span class="line">  // 支持变量和表达式</span><br><span class="line">  let name = &apos;Rosen&apos;;</span><br><span class="line">  str += `$&#123;name&#125;`;</span><br><span class="line">  // document.querySelector(&apos;body&apos;).innerHTML = str;</span><br><span class="line"></span><br><span class="line">  let getName = () =&gt; &#123;</span><br><span class="line">    return &apos;Rosen title&apos;</span><br><span class="line">  &#125;</span><br><span class="line">  str += `$&#123;getName()&#125;`;</span><br><span class="line">  // document.querySelector(&apos;body&apos;).innerHTML = str;</span><br><span class="line"></span><br><span class="line">  let names = [&apos;tim&apos;, &apos;dodo&apos;]</span><br><span class="line"></span><br><span class="line">  str += `</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      $&#123;names.map(name =&gt;</span><br><span class="line">    `&lt;li&gt;Hi, i am $&#123;name&#125;&lt;/li&gt;`</span><br><span class="line">  ).join(&apos; &apos;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  `</span><br><span class="line">  document.querySelector(&apos;body&apos;).innerHTML = str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // Promise</span><br><span class="line">  // Promise对象 </span><br><span class="line">  new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步函数</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: &apos;http://happymmall.com/user/get_user_info.do&apos;,</span><br><span class="line">      type: &apos;post&apos;,</span><br><span class="line">      // 关键词：resolve,reject,then</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;,</span><br><span class="line">      error(err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;).then(</span><br><span class="line">    (res) =&gt; &#123;</span><br><span class="line">      console.log(&apos;success:&apos;, res);</span><br><span class="line">    &#125;,</span><br><span class="line">    (err) =&gt; &#123;</span><br><span class="line">      console.log(&apos;error:&apos;, err);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  // 链式Promise</span><br><span class="line">  let promiseFn1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步函数</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: &apos;http://happymmall.com/user/get_user_info.do&apos;,</span><br><span class="line">      type: &apos;post&apos;,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;,</span><br><span class="line">      error(err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  let promiseFn2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步函数</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: &apos;http://happymmall.com/user/get_cart_prodouct_count.do&apos;,</span><br><span class="line">      type: &apos;post&apos;,</span><br><span class="line">      success(res) &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;,</span><br><span class="line">      error(err) &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  promiseFn1.then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;promiseFn1 success&apos;)</span><br><span class="line">    return promiseFn2;</span><br><span class="line">  &#125;).then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;promiseFn2 success&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 面向对象-类</span><br><span class="line">  // 关键词：class</span><br><span class="line">  // 语法糖，对应function</span><br><span class="line">  // 构造函数：constructor</span><br><span class="line">  class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">      this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">      return this.name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  let animal = new Animal(&apos;animal title&apos;);</span><br><span class="line">  console.log(animal.getName());</span><br><span class="line"></span><br><span class="line">  // 面向对象-类的继承</span><br><span class="line">  // extends：类的继承</span><br><span class="line">  // super：调用父类的构造函数 </span><br><span class="line">  class Animal2 &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      this.name = &apos;张三&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">      return this.name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Cart extends Animal2 &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      super();</span><br><span class="line">      this.name = &apos;cart&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let animal2 = new Animal2();</span><br><span class="line">  let cart = new Cart();</span><br><span class="line"></span><br><span class="line">  console.log(animal2.getName());</span><br><span class="line">  console.log(cart.getName());</span><br><span class="line"></span><br><span class="line">  // 面向对象-对象</span><br><span class="line">  // 对象里属性的简写</span><br><span class="line">  // 对象里方法的简写</span><br><span class="line">  // 属性名可以为表达式</span><br><span class="line">  // 其他扩展</span><br><span class="line">  var name = &quot;Reson&quot;,</span><br><span class="line">    age = 18;</span><br><span class="line"></span><br><span class="line">  // old</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    getName: function () &#123;</span><br><span class="line">      return this.name</span><br><span class="line">    &#125;,</span><br><span class="line">    getAge: function () &#123;</span><br><span class="line">      return this.age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // news</span><br><span class="line">  let name1 = &quot;Reson&quot;,</span><br><span class="line">    age1 = 18;</span><br><span class="line"></span><br><span class="line">  let obj1 = &#123;</span><br><span class="line">    // 变量名可以用作对象属性名</span><br><span class="line">    name1,</span><br><span class="line">    age1,</span><br><span class="line">    // 对象方法可以简写</span><br><span class="line">    getName() &#123;</span><br><span class="line">      return this.name1</span><br><span class="line">    &#125;,</span><br><span class="line">    // 表达式作为属性方法名</span><br><span class="line">    [&apos;get&apos; + &apos;Age&apos;]() &#123;</span><br><span class="line">      return this.age1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Object对象的扩展</span><br><span class="line">  Object.keys(obj1);</span><br><span class="line">  Object.assign(&#123; a: 1 &#125;, &#123; a: 2, b: 2 &#125;)  // 浅拷贝</span><br><span class="line"></span><br><span class="line">  // ES6模块化</span><br><span class="line">  // 解决一个复杂问题时，自上而下逐层把系统划分成若干模块的过程</span><br><span class="line">  // CommonJS,AMD,CMD</span><br><span class="line">  // 关键词 export import</span><br><span class="line"></span><br><span class="line">  // 基本指令：let const</span><br><span class="line">  // 箭头函数：value =&gt; return value + 1</span><br><span class="line">  // 模板字符串： `Hell $&#123;name&#125;`</span><br><span class="line">  // promise: Promise, resolve, reject, then</span><br><span class="line">  // 面向对象： class, extends, super, constructor</span><br><span class="line">  // 模块化：export, import, as, default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题16</title>
    <link href="https://liushuai97.github.io/2019/11/01/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9816/"/>
    <id>https://liushuai97.github.io/2019/11/01/JavaScript-自测题16/</id>
    <published>2019-11-01T05:33:07.000Z</published>
    <updated>2019-11-06T06:37:19.415Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><h4 id="理解元编程"><a href="#理解元编程" class="headerlink" title="理解元编程"></a>理解元编程</h4><p>Symbol、Reflect 和 Proxy 是属于 ES6 元编程范畴的，能“介入”的对象底层操作进行的过程中，并加以影响。元编程中的 元 的概念可以理解为 程序 本身。</p><p>“元编程就是改变程序原本的运行方式”</p><p>Javascript 中，eval、new Function()便是两个可以用来进行元编程的特性。</p><h4 id="ES6-下的元编程：Symbol"><a href="#ES6-下的元编程：Symbol" class="headerlink" title="ES6 下的元编程：Symbol"></a>ES6 下的元编程：Symbol</h4><p>Symbols 是 ES6 一个全新的 API，它是实现了的反射（Reflection within implementation）—— 你将 Symbols 应用到你已有的类和对象上去改变它们的行为。</p><p>Symbols 是新的原始类型（primitive）。就像是 Number、String、和 Boolean 一样。Symbols 具有一个 Symbol 函数用于创建 Symbol。与别的原始类型不同，Symbols 没有字面量语法（例如，String 有 ”）—— 创建 Symbol 的唯一方式是使用类似构造函数而又非构造函数的 Symbol 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Symbol(); // symbol</span><br><span class="line">console.log(Symbol()); // 输出 &quot;Symbol()&quot; 至控制台</span><br><span class="line">assert(typeof Symbol() === &apos;symbol&apos;)</span><br><span class="line">// 类似构造函数而又非构造函数的 Symbol 函数</span><br><span class="line">new Symbol(); // TypeError: Symbol is not a constructor</span><br></pre></td></tr></table></figure><h4 id="Symbols-能被用作对象的-key"><a href="#Symbols-能被用作对象的-key" class="headerlink" title="Symbols 能被用作对象的 key"></a>Symbols 能被用作对象的 key</h4><p>Symbols 能用作对象的 key （类似字符串 key），这意味着你可以分配无限多的具有唯一性的 Symbols 到一个对象上，这些 key 保证不会和现有的字符串 key 冲突，或者和其他 Symbol key 冲突。</p><p>并且，继续划重点，Symbols key 无法通过 for in、for of 或者 Object.getOwnPropertyNames 获得 —— 获得它们的唯一方式是 Object.getOwnPropertySymbols。</p><p>这意味着 Symbols 能够给对象提供一个隐藏层，帮助对象实现了一种全新的目的 —— 属性不可迭代，也不能够通过现有的反射工具获得，并且能被保证不会和对象任何已有属性冲突。</p><p>但是，这里也有个例外：Symbol.for()</p><p>JavaScript 也有另一个创建 Symbol 的方式来轻易地实现 Symbol 的获得和重用：Symbol.for()。该方法在 “全局 Symbol 注册中心” 创建了一个 Symbol。额外注意的一点：这个注册中心也是跨域的，意味着 iframe 或者 service worker 中的 Symbol 会与当前 frame Symbol 相等</p><ol><li>Symbols 无法通过现有的反射工具读取。</li></ol><p>你需要一个新的方法 Object.getOwnPropertySymbols() 来访问对象上的 Symbols，这让 Symbol 适合存储那些你不想让别人直接获得的信息。</p><ol start="2"><li>Symbols 不是私有的。</li></ol><p>作为双刃剑的另一面 —— 对象上所有的 Symbols 都可以直接通过 Object.getOwnPropertySymbols() 获得 —— 这不利于我们使用 Symbol 存储一些真正需要私有化的值。</p><ol start="3"><li>Symbols 不总是唯一的。</li></ol><p>Symbol.for() 将为你返回一个不唯一的 Symbol。不要总认为 Symbol 具有唯一性，除非你自己能够保证它的唯一性。</p><h4 id="Symbol的作用"><a href="#Symbol的作用" class="headerlink" title="Symbol的作用"></a>Symbol的作用</h4><ol><li><p>作为一个可替换字符串或者整型使用的唯一值</p></li><li><p>作为一个对象中放置元信息（metadata）的场所（记住，Symbols 不是私有的）</p></li><li><p>给予开发者在 API 中为对象添加钩子（hook）的能力</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从 API 的 Symbols 常量中获得这个充满魔力的 Inspect Symbol</span><br><span class="line">var inspect = console.Symbols.INSPECT; // 这是一个 Symbols 对象</span><br><span class="line"></span><br><span class="line">var myVeryOwnObject = &#123;&#125;;</span><br><span class="line">console.log(myVeryOwnObject); // 日志 `&#123;&#125;`</span><br><span class="line"></span><br><span class="line">myVeryOwnObject[inspect] = function () &#123; return &apos;DUUUDE&apos;; &#125;;</span><br><span class="line">console.log(myVeryOwnObject); // 日志输出 `DUUUDE`</span><br></pre></td></tr></table></figure><p>钩子实现大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log = function (…items) &#123;</span><br><span class="line">  var output = &apos;&apos;;</span><br><span class="line">  for(const item of items) &#123;</span><br><span class="line">    if (typeof item[console.Symbols.INSPECT] === &apos;function&apos;) &#123;</span><br><span class="line">        output += item[console.Symbols.INSPECT](item);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        output += console.inspect[typeof item](item);</span><br><span class="line">    &#125;</span><br><span class="line">    output += &apos;  &apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  process.stdout.write(output + &apos;\n&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>PS：钩子是什么？</li></ul><p>提供一个可以影响默认的(或原有的)流程(机制)的时机</p><p>通常就是：一个库、一个框架、一个系统或一种语言，提供一个对外公开的接口，通过这个接口，用户能够影响库、框架、系统或程序的行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const arr = [4, 5, 6, 7, 8, 9];</span><br><span class="line">//定义一个尽在奇数索引地方生产值</span><br><span class="line">arr[Symbol.iterator] = function* () &#123;</span><br><span class="line">    let idx = 1;</span><br><span class="line">    console.table(this);</span><br><span class="line">    do &#123;</span><br><span class="line">        yield this[idx];</span><br><span class="line">    &#125; while ((idx += 2) &lt; this.length)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">for (const v of arr) &#123;</span><br><span class="line">    console.log(&apos;v&apos;, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    age: 27</span><br><span class="line">&#125;;</span><br><span class="line">const validator = &#123;</span><br><span class="line">    set(target, key, value) &#123;</span><br><span class="line">        console.log(target);</span><br><span class="line">        if (typeof value !== &quot;number&quot; || Number.isNaN(value)) &#123;</span><br><span class="line">            throw new TypeError(&quot;年龄必须是一个数字&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const proxy = new Proxy(person, validator);</span><br><span class="line">proxy.age = &quot;🇨🇳&quot;;</span><br><span class="line">console.log(123);</span><br></pre></td></tr></table></figure><h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><p>为操作对象而提供的新API</p><ul><li><p>将Object对象的属于语言内部的方法放到Reflect对象上，即从Reflect对象上拿Object对象内部方法。</p></li><li><p>将用 老Object方法 报错的情况，改为返回false</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Tree() &#123;</span><br><span class="line">    return new Proxy(&#123;&#125;, handler);</span><br><span class="line">&#125;</span><br><span class="line">const handler = &#123;</span><br><span class="line">    get(target, key, receiver) &#123;</span><br><span class="line">        if (!(key in target)) &#123;</span><br><span class="line">            //自动创建一个树</span><br><span class="line">            target[key] = Tree();</span><br><span class="line">        &#125;</span><br><span class="line">        return Reflect.get(target, key, receiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tree = Tree();</span><br><span class="line">tree.yideng.student.a = &quot;小牛🐂&quot;;</span><br><span class="line">console.log(tree);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;理解元编程&quot;&gt;&lt;a href=&quot;#理解元编程&quot; class=&quot;headerlink&quot; title=&quot;理解元编程&quot;&gt;&lt;/a&gt;理解元编程&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题15</title>
    <link href="https://liushuai97.github.io/2019/11/01/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9815/"/>
    <id>https://liushuai97.github.io/2019/11/01/JavaScript-自测题15/</id>
    <published>2019-11-01T02:41:39.000Z</published>
    <updated>2019-11-01T03:00:51.043Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  const b = 2;</span><br><span class="line">  function test()&#123;&#125;</span><br><span class="line">  test = 3;</span><br><span class="line">  console.log(typeof test);   // number</span><br><span class="line">&#125;</span><br><span class="line">console.log(a); // 1</span><br><span class="line">console.log(typeof test);  // function</span><br><span class="line">console.log(b); // b is not defined</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">number</span><br><span class="line">1</span><br><span class="line">function</span><br><span class="line">Uncaught ReferenceError: b is not defined</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>test = 3 console.log(type test)为：number</li><li>var a 不存在块级作用域限制，所以 console.log(a)为：1</li><li>test() 函数声明被提升，所以外部console.log(typeof test)为：function</li><li>const b 存在块级作用域限制，所以 b is not defined</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题14</title>
    <link href="https://liushuai97.github.io/2019/11/01/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9814/"/>
    <id>https://liushuai97.github.io/2019/11/01/JavaScript-自测题14/</id>
    <published>2019-11-01T01:30:56.000Z</published>
    <updated>2019-11-01T02:42:34.668Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  Object.prototype.a = &apos;a&apos;;</span><br><span class="line">  Function.prototype.a = &apos;a1&apos;;</span><br><span class="line">  function Person()&#123;&#125;;</span><br><span class="line">  var yideng = new Person();</span><br><span class="line">  console.log(Person.a);</span><br><span class="line">  console.log(yideng.a);</span><br><span class="line">  console.log(1..a);</span><br><span class="line">  console.log(1.a);</span><br><span class="line">  console.log(yideng.__proto__.__proto__.constructor.constructor.constructor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a1</span><br><span class="line">a</span><br><span class="line">a</span><br><span class="line">Uncaught SyntaxError: Invalid or unexpected token  数据格式错误</span><br><span class="line">ƒ Function() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>Person.a 是function Person()函数，所以结果为：a1</li><li>yideng 是 new Person()对象，所以结果为：a</li><li>1..a 是Number(1).a，也是对象，所以结果为：a，特殊转换 +1 1.</li><li>1.a 报错</li><li><code>yideng.__proto__.__proto__.constructor</code> 是Persoon()对象的<strong>proto</strong>下的constructor 内置函数，结果为：ƒ Function() { [native code] }</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题13</title>
    <link href="https://liushuai97.github.io/2019/10/31/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9813/"/>
    <id>https://liushuai97.github.io/2019/10/31/JavaScript-自测题13/</id>
    <published>2019-10-31T08:14:26.000Z</published>
    <updated>2019-11-01T02:42:27.993Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  function test()&#123;</span><br><span class="line">    var a = &quot;yideng&quot;;</span><br><span class="line">    return function()&#123;</span><br><span class="line">      eval(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  test()();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>没有被GC回收</p><p>解析：</p><p>eval(“”)改变了词法作用域，影响了执行上下文，导致a无法回收，但是又没有引用，所以形成野指针</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题12</title>
    <link href="https://liushuai97.github.io/2019/10/31/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9812/"/>
    <id>https://liushuai97.github.io/2019/10/31/JavaScript-自测题12/</id>
    <published>2019-10-31T07:36:38.000Z</published>
    <updated>2019-10-31T08:27:21.789Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  function fn()&#123;</span><br><span class="line">    console.log(this.length); </span><br><span class="line">  &#125;</span><br><span class="line">  var yideng = &#123; </span><br><span class="line">    length: 5,</span><br><span class="line">    method: function()&#123;</span><br><span class="line">      &quot;use strict&quot;;</span><br><span class="line">      fn();</span><br><span class="line">      arguments[0]();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const result = yideng.method.bind(null); </span><br><span class="line">  result(fn,1,3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>fn() this指向window this.length指向iframe为1</li><li>arguments[0] 调用fn()，此时this指向arguments，this.length就是3</li></ol><p>附加题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> function yideng(a,b,c)&#123;</span><br><span class="line">  console.log(this.length);</span><br><span class="line">  console.log(this.callee.length);</span><br><span class="line"> &#125;</span><br><span class="line"> function fn(d)&#123;</span><br><span class="line">   arguments[0](10,20,30,40,50);</span><br><span class="line"> &#125;</span><br><span class="line"> fn(yideng,10,20,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>fn(yideng,10,20,30) 调用yideng() this指向arguments this.length为4</li><li>this.callee.length指向fn(d)为1</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题11</title>
    <link href="https://liushuai97.github.io/2019/10/31/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9811/"/>
    <id>https://liushuai97.github.io/2019/10/31/JavaScript-自测题11/</id>
    <published>2019-10-31T07:19:02.000Z</published>
    <updated>2019-10-31T07:35:20.011Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  console.log(typeof yideng(a));</span><br><span class="line">  var flag = true;</span><br><span class="line">  if(!flag)&#123;</span><br><span class="line">    var a = 1;</span><br><span class="line">  &#125;</span><br><span class="line">  if(flag)&#123;</span><br><span class="line">    function yideng(a)&#123;</span><br><span class="line">      yideng = a;</span><br><span class="line">      console.log(&apos;yideng1&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(typeof yideng(a));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    function yideng(a) &#123;</span><br><span class="line">      yideng = a;</span><br><span class="line">      console.log(&apos;yideng2&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br><span class="line">yideng is not a function</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>a声明未赋值</li><li>yideng()被限制在块级作用域内，无法检测类型</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程概念</title>
    <link href="https://liushuai97.github.io/2019/10/25/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>https://liushuai97.github.io/2019/10/25/函数式编程概念/</id>
    <published>2019-10-25T05:14:09.000Z</published>
    <updated>2019-11-25T08:30:59.961Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:23 GMT+0800 (GMT+08:00) --><h4 id="函数式编程特性"><a href="#函数式编程特性" class="headerlink" title="函数式编程特性"></a>函数式编程特性</h4><ul><li>与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。</li><li>最主要的特征是，函数是第一等公民。</li><li>强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。</li><li>只有纯的、没有副作用的函数，才是合格的函数。</li></ul><h4 id="范畴论"><a href="#范畴论" class="headerlink" title="范畴论"></a>范畴论</h4><p>函数式编程的起源，是一门叫做范畴论（Category Theory）的数学分支。</p><p>“范畴就是使用箭头连接的物体。”</p><p><img src="category.jpg" alt="kyrie irving"></p><p>箭头表示范畴成员之间的关系，正式的名称叫做”态射”（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的”变形”（transformation）。通过”态射”，一个成员可以变形成另一个成员。</p><ul><li>数学模型</li></ul><ol><li>所有成员是一个集合</li><li>变形关系是函数</li></ol><ul><li>范畴与容器</li></ul><ol><li>值（value）</li><li>值的变形关系，也就是函数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  constructor (val) &#123;</span><br><span class="line">    this.val = val;</span><br><span class="line">  &#125;</span><br><span class="line">  addOne (a) &#123;</span><br><span class="line">    return a = a + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><p>对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态的函数，叫做纯函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var xs = [1,2,3,4,5];// Array.slice是纯函数，因为它没有副作用，对于固定的输入，输出总是固定的</span><br><span class="line">xs.slice(0,3);</span><br><span class="line">xs.slice(0,3);</span><br><span class="line">xs.splice(0,3);// Array.splice会对原array造成影响，所以不纯</span><br><span class="line">xs.splice(0,3);</span><br></pre></td></tr></table></figure><h4 id="函数式编程基本的运算"><a href="#函数式编程基本的运算" class="headerlink" title="函数式编程基本的运算"></a>函数式编程基本的运算</h4><p>函数式编程主旨在于将复杂的函数符合成简单的函数（计算理论，或者递归论，或者拉姆达演算）。运算过程尽量写成一系列嵌套的函数调用，函数式编程有两个最基本的运算：合成和柯里化。</p><ul><li>函数的合成</li></ul><p>如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做”函数的合成”（compose）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const compose = (f,g) =&gt; &#123;</span><br><span class="line">  return (x) =&gt; &#123;</span><br><span class="line">    return f(g(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>柯里化</li></ul><p>所谓”柯里化”，就是把一个多参数的函数，转化为单参数函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 柯里化之前</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2) // 3</span><br><span class="line">// 柯里化之后</span><br><span class="line">function addX(y) &#123;</span><br><span class="line">    return function (x) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">addX(2)(1) // 3</span><br></pre></td></tr></table></figure><p>事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const compose = (f, g) =&gt; (x =&gt; f(g(x)));</span><br><span class="line">var first = arr =&gt; arr[0];</span><br><span class="line">var reverse = arr =&gt; arr.reverse();</span><br><span class="line">var last = compose(first, reverse);</span><br><span class="line">last([1, 2, 3, 4, 5]); // 5</span><br></pre></td></tr></table></figure><ul><li>Point Free</li></ul><p>把一些对象自带的方法转化成纯函数，不要命名转瞬即逝的中间变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  const compose = (f, g) =&gt; (x =&gt; f(g(x)));</span><br><span class="line">  const f = str =&gt; str.toUpperCase().split(&apos; &apos;);</span><br><span class="line"></span><br><span class="line">  var toUpperCase = word =&gt; word.toUpperCase();</span><br><span class="line">  var split = x =&gt; (str =&gt; str.split(x));</span><br><span class="line">  var f = compose(split(&apos; &apos;), toUpperCase);</span><br><span class="line">  console.log(f(&quot;abcd efgh&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明式与命令式代码</li></ul><p>函数式编程的一个明显的好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//命令式</span><br><span class="line">let CEOs = [];</span><br><span class="line">for (var i = 0; i &lt; companies.length; i++) &#123;</span><br><span class="line">    CEOs.push(companies[i].CEO)</span><br><span class="line">&#125;</span><br><span class="line">//声明式</span><br><span class="line">let CEOs = companies.map(c =&gt; c.CEO);</span><br></pre></td></tr></table></figure><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul><li>高阶函数</li></ul><p>高阶函数，就是把函数当参数，把传入的函数做一个封装，然后返回这个封装函数,达到更高程度的抽象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//命令式</span><br><span class="line">var add = function (a, b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function math(func, array) &#123;</span><br><span class="line">    return func(array[0], array[1]);</span><br><span class="line">&#125;</span><br><span class="line">math(add, [1, 2]); // 3</span><br></pre></td></tr></table></figure><ul><li>递归与尾递归</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不是尾递归，无法优化</span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">    if (n === 1) return 1;</span><br><span class="line">    return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function factorial(n, total) &#123;</span><br><span class="line">    if (n === 1) return total;</span><br><span class="line">    return factorial(n - 1, n * total);</span><br><span class="line">&#125; //ES6强制使用尾递归</span><br></pre></td></tr></table></figure><h4 id="函子"><a href="#函子" class="headerlink" title="函子"></a>函子</h4><p>函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。</p><p>它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。</p><ul><li>函子的代码实现</li></ul><p>任何具有map方法的数据结构，都可以当作函子的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Functor &#123;</span><br><span class="line">  constructor(val) &#123; </span><br><span class="line">    this.val = val; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(f) &#123;</span><br><span class="line">    return new Functor(f(this.val));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(new Functor(2)).map(function (two) &#123;</span><br><span class="line">  return two + 2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="of方法"><a href="#of方法" class="headerlink" title="of方法"></a>of方法</h4><p>函数式编程一般约定，函子有一个of方法，用来生成新得容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Functor &#123;</span><br><span class="line">  constructor(val) &#123; </span><br><span class="line">    this.val = val; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(f) &#123;</span><br><span class="line">    return new Functor(f(this.val));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Functor.of = function(val) &#123;</span><br><span class="line">  return new Functor(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Functor.of(2).map(function (two) &#123;</span><br><span class="line">  return two + 2;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="maybe函子"><a href="#maybe函子" class="headerlink" title="maybe函子"></a>maybe函子</h4><p>函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。</p><p>Maybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Functor &#123;</span><br><span class="line">  constructor(val) &#123; </span><br><span class="line">    this.val = val; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(f) &#123;</span><br><span class="line">    return new Functor(f(this.val));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Maybe extends Functor &#123;</span><br><span class="line">  map(f) &#123;</span><br><span class="line">    return this.val ? Maybe.of(f(this.val)) : Maybe.of(null);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maybe.of(null).map(function (s) &#123;</span><br><span class="line">  return s.toUpperCase();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Either-函子"><a href="#Either-函子" class="headerlink" title="Either 函子"></a>Either 函子</h4><p>条件运算if…else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。</p><p>Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Either extends Functor &#123;</span><br><span class="line">  constructor(left, right) &#123;</span><br><span class="line">    this.left = left;</span><br><span class="line">    this.right = right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(f) &#123;</span><br><span class="line">    return this.right ? </span><br><span class="line">      Either.of(this.left, f(this.right)) :</span><br><span class="line">      Either.of(f(this.left), this.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Either.of = function (left, right) &#123;</span><br><span class="line">  return new Either(left, right);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var addOne = function (x) &#123;</span><br><span class="line">  return x + 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Either.of(5, 6).map(addOne);</span><br><span class="line">// Either(5, 7);</span><br></pre></td></tr></table></figure><h4 id="ap-函子"><a href="#ap-函子" class="headerlink" title="ap 函子"></a>ap 函子</h4><p>ap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。ap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  class Functor &#123;</span><br><span class="line">    constructor(val) &#123; </span><br><span class="line">      this.val = val; </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    map(f) &#123;</span><br><span class="line">      return new Functor(f(this.val));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // Maybe空值检测</span><br><span class="line">  class Maybe extends Functor &#123;</span><br><span class="line">    map(f) &#123;</span><br><span class="line">      return this.val ? Maybe.of(f(this.val)) : Maybe.of(null);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  class Ap extends Functor &#123;</span><br><span class="line">    ap(F) &#123;</span><br><span class="line">      return Ap.of(this.val(F.val));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Ap.of = function(F)&#123;</span><br><span class="line">    return new Ap(F);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Maybe.of = function(f)&#123;</span><br><span class="line">    return new Maybe(f);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 柯里化</span><br><span class="line">  function add(x) &#123;</span><br><span class="line">    return function (y) &#123;</span><br><span class="line">      return x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(Ap.of(add(2)).ap(Maybe.of(3)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="IO函子"><a href="#IO函子" class="headerlink" title="IO函子"></a>IO函子</h4><p>真正的程序总要去接触肮脏的世界。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function readLocalStorage()&#123;</span><br><span class="line">  return window.localStorage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IO 跟前面那几个 Functor 不同的地方在于，它的 __value 是一个函数。它把不纯的操作（比如 IO、网络请求、DOM）包裹到一个函数内，从而延迟这个操作的执行。所以我们认为，IO 包含的是被包裹的操作的返回值。</p><p>IO其实也算是惰性求值。</p><p>IO负责了调用链积累了很多很多不纯的操作，带来的复杂性和不可维护性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Monad extends Functor &#123;</span><br><span class="line">    join() &#123;</span><br><span class="line">        return this.val;</span><br><span class="line">    &#125;</span><br><span class="line">    flatMap(f) &#123;</span><br><span class="line">        return this.map(f).join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class IO extends Monad &#123;</span><br><span class="line">    map(f) &#123;</span><br><span class="line">        return IO.of(compose(f, this.__value))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>易调试、热部署、并发</li></ul><ol><li><p>函数式编程中的每个符号都是 const 的，于是没有什么函数会有副作用。谁也不能在运行时修改任何东西，也没有函数可以修改在它的作用域之外修改什么值给其他函数继续使用。这意味着决定函数执行结果的唯一因素就是它的返回值，而影响其返回值的唯一因素就是它的参数。</p></li><li><p>函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）。</p></li><li><p>函数式编程中所有状态就是传给函数的参数，而参数都是储存在栈上的。这一特性让软件的热部署变得十分简单。只要比较一下正在运行的代码以及新的代码获得一个diff，然后用这个diff更新现有的代码，新代码的热部署就完成了。</p></li></ol><ul><li>单元测试</li></ul><ol><li><p>严格函数式编程的每一个符号都是对直接量或者表达式结果的引用，没有函数产生副作用。因为从未在某个地方修改过值，也没有函数修改过在其作用域之外的量并被其他函数使用（如类成员或全局变量）。这意味着函数求值的结果只是其返回值，而惟一影响其返回值的就是函数的参数。</p></li><li><p>这是单元测试者的梦中仙境(wet dream)。对被测试程序中的每个函数，你只需在意其参数，而不必考虑函数调用顺序，不用谨慎地设置外部状态。所有要做的就是传递代表了边际情况的参数。如果程序中的每个函数都通过了单元测试，你就对这个软件的质量有了相当的自信。而命令式编程就不能这样乐观了，在 Java 或 C++ 中只检查函数的返回值还不够——我们还必须验证这个函数可能修改了的外部状态。</p></li></ol><h4 id="函数式编程库"><a href="#函数式编程库" class="headerlink" title="函数式编程库"></a>函数式编程库</h4><ol><li>RxJS</li><li>cycleJS</li><li>lodashJS、lazy(惰性求值)</li><li>underscoreJS</li><li>ramdajs</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:23 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;函数式编程特性&quot;&gt;&lt;a href=&quot;#函数式编程特性&quot; class=&quot;headerlink&quot; title=&quot;函数式编程特性&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="函数式编程" scheme="https://liushuai97.github.io/categories/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="函数式编程" scheme="https://liushuai97.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ES6 对象代理</title>
    <link href="https://liushuai97.github.io/2019/10/21/ES6-%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%90%86/"/>
    <id>https://liushuai97.github.io/2019/10/21/ES6-对象代理/</id>
    <published>2019-10-21T07:40:03.000Z</published>
    <updated>2019-10-21T07:56:26.387Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ES3 数据保护</span><br><span class="line">  var Person = function() &#123;</span><br><span class="line">    var data = &#123;</span><br><span class="line">      name: &apos;es3&apos;,</span><br><span class="line">      sex: &apos;male&apos;,</span><br><span class="line">      age: 15</span><br><span class="line">    &#125;</span><br><span class="line">    this.get = function(key) &#123;</span><br><span class="line">      return data[key]</span><br><span class="line">    &#125;</span><br><span class="line">    this.set = function(key, value) &#123;</span><br><span class="line">      if (key !== &apos;sex&apos;) &#123;</span><br><span class="line">        data[key] = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 声明一个实例</span><br><span class="line">  var person = new Person();</span><br><span class="line">  // 读取</span><br><span class="line">  console.table(&#123;name: person.get(&apos;name&apos;), sex: person.get(&apos;sex&apos;), age: person.get(&apos;age&apos;)&#125;);</span><br><span class="line">  // 修改</span><br><span class="line">  person.set(&apos;name&apos;, &apos;es3-cname&apos;);</span><br><span class="line">  console.table(&#123;name: person.get(&apos;name&apos;), sex: person.get(&apos;sex&apos;), age: person.get(&apos;age&apos;)&#125;);</span><br><span class="line">  person.set(&apos;sex&apos;, &apos;female&apos;);</span><br><span class="line">  console.table(&#123;name: person.get(&apos;name&apos;), sex: person.get(&apos;sex&apos;), age: person.get(&apos;age&apos;)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  // ES5 数据保护</span><br><span class="line">  var Person = &#123;</span><br><span class="line">    name: &apos;es5&apos;,</span><br><span class="line">    age: 15</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Person, &apos;sex&apos;, &#123;</span><br><span class="line">    writable: false,</span><br><span class="line">    value: &apos;male&apos;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  console.table(&#123;name: Person.name, age: Person.age, sex: Person.sex&#125;);</span><br><span class="line">  Person.name = &apos;es5-cname&apos;;</span><br><span class="line">  console.table(&#123;name: Person.name, age: Person.age, sex: Person.sex&#125;);</span><br><span class="line">  try &#123;</span><br><span class="line">    Person.sex = &apos;female&apos;;</span><br><span class="line">    console.table(&#123;name: Person.name, age: Person.age, sex: Person.sex&#125;);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ES6</span><br><span class="line">  let Person = &#123;</span><br><span class="line">    name: &apos;es6&apos;,</span><br><span class="line">    sex: &apos;male&apos;,</span><br><span class="line">    age: 15</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  let persoon = new Proxy(Person, &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">      return target[key]</span><br><span class="line">    &#125;,</span><br><span class="line">    set (target, key) &#123;</span><br><span class="line">      if(key !== &apos;sex&apos;)&#123;</span><br><span class="line">        target[key] = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  console.table(&#123;</span><br><span class="line">    name: persoon.name,</span><br><span class="line">    sex: person.sex,</span><br><span class="line">    age: person.age</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  try&#123;</span><br><span class="line">    person.sex=&apos;female&apos;;</span><br><span class="line">  &#125;catch(e)&#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 默认参数</title>
    <link href="https://liushuai97.github.io/2019/10/18/ES6-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    <id>https://liushuai97.github.io/2019/10/18/ES6-默认参数/</id>
    <published>2019-10-18T00:21:37.000Z</published>
    <updated>2019-10-18T03:03:23.818Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><p>函数默认参数，在ES6中，可以为函数的采纳数指定默认值。函数默认参数允许在没有值或undefined被传入时使用默认形参。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x,y = &quot;world&quot;)&#123;</span><br><span class="line">  console.log(x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello world</span><br><span class="line">log(&apos;hello&apos;,&apos;china&apos;) // hello china</span><br><span class="line">log(&apos;hello&apos;,&apos;&apos;) // hello</span><br></pre></td></tr></table></figure><h4 id="默认参数使用注意点"><a href="#默认参数使用注意点" class="headerlink" title="默认参数使用注意点"></a>默认参数使用注意点</h4><ol><li>参数变量是默认声明的，所以不能用let或const再次声明。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(x = 5) &#123;</span><br><span class="line">  let x = 1; // Identifier &apos;x&apos; has already been declared</span><br><span class="line">  const x = 2; // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用参数默认值时，函数不能有同名参数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">function foo(x, x, y) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function foo(x, x, y = 1) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// SyntaxError: Duplicate parameter name not allowed in this context</span><br></pre></td></tr></table></figure><ol start="3"><li>显式传入undefined或不传值时使用函数默认参数值，传入’’或null时使用传入的参数值。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function test (num = 1)&#123;</span><br><span class="line">  console.log(typeof num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();   // &apos;number&apos; (num is set to 1)</span><br><span class="line">test(undefined); // &apos;number&apos; (num is set to 1 too)</span><br><span class="line"></span><br><span class="line">// test with other falsy values: </span><br><span class="line"></span><br><span class="line">test(&apos;&apos;)  // &apos;string&apos; (num is set to &apos;&apos;)</span><br><span class="line">test(null) // &apos;object&apos; (num is set to null)</span><br></pre></td></tr></table></figure><ol start="4"><li>参数默认值不是传值的，而是字函数被调用时，参数默认值才会被解析。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function append(value, array = [])&#123;</span><br><span class="line">  array.push(value);</span><br><span class="line">  return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">append(1); // [1]</span><br><span class="line">append(2); // [2], not [1,2]</span><br></pre></td></tr></table></figure><ol start="5"><li>位置在前的默认参数可用于后面的默认参数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function greet (name,greeting,message = greeting + &apos;&apos; + name)&#123;</span><br><span class="line">  return [name,greeting,message];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(&apos;David&apos;, &apos;Hi&apos;) // [&apos;David&apos;, &apos;Hi&apos;, &apos;Hi&apos;, &apos;Hi David&apos;]</span><br><span class="line">greet(&apos;David&apos;, &apos;Hi&apos;, &apos;Happy birthday!&apos;); // [&apos;David&apos;, &apos;Hi&apos;, &apos;Happy Birthday!&apos;]</span><br></pre></td></tr></table></figure><ol start="6"><li>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">function f(x = 1, y) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [1, undefined]</span><br><span class="line">f(2) // [2, undefined])</span><br><span class="line">f(, 1) // 报错</span><br><span class="line">f(undefined, 1) // [1, 1]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">function f(x, y = 5, z) &#123;</span><br><span class="line">  return [x, y, z];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // [undefined, 5, undefined]</span><br><span class="line">f(1) // [1, 5, undefined]</span><br><span class="line">f(1, ,2) // 报错</span><br><span class="line">f(1, undefined, 2) // [1, 5, 2]</span><br></pre></td></tr></table></figure><ol start="7"><li>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。后文的 rest 参数也不会计入length属性。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function (a) &#123;&#125;).length // 1</span><br><span class="line">(function (a = 5) &#123;&#125;).length // 0</span><br><span class="line">(function (a, b, c = 5) &#123;&#125;).length // 2</span><br><span class="line"></span><br><span class="line">(function(...args) &#123;&#125;).length // 0</span><br><span class="line"></span><br><span class="line">(function (a = 0, b, c) &#123;&#125;).length // 0</span><br><span class="line">(function (a, b = 1, c) &#123;&#125;).length // 1</span><br></pre></td></tr></table></figure><h4 id="剩余-rest-参数"><a href="#剩余-rest-参数" class="headerlink" title="剩余(rest)参数"></a>剩余(rest)参数</h4><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(...values) &#123;</span><br><span class="line">  let sum = 0;</span><br><span class="line"></span><br><span class="line">  for (var val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) // 10</span><br></pre></td></tr></table></figure><h4 id="rest-参数使用注意点"><a href="#rest-参数使用注意点" class="headerlink" title="rest 参数使用注意点"></a>rest 参数使用注意点</h4><ol><li>rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function f(a, ...b, c) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数的length属性，不包括 rest 参数。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(a) &#123;&#125;).length  // 1</span><br><span class="line">(function(...a) &#123;&#125;).length  // 0</span><br><span class="line">(function(a, ...b) &#123;&#125;).length  // 1</span><br></pre></td></tr></table></figure><ol start="3"><li>rest参数可以被解构，这意味着他们的数据可以被解包到不同的变量中。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f(...[a, b, c]) &#123;</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1)          // NaN (b and c are undefined)</span><br><span class="line">f(1, 2, 3)    // 6</span><br><span class="line">f(1, 2, 3, 4) // 6 (the fourth parameter is not destructured)</span><br></pre></td></tr></table></figure><h4 id="rest参数和-arguments对象的区别"><a href="#rest参数和-arguments对象的区别" class="headerlink" title="rest参数和 arguments对象的区别"></a>rest参数和 arguments对象的区别</h4><ul><li><p>rest参数只包含那些没有对应形参的实参，而arguments对象包含了传给函数的所有实参。</p></li><li><p>arguments对象不是一个真正的数组，而rest参数是真正的Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。</p></li><li><p>arguments对象还有一些附加的属性 （如callee属性）。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  // ES5\ES3 默认参数的写法</span><br><span class="line">  function f(x, y, z) &#123;</span><br><span class="line">    if (y === undefined) &#123;</span><br><span class="line">      y = 7;</span><br><span class="line">    &#125;</span><br><span class="line">    if (z === undefined) &#123;</span><br><span class="line">      z = 42</span><br><span class="line">    &#125;</span><br><span class="line">    return x + y + z</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(f(1, 3));</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // ES6 默认参数</span><br><span class="line">  function f(x, y = 7, z = 42) &#123;</span><br><span class="line">    return x + y + z</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(f(1, 3));</span><br><span class="line">&#125; &#123;</span><br><span class="line">  function checkParameter() &#123;</span><br><span class="line">    throw new Error(&apos;can\&apos;t be empty&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  function f(x = checkParameter(), y = 7, z = 42) &#123;</span><br><span class="line">    return x + y + z</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(f(1));</span><br><span class="line">  try &#123;</span><br><span class="line">    f()</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125; finally &#123;&#125;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // ES3,ES5 可变参数</span><br><span class="line">  function f() &#123;</span><br><span class="line">    var a = Array.prototype.slice.call(arguments);</span><br><span class="line">    var sum = 0;</span><br><span class="line">    a.forEach(function(item) &#123;</span><br><span class="line">      sum += item * 1;</span><br><span class="line">    &#125;)</span><br><span class="line">    return sum</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(f(1, 2, 3, 6));</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // ES6 可变参数</span><br><span class="line">  // ... 扩展运算符</span><br><span class="line">  function f(...a) &#123;</span><br><span class="line">    var sum = 0;</span><br><span class="line">    a.forEach(item =&gt; &#123;</span><br><span class="line">      sum += item * 1</span><br><span class="line">    &#125;);</span><br><span class="line">    return sum</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(f(1, 2, 3, 6));</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // ES5 合并数组</span><br><span class="line">  var params = [&apos;hello&apos;, true, 7];</span><br><span class="line">  var other = [1, 2].concat(params);</span><br><span class="line">  console.log(other);</span><br><span class="line">&#125; &#123;</span><br><span class="line">  // ES6 利用扩展运算符合并数组</span><br><span class="line">  var params = [&apos;hello&apos;, true, 7];</span><br><span class="line">  var other = [</span><br><span class="line">    1, 2, ...params</span><br><span class="line">  ];</span><br><span class="line">  console.log(other);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;函数默认参数，在ES6中，可以为函数的采纳数指定默认值。函数默认参数允许在没有值或undefined被传入时使用默认形参。&lt;/p&gt;&lt;figure
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 箭头函数</title>
    <link href="https://liushuai97.github.io/2019/10/17/ES6-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://liushuai97.github.io/2019/10/17/ES6-箭头函数/</id>
    <published>2019-10-17T06:15:24.000Z</published>
    <updated>2019-10-17T08:39:05.748Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><h4 id="箭头函数基本形式"><a href="#箭头函数基本形式" class="headerlink" title="箭头函数基本形式"></a>箭头函数基本形式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let func = （num) =&gt; num;</span><br><span class="line">let func = () =&gt; num;</span><br><span class="line">let sum = (num1,num2) =&gt; num1 + num2;</span><br><span class="line">[1,2,3].map(x =&gt; x * x);</span><br></pre></td></tr></table></figure><h4 id="箭头函数基本特点"><a href="#箭头函数基本特点" class="headerlink" title="箭头函数基本特点"></a>箭头函数基本特点</h4><ul><li>箭头函数this为父作用域的this，不是调用时的this。</li></ul><p>箭头函数的this永远指向其父作用域，任何方法都改变不了，包括call，apply，bind。普通函数的this指向调用它的那个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123; </span><br><span class="line">  name: &apos;jike&apos;, </span><br><span class="line">  init: function () &#123; </span><br><span class="line">    document.body.onclick = () =&gt; &#123; </span><br><span class="line">      alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">// init是function，以person.init()调用</span><br><span class="line">// this指向person本身</span><br><span class="line">// onclick是箭头函数，其内部的this，就是父作用域的this，就是person，能得到name。</span><br><span class="line">person.init();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">    name:&apos;jike&apos;,</span><br><span class="line">    init:() =&gt; &#123;</span><br><span class="line">        document.body.onclick = () =&gt; &#123;</span><br><span class="line">            alert(this.name);             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// init()箭头函数，其内部的this为全局window</span><br><span class="line">// onclick的this也就是init函数的this，也是window，得到的this.name就为undefined。</span><br><span class="line">person.init();</span><br></pre></td></tr></table></figure><ul><li>箭头函数不能作为构造函数，不能使用new。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//构造函数如下：</span><br><span class="line">function Person(p)&#123;</span><br><span class="line">    this.name = p.name;</span><br><span class="line">&#125;</span><br><span class="line">//如果用箭头函数作为构造函数，则如下</span><br><span class="line">var Person = (p) =&gt; &#123;</span><br><span class="line">    this.name = p.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于this必须是对象实例，而箭头函数是没有实例的，此处的this指向别处，不能产生person实例，自相矛盾。</span><br></pre></td></tr></table></figure><ul><li>箭头函数没有arguments，caller，callee</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let B = (b)=&gt;&#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">B(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined</span><br><span class="line"></span><br><span class="line">let C = (...c) =&gt; &#123;</span><br><span class="line">  console.log(c);</span><br><span class="line">&#125;</span><br><span class="line">C(3,82,32,11323);  // [3, 82, 32, 11323]</span><br></pre></td></tr></table></figure><ul><li>箭头函数通过call和apply调用，不会改变this指向，只会传入参数。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let obj2 = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    b: function(n) &#123;</span><br><span class="line">        let f = (n) =&gt; n + this.a;</span><br><span class="line">        return f(n);</span><br><span class="line">    &#125;,</span><br><span class="line">    c: function(n) &#123;</span><br><span class="line">        let f = (n) =&gt; n + this.a;</span><br><span class="line">        let m = &#123;</span><br><span class="line">            a: 20</span><br><span class="line">        &#125;;</span><br><span class="line">        return f.call(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj2.b(1));  // 11</span><br><span class="line">console.log(obj2.c(1)); // 11</span><br></pre></td></tr></table></figure><ul><li>箭头函数没有原型属性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = ()=&gt;&#123;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b()&#123;</span><br><span class="line">  return 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a.prototype);  // undefined</span><br><span class="line">console.log(b.prototype);   // &#123;constructor: ƒ&#125;</span><br></pre></td></tr></table></figure><ul><li><p>箭头函数不能作为Generator函数，不能使用yield关键字</p></li><li><p>箭头函数返回对象时，要加一个小括号</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var func = () =&gt; (&#123; foo: 1 &#125;); //正确</span><br><span class="line">var func = () =&gt; &#123; foo: 1 &#125;;   //错误</span><br></pre></td></tr></table></figure><ul><li>箭头函数在ES6 class中声明的方法为实例方法，不是原型方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//deom1</span><br><span class="line">class Super&#123;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">        //do some thing here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//通过Super.prototype可以访问到sayName方法，这种形式定义的方法，都是定义在prototype上</span><br><span class="line">var a = new Super()</span><br><span class="line">var b = new Super()</span><br><span class="line">a.sayName === b.sayName //true</span><br><span class="line">//所有实例化之后的对象共享prototypy上的sayName方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//demo2</span><br><span class="line">class Super&#123;</span><br><span class="line">    sayName =()=&gt;&#123;</span><br><span class="line">        //do some thing here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//通过Super.prototype访问不到sayName方法，该方法没有定义在prototype上</span><br><span class="line">var a = new Super()</span><br><span class="line">var b = new Super()</span><br><span class="line">a.sayName === b.sayName //false</span><br><span class="line">//实例化之后的对象各自拥有自己的sayName方法，比demo1需要更多的内存空间</span><br></pre></td></tr></table></figure><ul><li>多重箭头函数就是一个高阶函数，相当于内嵌函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const add = x =&gt; y =&gt; y + x;</span><br><span class="line">//相当于</span><br><span class="line">function add(x)&#123;</span><br><span class="line">  return function(y)&#123;</span><br><span class="line">    return y + x;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头函数常见错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: () =&gt; console.log(this.foo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.bar()  //undefined</span><br><span class="line"></span><br><span class="line">// bar函数中的this指向父作用域，而a对象没有作用域，因此this不是a，打印结果为undefined</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  this.foo = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.prototype.bar = () =&gt; console.log(this.foo)</span><br><span class="line"></span><br><span class="line">let a = new A()</span><br><span class="line">a.bar()  //undefined</span><br><span class="line"></span><br><span class="line">// 原型上使用箭头函数，this指向是其父作用域，并不是对象a，因此得不到预期结果。</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;箭头函数基本形式&quot;&gt;&lt;a href=&quot;#箭头函数基本形式&quot; class=&quot;headerlink&quot; title=&quot;箭头函数基本形式&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 作用域</title>
    <link href="https://liushuai97.github.io/2019/10/17/ES6-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://liushuai97.github.io/2019/10/17/ES6-作用域/</id>
    <published>2019-10-17T03:33:07.000Z</published>
    <updated>2019-10-17T06:13:41.703Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --><h4 id="什么是作用域？"><a href="#什么是作用域？" class="headerlink" title="什么是作用域？"></a>什么是作用域？</h4><p>任何编程语言都有作用域的概念，简单来说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。</p><p>JavaScript的作用域是靠函数来形成的，也就是说一个函数的变量在函数外不可以访问。</p><h4 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h4><p>任何地方都能访问到的对象拥有全局作用域。</p><ol><li>函数外面定义的变量拥有全局作用域</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var n = 2;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn());  // 1</span><br><span class="line">console.log(n); // 2</span><br><span class="line">console.log(a); //报错 a is not defined</span><br></pre></td></tr></table></figure><ol start="2"><li>未定义直接赋值的变量自动声明为拥有全局作用域</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var n = 2;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  a = 1;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn());  // 1</span><br><span class="line">console.log(n); // 2</span><br><span class="line">console.log(a); // 1</span><br></pre></td></tr></table></figure><ol start="3"><li>window对象的属性拥有全局作用</li></ol><h4 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h4><p>局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所以在一些地方会把这种作用域成为函数作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var n = 2;</span><br><span class="line">function fn()&#123;</span><br><span class="line">  var a = 1;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(fn());  // 1</span><br><span class="line">console.log(n); // 2</span><br><span class="line">console.log(a); //报错 a is not defined</span><br><span class="line"></span><br><span class="line">// a是函数内部声明并赋值，拥有局部作用域，只能带函数fn内部使用，在fn外部使用就会报错，这就是局部作用域的特性，外部无法访问。</span><br></pre></td></tr></table></figure><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>通俗的讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。</p><ol><li><p>当执行函数时，总是先从函数内部找寻局部变量。</p></li><li><p>如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，一次向上。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">  var a = 10;</span><br><span class="line">  function fn1()&#123;</span><br><span class="line">    var a = 20;</span><br><span class="line">    console.log(a); // 20</span><br><span class="line">  &#125;</span><br><span class="line">  function fn2()&#123;</span><br><span class="line">    console.log(a); // 10</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn1();</span><br><span class="line">  fn2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line">console.log(a) // 1</span><br></pre></td></tr></table></figure><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>提到作用域就不得不提到闭包，简单来讲，闭包外部函数能够读取内部函数的变量。</p><p>优点：闭包可以形成独立的空间，永久的保存局部变量。</p><p>缺点：保存中间值的状态缺点是容易造成内存泄漏，因为闭包中的局部变量永远不会被回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var n = 999;</span><br><span class="line">  nAdd = function () &#123;</span><br><span class="line">    n += 1;</span><br><span class="line">  &#125;</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line">var result = f1();</span><br><span class="line"></span><br><span class="line">result(); // 999</span><br><span class="line">nAdd(); // 执行 n += 1</span><br><span class="line">result(); // 1000</span><br></pre></td></tr></table></figure><h4 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h4><p>ES6引入了块级作用域，明确允许在块级作用域中声明函数，let和const命令都涉及块级作用域。块级作用域允许声明函数只在使用大括号的情况下成立，如果未使用大括号，会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// ES5 中作用域</span><br><span class="line">var callbacks = []</span><br><span class="line">for (var i = 0; i &lt;= 2; i++) &#123;</span><br><span class="line">    callbacks[i] = function() &#123;</span><br><span class="line">        return i * 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.table([</span><br><span class="line">    callbacks[0](),</span><br><span class="line">    callbacks[1](),</span><br><span class="line">    callbacks[2](),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">;((function() &#123;</span><br><span class="line">    const foo = function() &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;foo()===1&quot;, foo() === 1)</span><br><span class="line">    ;((function() &#123;</span><br><span class="line">        const foo = function() &#123;</span><br><span class="line">            return 2</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;foo()===2&quot;, foo() === 2)</span><br><span class="line">    &#125;)())</span><br><span class="line">&#125;)())</span><br><span class="line"></span><br><span class="line">// ES6中块级作用域</span><br><span class="line">const callbacks2 = []</span><br><span class="line">for (let j = 0; j &lt;= 2; j++) &#123;</span><br><span class="line">    callbacks2[j] = function() &#123;</span><br><span class="line">        return j * 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.table([</span><br><span class="line">    callbacks2[0](),</span><br><span class="line">    callbacks2[1](),</span><br><span class="line">    callbacks2[2](),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    function foo() &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    console.log(&quot;foo()===1&quot;, foo() === 1)</span><br><span class="line">    &#123;</span><br><span class="line">        function foo() &#123;</span><br><span class="line">            return 2</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        console.log(&quot;foo()===2&quot;, foo() === 2)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(&quot;foo()===1&quot;, foo() === 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Nov 27 2019 15:34:22 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;什么是作用域？&quot;&gt;&lt;a href=&quot;#什么是作用域？&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域？&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/categories/ES6/"/>
    
    
      <category term="ES6" scheme="https://liushuai97.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
