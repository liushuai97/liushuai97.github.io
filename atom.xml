<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随笔</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liushuai97.github.io/"/>
  <updated>2019-09-23T09:35:05.477Z</updated>
  <id>https://liushuai97.github.io/</id>
  
  <author>
    <name>前端菜鸟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript-自测题8</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%988/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题8/</id>
    <published>2019-09-23T09:30:52.000Z</published>
    <updated>2019-09-23T09:35:05.477Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="JavaScript-正则表达式"><a href="#JavaScript-正则表达式" class="headerlink" title="JavaScript 正则表达式"></a>JavaScript 正则表达式</h4><ul><li>语法</li></ul><p>/正则表达式主体/修饰符(可选)</p><ul><li>使用字符串方法</li></ul><p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p><ol><li><p>search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p></li><li><p>replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p></li></ol><h4 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h4><ul><li>修饰符可以在全局搜索中不区分大小写:</li></ul><table><thead><tr><th align="center">修饰符</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>执行对大小写不敏感的匹配。</td></tr><tr><td align="center">g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td align="center">m</td><td>执行多行匹配。</td></tr></tbody></table><h4 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h4><ul><li>方括号用于查找某个范围内的字符：</li></ul><table><thead><tr><th align="center">表达式</th><th>描述</th></tr></thead><tbody><tr><td align="center">[abc]</td><td>查找方括号之间的任何字符。</td></tr><tr><td align="center">[0-9]</td><td>查找任何从 0 至 9 的数字。</td></tr><tr><td align="center">(x</td><td>y)</td></tr></tbody></table><ul><li>元字符是拥有特殊含义的字符：</li></ul><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center">\d</td><td>查找数字。</td></tr><tr><td align="center">\s</td><td>查找空白字符。</td></tr><tr><td align="center">\b</td><td>匹配单词边界。</td></tr><tr><td align="center">\uxxxx</td><td>查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><ul><li>量词:</li></ul><table><thead><tr><th align="center">量词</th><th>描述</th></tr></thead><tbody><tr><td align="center">n+</td><td>匹配任何包含至少一个 n 的字符串。</td></tr><tr><td align="center">n*</td><td>匹配任何包含零个或多个 n 的字符串。</td></tr><tr><td align="center">n?</td><td>匹配任何包含零个或一个 n 的字符串。</td></tr></tbody></table><h4 id="使用-RegExp-对象"><a href="#使用-RegExp-对象" class="headerlink" title="使用 RegExp 对象"></a>使用 RegExp 对象</h4><p>在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。</p><h4 id="使用-test"><a href="#使用-test" class="headerlink" title="使用 test()"></a>使用 test()</h4><p>test() 方法是一个正则表达式方法。</p><p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p><h4 id="使用-exec"><a href="#使用-exec" class="headerlink" title="使用 exec()"></a>使用 exec()</h4><p>exec() 方法是一个正则表达式方法。</p><p>exec() 方法用于检索字符串中的正则表达式的匹配。</p><p>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;JavaScript-正则表达式&quot;&gt;&lt;a href=&quot;#JavaScript-正则表达式&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题7</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%987/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题7/</id>
    <published>2019-09-23T08:56:17.000Z</published>
    <updated>2019-09-23T09:16:56.186Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h4><p>String 对象方法</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">anchor()</td><td>创建 HTML 锚。</td></tr><tr><td align="center">big()</td><td>用大号字体显示字符串。</td></tr><tr><td align="center">blink()</td><td>显示闪动字符串。</td></tr><tr><td align="center">bold()</td><td>使用粗体显示字符串。</td></tr><tr><td align="center">charAt()</td><td>返回在指定位置的字符。</td></tr><tr><td align="center">charCodeAt()</td><td>返回在指定的位置的字符的 Unicode 编码。</td></tr><tr><td align="center">concat()</td><td>连接字符串。</td></tr><tr><td align="center">fixed()</td><td>以打字机文本显示字符串。</td></tr><tr><td align="center">fontcolor()</td><td>使用指定的颜色来显示字符串。</td></tr><tr><td align="center">fontsize()</td><td>使用指定的尺寸来显示字符串。</td></tr><tr><td align="center">fromCharCode()</td><td>从字符编码创建一个字符串。</td></tr><tr><td align="center">indexOf()</td><td>检索字符串。</td></tr><tr><td align="center">italics()</td><td>使用斜体显示字符串。</td></tr><tr><td align="center">lastIndexOf()</td><td>从后向前搜索字符串。</td></tr><tr><td align="center">link()</td><td>将字符串显示为链接。</td></tr><tr><td align="center">localeCompare()</td><td>用本地特定的顺序来比较两个字符串。</td></tr><tr><td align="center">match()</td><td>找到一个或多个正则表达式的匹配。</td></tr><tr><td align="center">replace()</td><td>替换与正则表达式匹配的子串。</td></tr><tr><td align="center">search()</td><td>检索与正则表达式相匹配的值。</td></tr><tr><td align="center">slice()</td><td>提取字符串的片断，并在新的字符串中返回被提取的部分。</td></tr><tr><td align="center">small()</td><td>使用小字号来显示字符串。</td></tr><tr><td align="center">split()</td><td>把字符串分割为字符串数组。</td></tr><tr><td align="center">strike()</td><td>使用删除线来显示字符串。</td></tr><tr><td align="center">sub()</td><td>把字符串显示为下标。</td></tr><tr><td align="center">substr()</td><td>从起始索引号提取字符串中指定数目的字符。</td></tr><tr><td align="center">substring()</td><td>提取字符串中两个指定的索引号之间的字符。</td></tr><tr><td align="center">sup()</td><td>把字符串显示为上标。</td></tr><tr><td align="center">toLocaleLowerCase()</td><td>把字符串转换为小写。</td></tr><tr><td align="center">toLocaleUpperCase()</td><td>把字符串转换为大写。</td></tr><tr><td align="center">toLowerCase()</td><td>把字符串转换为小写。</td></tr><tr><td align="center">toUpperCase()</td><td>把字符串转换为大写。</td></tr><tr><td align="center">toSource()</td><td>代表对象的源代码。</td></tr><tr><td align="center">toString()</td><td>返回字符串。</td></tr><tr><td align="center">valueOf()</td><td>返回某个字符串对象的原始值。</td></tr></tbody></table><h4 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h4><p>Array 对象方法</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">concat()</td><td>连接两个或更多的数组，并返回结果。</td></tr><tr><td align="center">join()</td><td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td></tr><tr><td align="center">pop()</td><td>删除并返回数组的最后一个元素</td></tr><tr><td align="center">push()</td><td>向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="center">reverse()</td><td>颠倒数组中元素的顺序。</td></tr><tr><td align="center">shift()</td><td>删除并返回数组的第一个元素</td></tr><tr><td align="center">slice()</td><td>从某个已有的数组返回选定的元素</td></tr><tr><td align="center">sort()</td><td>对数组的元素进行排序</td></tr><tr><td align="center">splice()</td><td>删除元素，并向数组添加新元素。</td></tr><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">toString()</td><td>把数组转换为字符串，并返回结果。</td></tr><tr><td align="center">toLocaleString()</td><td>把数组转换为本地数组，并返回结果。</td></tr><tr><td align="center">unshift()</td><td>向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="center">valueOf()</td><td>返回数组对象的原始值</td></tr></tbody></table><h4 id="常用数组-字符串方法与遍历"><a href="#常用数组-字符串方法与遍历" class="headerlink" title="常用数组/字符串方法与遍历"></a>常用数组/字符串方法与遍历</h4><p>javascript有很多遍历的方法，for、for in、for of（ES6）、forEach、map、filter、every、some、Jquery的each等等。</p><ol><li>for 循环</li></ol><p>for循环语句，最基础的遍历，以数组的下标为索引，对数组元素进行遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrFor(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      for (var k = 0; k &lt; arr.length; k++) &#123;</span><br><span class="line">          ret += arr[k];</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array for 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array for 报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for 循环不是函数，不存在返回值。</li></ul><ol start="2"><li>for in</li></ol><p>for in循环不仅可以遍历数组，还可以遍历对象，但for in存在一些陷阱，比如它会在遍历完元素之后，还会对数组或对象的prototype中的属性进行遍历，所以，for in 更像是为对象遍历而设计的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrForIn(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      for (var k in arr) &#123;</span><br><span class="line">          ret += arr[k];</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array for in 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array for in报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>for of (ES6)</li></ol><p>ES6中引入了 for … of 循环，以替代 for…in 和 forEach() ，允许对 Array(数组)、String(字符串)、Maps(映射)、Sets(集合)等可迭代的数据结构进行遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrForOf(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      for(var k of arr) &#123;</span><br><span class="line">          ret += k;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array for of 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array for of报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for(var k of arr) 中的 k ，就是数组 arr 中的元素，而不是数组的下标。</li><li>IE 不支持，Edge支持。</li></ul><ol start="4"><li>forEach</li></ol><p>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrForEach(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      arr.forEach(function (v, k) &#123;</span><br><span class="line">          ret += v;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array forEach 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array forEach报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>forEach() 对于空数组是不会执行回调函数的。</p></li><li><p>回调函数 function (v, k) 中的 k 是数组的下标，v 是数组元素值。</p></li><li><p>IE9以下的版本不支持。</p><ol start="5"><li>map</li></ol><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrMap(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      arr.map(function (v, k) &#123;</span><br><span class="line">          ret += v;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array map 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array map报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map() 返回一个新数组。</li><li>map() 不会对空数组进行检测。</li><li>map() 不会改变原始数组。</li></ul><ol start="6"><li>filter</li></ol><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrFilter(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      arr.filter(function (v, k) &#123;</span><br><span class="line">          ret += v;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array filter 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array filter报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>filter() 不会对空数组进行检测。</li><li>filter() 不会改变原始数组。</li></ul><ol start="7"><li>every</li></ol><p>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供），返回 boolen。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function arrEvery(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var st = performance.now();</span><br><span class="line">      var ret = arr.every(function (v, k) &#123;</span><br><span class="line">          return v.length &gt; 1;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array every 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array every报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li><li>如果所有元素都满足条件，则返回 true。</li><li>every() 不会对空数组进行检测。</li><li>every() 不会改变原始数组。</li></ul><ol start="8"><li>some</li></ol><p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。只要有一个元素满足则返回true，并不再继续往下判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function arrSome(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var st = performance.now();</span><br><span class="line">      var ret = arr.some(function (v, k) &#123;</span><br><span class="line">          return v.length &gt; 1;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array some 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array some报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。</li><li>如果没有满足条件的元素，则返回false。</li><li>some() 不会对空数组进行检测。</li><li>some() 不会改变原始数组。</li></ul><ol start="9"><li>Object.keys.forEach</li></ol><p>Object.keys.forEach() 主要是用于遍历对象，获取对象的属性名，对于遍历数组意义不大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function objectKey(obj) &#123;</span><br><span class="line">  try&#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      Object.keys(obj).forEach(function(key, index, arr) &#123;</span><br><span class="line">          ret += obj[key];</span><br><span class="line">      &#125;);</span><br><span class="line">      //ES6写法</span><br><span class="line">      //Object.keys(obj).forEach(k =&gt; &#123;</span><br><span class="line">      //    ret += obj[k];</span><br><span class="line">      //&#125;);　</span><br><span class="line">      console.log(ret);</span><br><span class="line">      let diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;object key 总耗时：&quot; + diff);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (e)&#123;</span><br><span class="line">      console.log(&quot;object key 报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Object.keys.forEach 在遍历时，回调函数的参数 key是属性名（对于数组，属性名和索引一一对应)，index 是keys数组的索引，arr是keys数组；所以在取值的时候还是用 obj[key]</p></li><li><p>例题：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a =&apos;abc&apos;</span><br><span class="line">a.split().every(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;);</span><br><span class="line">a.split().map(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;)</span><br><span class="line">a.split().forEach(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;)</span><br><span class="line">a.split().filter(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;String-对象&quot;&gt;&lt;a href=&quot;#String-对象&quot; class=&quot;headerlink&quot; title=&quot;String 对象
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题6</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%986/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题6/</id>
    <published>2019-09-23T08:52:11.000Z</published>
    <updated>2019-09-23T09:02:12.078Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h4><p>Math 对象用于执行数学任务。</p><p>使用 Math 的属性和方法的语法：<br>var pi_value=Math.PI;<br>var sqrt_value=Math.sqrt(15);<br>注释：Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。</p><h4 id="Math-对象属性"><a href="#Math-对象属性" class="headerlink" title="Math 对象属性"></a>Math 对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">E</td><td>返回算术常量 e，即自然对数的底数（约等于2.718）。</td></tr><tr><td align="center">LN2</td><td>返回 2 的自然对数（约等于0.693）。</td></tr><tr><td align="center">LN10</td><td>返回 10 的自然对数（约等于2.302）。</td></tr><tr><td align="center">LOG2E</td><td>返回以 2 为底的 e 的对数（约等于 1.414）。</td></tr><tr><td align="center">LOG10E</td><td>返回以 10 为底的 e 的对数（约等于0.434）。</td></tr><tr><td align="center">PI</td><td>返回圆周率（约等于3.14159）。</td></tr><tr><td align="center">SQRT1_2</td><td>返回返回 2 的平方根的倒数（约等于 0.707）。</td></tr><tr><td align="center">SQRT2</td><td>返回 2 的平方根（约等于 1.414）。</td></tr></tbody></table><h4 id="Math-对象方法"><a href="#Math-对象方法" class="headerlink" title="Math 对象方法"></a>Math 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">abs(x)</td><td>返回数的绝对值。</td></tr><tr><td align="center">acos(x)</td><td>返回数的反余弦值。</td></tr><tr><td align="center">asin(x)</td><td>返回数的反正弦值。</td></tr><tr><td align="center">atan(x)</td><td>以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td></tr><tr><td align="center">atan2(y,x)</td><td>返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。</td></tr><tr><td align="center">ceil(x)</td><td>对数进行上舍入。</td></tr><tr><td align="center">cos(x)</td><td>返回数的余弦。</td></tr><tr><td align="center">exp(x)</td><td>返回 e 的指数。</td></tr><tr><td align="center">floor(x)</td><td>对数进行下舍入。</td></tr><tr><td align="center">log(x)</td><td>返回数的自然对数（底为e）。</td></tr><tr><td align="center">max(x,y)</td><td>返回 x 和 y 中的最高值。</td></tr><tr><td align="center">min(x,y)</td><td>返回 x 和 y 中的最低值。</td></tr><tr><td align="center">pow(x,y)</td><td>返回 x 的 y 次幂。</td></tr><tr><td align="center">random()</td><td>返回 0 ~ 1 之间的随机数。</td></tr><tr><td align="center">round(x)</td><td>把数四舍五入为最接近的整数。</td></tr><tr><td align="center">sin(x)</td><td>返回数的正弦。</td></tr><tr><td align="center">sqrt(x)</td><td>返回数的平方根。</td></tr><tr><td align="center">tan(x)</td><td>返回角的正切。</td></tr><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">valueOf()</td><td>返回 Math 对象的原始值。</td></tr></tbody></table><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function lv (num) &#123;</span><br><span class="line">  var lv = 11 - Math.ceil(num/10);</span><br><span class="line">  console.log(lv + &apos;等生&apos;);</span><br><span class="line">&#125;</span><br><span class="line">lv(91)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;Math-对象&quot;&gt;&lt;a href=&quot;#Math-对象&quot; class=&quot;headerlink&quot; title=&quot;Math 对象&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题5</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%985/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题5/</id>
    <published>2019-09-23T08:12:09.000Z</published>
    <updated>2019-09-23T08:30:12.606Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><ul><li><p>栈：栈，只允许在一段进行插入或者删除操作的线性表，是一种先进后出的数据结构。</p></li><li><p>堆：堆是基于散列算法的数据结构。</p></li><li><p>队列：队列是一种先进先出（FIFO）的数据结构。</p></li></ul><h4 id="JavaScript中数据类型的存储"><a href="#JavaScript中数据类型的存储" class="headerlink" title="JavaScript中数据类型的存储"></a>JavaScript中数据类型的存储</h4><p>JavaScript中将数据类型分为基本数据类型和引用数据类型，它们其中有一个区别就是存储的位置不同。</p><ul><li>基本数据类型</li></ul><p>我们都知道JavaScript中的基本数据类型有：</p><p>String<br>Number<br>Boolean<br>Undefined<br>Null<br>Symbol（暂时不管）<br>基本数据类型都是一些简单的数据段，它们是存储在栈内存中。</p><ul><li>引用数据类型</li></ul><p>JavaScript中的引用数据类型有：</p><p>Array<br>Object<br>引用数据类型是保存在堆内存中的，然后再栈内存中保存一个对堆内存中实际对象的引用。所以，JavaScript中对引用数据类型的操作都是操作对象的引用而不是实际的对象。</p><p>可以理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的。</p><p><img src="ti6.png" alt="kyrie irving"></p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul><li>基本数据类型</li></ul><p>对于基本数据类型，如果进行复制，系统会自动为新的变量在栈内存中分配一个新值，很容易理解。</p><ul><li>引用数据类型</li></ul><p>如果对于数组、对象这样的引用数据类型而言，复制的时候就会有所区别了：</p><p>系统也会自动为新的变量在栈内存中分配一个值，但这个值仅仅是一个地址。也就是说，复制出来的变量和原有的变量具有相同的地址值，指向堆内存中的同一个对象。</p><p><img src="ti7.png" alt="kyrie irving"></p><ul><li>为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？</li></ul><ol><li>堆比栈大，栈比对速度快。</li><li>基础数据类型比较稳定，而且相对来说占用的内存小。</li><li>引用数据类型大小是动态的，而且是无限的。</li><li>堆内存是无序存储，可以根据引用直接获取。</li></ol><ul><li>例题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test (m) &#123;</span><br><span class="line">  m = &#123; v: 5 &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var m = &#123; k: 30 &#125;;</span><br><span class="line">test(m);</span><br><span class="line">alert(m.v);</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti8.png" alt="kyrie irving"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;基本数据结构&quot;&gt;&lt;a href=&quot;#基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;基本数据结构&quot;&gt;&lt;/a&gt;基本数
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题4</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%984/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题4/</id>
    <published>2019-09-23T07:18:49.000Z</published>
    <updated>2019-09-23T08:39:42.033Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h4><ul><li>Document 对象集合</li></ul><table><thead><tr><th align="center">集合</th><th>描述</th></tr></thead><tbody><tr><td align="center">all[]</td><td>提供对文档中所有 HTML 元素的访问。</td></tr><tr><td align="center">anchors[]</td><td>返回对文档中所有 Anchor 对象的引用。</td></tr><tr><td align="center">applets</td><td>返回对文档中所有 Applet 对象的引用。</td></tr><tr><td align="center">forms[]</td><td>返回对文档中所有 Form 对象引用。</td></tr><tr><td align="center">images[]</td><td>返回对文档中所有 Image 对象引用。</td></tr><tr><td align="center">links[]</td><td>返回对文档中所有 Area 和 Link 对象引用。</td></tr></tbody></table><ul><li>Document 对象属性</li></ul><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">body</td><td>提供对<body>元素的直接访问。对于定义了框架集的文档，该属性引用最外层的<frameset>。</frameset></body></td></tr><tr><td align="center">cookie</td><td>设置或返回与当前文档有关的所有 cookie。</td></tr><tr><td align="center">domain</td><td>返回当前文档的域名。</td></tr><tr><td align="center">lastModified</td><td>返回文档被最后修改的日期和时间。</td></tr><tr><td align="center">referrer</td><td>返回载入当前文档的文档的 URL。</td></tr><tr><td align="center">title</td><td>返回当前文档的标题。</td></tr><tr><td align="center">URL</td><td>返回当前文档的 URL。</td></tr></tbody></table><ul><li>Document 对象方法</li></ul><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">close()</td><td>关闭用 document.open() 方法打开的输出流，并显示选定的数据。</td></tr><tr><td align="center">getElementById()</td><td>返回对拥有指定 id 的第一个对象的引用。</td></tr><tr><td align="center">getElementsByName()</td><td>返回带有指定名称的对象集合。</td></tr><tr><td align="center">getElementsByTagName()</td><td>返回带有指定标签名的对象集合。</td></tr><tr><td align="center">open()</td><td>打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。</td></tr><tr><td align="center">write()</td><td>向文档写 HTML 表达式 或 JavaScript 代码。</td></tr><tr><td align="center">writeln()</td><td>等同于 write() 方法，不同的是在每个表达式之后写一个换行符。</td></tr></tbody></table><h4 id="Element-对象"><a href="#Element-对象" class="headerlink" title="Element 对象"></a>Element 对象</h4><table><thead><tr><th align="center">属性 / 方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">element.accessKey</td><td>设置或返回元素的快捷键。</td></tr><tr><td align="center">element.appendChild()</td><td>向元素添加新的子节点，作为最后一个子节点。</td></tr><tr><td align="center">element.attributes</td><td>返回元素属性的 NamedNodeMap。</td></tr><tr><td align="center">element.childNodes</td><td>返回元素子节点的 NodeList。</td></tr><tr><td align="center">element.className</td><td>设置或返回元素的 class 属性。</td></tr><tr><td align="center">element.clientHeight</td><td>返回元素的可见高度。</td></tr><tr><td align="center">element.clientWidth</td><td>返回元素的可见宽度。</td></tr><tr><td align="center">element.cloneNode()</td><td>克隆元素。</td></tr><tr><td align="center">element.compareDocumentPosition()</td><td>比较两个元素的文档位置。</td></tr><tr><td align="center">element.contentEditable</td><td>设置或返回元素的文本方向。</td></tr><tr><td align="center">element.dir</td><td>设置或返回元素的内容是否可编辑。</td></tr><tr><td align="center">element.firstChild</td><td>返回元素的首个子。</td></tr><tr><td align="center">element.getAttribute()</td><td>返回元素节点的指定属性值。</td></tr><tr><td align="center">element.getAttributeNode()</td><td>返回指定的属性节点。</td></tr><tr><td align="center">element.getElementsByTagName()</td><td>返回拥有指定标签名的所有子元素的集合。</td></tr><tr><td align="center">element.getFeature()</td><td>返回实现了指定特性的 API 的某个对象。</td></tr><tr><td align="center">element.getUserData()</td><td>返回关联元素上键的对象。</td></tr><tr><td align="center">element.hasAttribute()</td><td>如果元素拥有指定属性，则返回true，否则返回 false。</td></tr><tr><td align="center">element.hasAttributes()</td><td>如果元素拥有属性，则返回 true，否则返回 false。</td></tr><tr><td align="center">element.hasChildNodes()</td><td>如果元素拥有子节点，则返回 true，否则 false。</td></tr><tr><td align="center">element.id</td><td>设置或返回元素的 id。</td></tr><tr><td align="center">element.innerHTML</td><td>设置或返回元素的内容。</td></tr><tr><td align="center">element.insertBefore()</td><td>在指定的已有的子节点之前插入新节点。</td></tr><tr><td align="center">element.isContentEditable</td><td>设置或返回元素的内容。</td></tr><tr><td align="center">element.isDefaultNamespace()</td><td>如果指定的 namespaceURI 是默认的，则返回 true，否则返回 false。</td></tr><tr><td align="center">element.isEqualNode()</td><td>检查两个元素是否相等。</td></tr><tr><td align="center">element.isSameNode()</td><td>检查两个元素是否是相同的节点。</td></tr><tr><td align="center">element.isSupported()</td><td>如果元素支持指定特性，则返回 true。</td></tr><tr><td align="center">element.lang</td><td>设置或返回元素的语言代码。</td></tr><tr><td align="center">element.lastChild</td><td>返回元素的最后一个子元素。</td></tr><tr><td align="center">element.namespaceURI</td><td>返回元素的 namespace URI。</td></tr><tr><td align="center">element.nextSibling</td><td>返回位于相同节点树层级的下一个节点。</td></tr><tr><td align="center">element.nodeName</td><td>返回元素的名称。</td></tr><tr><td align="center">element.nodeType</td><td>返回元素的节点类型。</td></tr><tr><td align="center">element.nodeValue</td><td>设置或返回元素值。</td></tr><tr><td align="center">element.normalize()</td><td>合并元素中相邻的文本节点，并移除空的文本节点。</td></tr><tr><td align="center">element.offsetHeight</td><td>返回元素的高度。</td></tr><tr><td align="center">element.offsetWidth</td><td>返回元素的宽度。</td></tr><tr><td align="center">element.offsetLeft</td><td>返回元素的水平偏移位置。</td></tr><tr><td align="center">element.offsetParent</td><td>返回元素的偏移容器。</td></tr><tr><td align="center">element.offsetTop</td><td>返回元素的垂直偏移位置。</td></tr><tr><td align="center">element.ownerDocument</td><td>返回元素的根元素（文档对象）。</td></tr><tr><td align="center">element.parentNode</td><td>返回元素的父节点。</td></tr><tr><td align="center">element.previousSibling</td><td>返回位于相同节点树层级的前一个元素。</td></tr><tr><td align="center">element.removeAttribute()</td><td>从元素中移除指定属性。</td></tr><tr><td align="center">element.removeAttributeNode()</td><td>移除指定的属性节点，并返回被移除的节点。</td></tr><tr><td align="center">element.removeChild()</td><td>从元素中移除子节点。</td></tr><tr><td align="center">element.replaceChild()</td><td>替换元素中的子节点。</td></tr><tr><td align="center">element.scrollHeight</td><td>返回元素的整体高度。</td></tr><tr><td align="center">element.scrollLeft</td><td>返回元素左边缘与视图之间的距离。</td></tr><tr><td align="center">element.scrollTop</td><td>返回元素上边缘与视图之间的距离。</td></tr><tr><td align="center">element.scrollWidth</td><td>返回元素的整体宽度。</td></tr><tr><td align="center">element.setAttribute()</td><td>把指定属性设置或更改为指定值。</td></tr><tr><td align="center">element.setAttributeNode()</td><td>设置或更改指定属性节点。</td></tr><tr><td align="center">element.setIdAttribute()</td><td>预留</td></tr><tr><td align="center">element.setIdAttributeNode()</td><td>预留</td></tr><tr><td align="center">element.setUserData()</td><td>把对象关联到元素上的键。</td></tr><tr><td align="center">element.style</td><td>设置或返回元素的 style 属性。</td></tr><tr><td align="center">element.tabIndex</td><td>设置或返回元素的 tab 键控制次序。</td></tr><tr><td align="center">element.tagName</td><td>返回元素的标签名。</td></tr><tr><td align="center">element.textContent</td><td>设置或返回节点及其后代的文本内容。</td></tr><tr><td align="center">element.title</td><td>设置或返回元素的 title 属性。</td></tr><tr><td align="center">element.toString()</td><td>把元素转换为字符串。</td></tr><tr><td align="center">nodelist.item()</td><td>返回 NodeList 中位于指定下标的节点。</td></tr><tr><td align="center">nodelist.length</td><td>返回 NodeList 中的节点数。</td></tr></tbody></table><h4 id="Attr-对象"><a href="#Attr-对象" class="headerlink" title="Attr 对象"></a>Attr 对象</h4><table><thead><tr><th align="center">属性 / 方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">attr.isId</td><td>如果属性是 id 类型，则返回 true，否则返回 false。</td></tr><tr><td align="center">attr.name</td><td>返回属性的名称。</td></tr><tr><td align="center">attr.value</td><td>设置或返回属性的值。</td></tr><tr><td align="center">attr.specified</td><td>如果已指定属性，则返回 true，否则返回 false。</td></tr><tr><td align="center">nodemap.getNamedItem()</td><td>从 NamedNodeMap 返回指定的属性节点。</td></tr><tr><td align="center">nodemap.item()</td><td>返回 NamedNodeMap 中位于指定下标的节点。</td></tr><tr><td align="center">nodemap.length</td><td>返回 NamedNodeMap 中的节点数。</td></tr><tr><td align="center">nodemap.removeNamedItem()</td><td>移除指定的属性节点。</td></tr><tr><td align="center">nodemap.setNamedItem()</td><td>设置指定的属性节点（通过名称）。</td></tr></tbody></table><ul><li>DOM 4 警告！</li></ul><p>在 W3C DOM Core 中，Attr (attribute) 对象从 Node 对象继承所有属性和方法。</p><p>在 DOM 4 中，Attr 对象不再从 Node 继承。</p><p>为了保证未来的代码安全，您应该避免在属性对象上使用节点对象的属性和方法：</p><table><thead><tr><th align="center">属性 / 方法</th><th>避免的理由</th></tr></thead><tbody><tr><td align="center">attr.appendChild()</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.attributes</td><td>属性没有属性。</td></tr><tr><td align="center">attr.baseURI</td><td>使用 document.baseURI 代替。</td></tr><tr><td align="center">attr.childNodes</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.cloneNode()</td><td>使用 attr.value 代替。</td></tr><tr><td align="center">attr.firstChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.hasAttributes()</td><td>属性没有属性。</td></tr><tr><td align="center">attr.hasChildNodes</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.insertBefore()</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.isEqualNode()</td><td>没有意义。</td></tr><tr><td align="center">attr.isSameNode()</td><td>没有意义。</td></tr><tr><td align="center">attr.isSupported()</td><td>始终为 true。</td></tr><tr><td align="center">attr.lastChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.nextSibling</td><td>属性没有同级节点。</td></tr><tr><td align="center">attr.nodeName</td><td>使用 attr.name 代替。</td></tr><tr><td align="center">attr.nodeType</td><td>始终为 2 (ATTRIBUTE_NODE)。</td></tr><tr><td align="center">attr.nodeValue</td><td>使用 attr.value 代替。</td></tr><tr><td align="center">attr.normalize()</td><td>属性无法被正常化。</td></tr><tr><td align="center">attr.ownerDocument</td><td>始终是您的 HTML 文档。</td></tr><tr><td align="center">attr.ownerElement</td><td>这是您用来访问该属性的 HTML 元素。</td></tr><tr><td align="center">attr.parentNode</td><td>这是您用来访问该属性的 HTML 元素。</td></tr><tr><td align="center">attr.previousSibling</td><td>属性没有同级节点。</td></tr><tr><td align="center">attr.removeChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.replaceChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.textContent</td><td>使用 attr.value 代替。</td></tr></tbody></table><h4 id="Event-对象"><a href="#Event-对象" class="headerlink" title="Event 对象"></a>Event 对象</h4><p>Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p><p>事件通常与函数结合使用，函数不会在事件发生前被执行！</p><ul><li>事件句柄　(Event Handlers)</li></ul><p>HTML 4.0 的新特性之一是能够使 HTML 事件触发浏览器中的行为，比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，可将之插入 HTML 标签以定义事件的行为。</p><table><thead><tr><th align="center">属性</th><th>此事件发生在何时…</th></tr></thead><tbody><tr><td align="center">onabort</td><td>图像的加载被中断。</td></tr><tr><td align="center">onblur</td><td>元素失去焦点。</td></tr><tr><td align="center">onchange</td><td>域的内容被改变。</td></tr><tr><td align="center">onclick</td><td>当用户点击某个对象时调用的事件句柄。</td></tr><tr><td align="center">ondblclick</td><td>当用户双击某个对象时调用的事件句柄。</td></tr><tr><td align="center">onerror</td><td>在加载文档或图像时发生错误。</td></tr><tr><td align="center">onfocus</td><td>元素获得焦点。</td></tr><tr><td align="center">onkeydown</td><td>某个键盘按键被按下。</td></tr><tr><td align="center">onkeypress</td><td>某个键盘按键被按下并松开。</td></tr><tr><td align="center">onkeyup</td><td>某个键盘按键被松开。</td></tr><tr><td align="center">onload</td><td>一张页面或一幅图像完成加载。</td></tr><tr><td align="center">onmousedown</td><td>鼠标按钮被按下。</td></tr><tr><td align="center">onmousemove</td><td>鼠标被移动。</td></tr><tr><td align="center">onmouseout</td><td>鼠标从某元素移开。</td></tr><tr><td align="center">onmouseover</td><td>鼠标移到某元素之上。</td></tr><tr><td align="center">onmouseup</td><td>鼠标按键被松开。</td></tr><tr><td align="center">onreset</td><td>重置按钮被点击。</td></tr><tr><td align="center">onresize</td><td>窗口或框架被重新调整大小。</td></tr><tr><td align="center">onselect</td><td>文本被选中。</td></tr><tr><td align="center">onsubmit</td><td>确认按钮被点击。</td></tr><tr><td align="center">onunload</td><td>用户退出页面。</td></tr></tbody></table><ul><li>鼠标 / 键盘属性</li></ul><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">altKey</td><td>返回当事件被触发时，”ALT” 是否被按下。</td></tr><tr><td align="center">button</td><td>返回当事件被触发时，哪个鼠标按钮被点击。</td></tr><tr><td align="center">clientX</td><td>返回当事件被触发时，鼠标指针的水平坐标。</td></tr><tr><td align="center">clientY</td><td>返回当事件被触发时，鼠标指针的垂直坐标。</td></tr><tr><td align="center">ctrlKey</td><td>返回当事件被触发时，”CTRL” 键是否被按下。</td></tr><tr><td align="center">metaKey</td><td>返回当事件被触发时，”meta” 键是否被按下。</td></tr><tr><td align="center">relatedTarget</td><td>返回与事件的目标节点相关的节点。</td></tr><tr><td align="center">screenX</td><td>返回当某个事件被触发时，鼠标指针的水平坐标。</td></tr><tr><td align="center">screenY</td><td>返回当某个事件被触发时，鼠标指针的垂直坐标。</td></tr><tr><td align="center">shiftKey</td><td>返回当事件被触发时，”SHIFT” 键是否被按下。</td></tr></tbody></table><ul><li>IE 属性<br>除了上面的鼠标/事件属性，IE 浏览器还支持下面的属性：</li></ul><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">cancelBubble</td><td>如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。</td></tr><tr><td align="center">fromElement</td><td>对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。</td></tr><tr><td align="center">keyCode</td><td>对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup 事件，它指定了被敲击的键的虚拟键盘码。虚拟键盘码可能和使用的键盘的布局相关。</td></tr><tr><td align="center">offsetX,offsetY</td><td>发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。</td></tr><tr><td align="center">returnValue</td><td>如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 fasle，可以取消发生事件的源元素的默认动作。</td></tr><tr><td align="center">srcElement</td><td>对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。</td></tr><tr><td align="center">toElement</td><td>对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。</td></tr><tr><td align="center">x,y</td><td>事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。</td></tr></tbody></table><ul><li>标准 Event 属性<br>下面列出了 2 级 DOM 事件标准定义的属性。</li></ul><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">bubbles</td><td>返回布尔值，指示事件是否是起泡事件类型。</td></tr><tr><td align="center">cancelable</td><td>返回布尔值，指示事件是否可拥可取消的默认动作。</td></tr><tr><td align="center">currentTarget</td><td>返回其事件监听器触发该事件的元素。</td></tr><tr><td align="center">eventPhase</td><td>返回事件传播的当前阶段。</td></tr><tr><td align="center">target</td><td>返回触发此事件的元素（事件的目标节点）。</td></tr><tr><td align="center">timeStamp</td><td>返回事件生成的日期和时间。</td></tr><tr><td align="center">type</td><td>返回当前 Event 对象表示的事件的名称。</td></tr></tbody></table><ul><li>标准 Event 方法<br>下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法：</li></ul><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">initEvent()</td><td>初始化新创建的 Event 对象的属性。</td></tr><tr><td align="center">preventDefault()</td><td>通知浏览器不要执行与事件关联的默认动作。</td></tr><tr><td align="center">stopPropagation()</td><td>不再派发事件。</td></tr></tbody></table><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &lt;ul&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;6&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var list_li = document.getElementsByTagName(&quot;li&quot;);</span><br><span class="line">  for(let i = 0; i &lt; list_li.length; i++) &#123;</span><br><span class="line">    list_li[i].onclick = function () &#123;</span><br><span class="line">      console.log(i + 1);</span><br><span class="line">      console.log(this.innerText);</span><br><span class="line">      console.log(this.innerHTML);</span><br><span class="line">      console.log(list_li[i].childNodes[0].nodeValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;Document对象&quot;&gt;&lt;a href=&quot;#Document对象&quot; class=&quot;headerlink&quot; title=&quot;Documen
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题3</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%983/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题3/</id>
    <published>2019-09-23T05:50:51.000Z</published>
    <updated>2019-09-23T08:46:17.336Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h4><ol><li><p>不允许使用未声明的变量</p></li><li><p>不允许删除变量或对象。</p></li><li><p>不允许删除函数。</p></li><li><p>不允许变量重名。</p></li><li><p>不允许使用八进制。</p></li><li><p>不允许使用转义字符。</p></li><li><p>不允许对只读属性赋值。</p></li><li><p>不允许对一个使用getter方法读取的属性进行赋值。</p></li><li><p>不允许删除一个不允许删除的属性。</p></li><li><p>变量名不能使用 “eval” 字符串。</p></li><li><p>变量名不能使用 “arguments” 字符串。</p></li><li><p>不允许使用以下这种语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">with (Math)&#123;x = cos(2)&#125;; // 报错</span><br></pre></td></tr></table></figure></li><li><p>由于一些安全原因，在作用域 eval() 创建的变量不能被调用</p></li><li><p>禁止this关键字指向全局对象。</p></li><li><p>禁止使用保留关键字or关键词。</p></li></ol><h4 id="立即执行函数（IIFE）"><a href="#立即执行函数（IIFE）" class="headerlink" title="立即执行函数（IIFE）"></a>立即执行函数（IIFE）</h4><p>在第一部分中提到IIFE实际是为了解决作用域缺陷而诞生的，那么它的诞生给我们带来了哪些好处呢？</p><ul><li><p>不必为函数命名，避免了污染全局变量；</p></li><li><p>IIFE内部形成了单独的作用域，可以封住一些外部无法读取的私有变量。</p></li></ul><h4 id="i和i-区别在于运算顺序和结合方向。"><a href="#i和i-区别在于运算顺序和结合方向。" class="headerlink" title="++i和i++区别在于运算顺序和结合方向。"></a>++i和i++区别在于运算顺序和结合方向。</h4><p>js中有两种自加运算，其运算符均为++，功能为将运算符自加1.<br>其中：<br>++VAR被称为前自加，其后面的变量执行自加操作，其运算为，先执行自加操作，再引用VAR值。<br>VAR++被称为后自加，其前面的变量执行自加操作，其运算为，先引用VAR值，再进行自加操作。</p><p>如果自加语句独立成为一个单独的语句，那么前后自加是完全相同的。<br>比如单独的一行<br>a++;和++a;是一样的。<br>再比如，常见的for循环:<br>for(i = 0; i &lt; 100; i ++)<br>for(i = 0; i &lt; 100; ++i)<br>这里用到的++i和i++是完全相同的，没有区别。</p><p>当运算变量本身值会在自加语句中，同时执行其它操作，二者就有区别了。<br>比如<br>var i =0;<br>while(i++&lt;10);<br>i会先和10比较大小，然后执行自加。这样当i=10时，退出循环，再执行一次自加，退出后i值为11。<br>而如果写成<br>while(++i&lt;10);<br>是先执行自加，然后再与10比较。这样在i=9时，先自加，得到i=10,然后比较就会退出循环了。这种情况下，退出后i值为10。</p><p>再举一个例子。<br>var a, i = 10;<br>a = i ++; //这里i要先赋值，再自加。语句执行后a=10, i = 11;<br>而如果写成：<br>var a, i = 10;<br>a = ++i; //这里i要先自加，再赋值。语句执行后a=11, i = 11;</p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var num = 1;</span><br><span class="line">function test() &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  console.log(this.num++);</span><br><span class="line">&#125;</span><br><span class="line">function test2() &#123;</span><br><span class="line">  console.log(++this.num);</span><br><span class="line">&#125;</span><br><span class="line">(function()&#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  test2();</span><br><span class="line">&#125;)();</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti4.png" alt="kyrie irving"></p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function C1(name) &#123;</span><br><span class="line">  if(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function C2(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">function C3(name) &#123;</span><br><span class="line">  this.name = name || &apos;fe&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">C1.prototype.name = &quot;zhang&quot;;</span><br><span class="line">C2.prototype.name = &quot;wang&quot;;</span><br><span class="line">C3.prototype.name = &quot;li&quot;;</span><br><span class="line">console.log((new C1().name) + (new C2().name) + (new C3().name))</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti5.png" alt="kyrie irving"></p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function test () &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;;</span><br><span class="line">(function()&#123;</span><br><span class="line">if(false)&#123;</span><br><span class="line">  function test()&#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">&#125;)();</span><br><span class="line">// 立即执行函数   函数作用域</span><br><span class="line">// test is not a function</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;严格模式的限制&quot;&gt;&lt;a href=&quot;#严格模式的限制&quot; class=&quot;headerlink&quot; title=&quot;严格模式的限制&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 自测题2</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%982/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题2/</id>
    <published>2019-09-23T02:10:26.000Z</published>
    <updated>2019-09-23T05:45:17.720Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="this的取值"><a href="#this的取值" class="headerlink" title="this的取值"></a>this的取值</h4><p>在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。</p><h4 id="this的4种绑定规则"><a href="#this的4种绑定规则" class="headerlink" title="this的4种绑定规则"></a>this的4种绑定规则</h4><ul><li>全局环境中，this默认绑定到window</li><li>函数独立调用时，this默认绑定到window</li><li>被嵌套的函数独立调用时，this默认绑定到window</li><li>IIFE立即执行函数实际上是函数声明后直接调用执行</li><li>闭包（类似地，test()函数是独立调用，而不是方法调用，所以this默认绑定到window）</li></ul><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p><h4 id="“构造函数“"><a href="#“构造函数“" class="headerlink" title="“构造函数“"></a>“构造函数“</h4><p>在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">this.a = 20;              </span><br><span class="line">function go() &#123;           </span><br><span class="line">  /* body... */</span><br><span class="line">  console.log(this.a);    </span><br><span class="line">  this.a = 30;            </span><br><span class="line">&#125;;</span><br><span class="line">go.prototype.a = 40;       </span><br><span class="line">var test = &#123;              </span><br><span class="line">  a: 50,</span><br><span class="line">  init: function(fn) &#123;    </span><br><span class="line">    fn();</span><br><span class="line">    console.log(this.a);  </span><br><span class="line">    return fn;            </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log((new go()).a);  </span><br><span class="line">test.init(go);              </span><br><span class="line">var p = test.init(go);      </span><br><span class="line">p();</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti3.png" alt="kyrie irving"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;this的取值&quot;&gt;&lt;a href=&quot;#this的取值&quot; class=&quot;headerlink&quot; title=&quot;this的取值&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 自测题1</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%981/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题1/</id>
    <published>2019-09-23T00:46:20.000Z</published>
    <updated>2019-09-23T02:04:19.225Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="什么是作用域："><a href="#什么是作用域：" class="headerlink" title="什么是作用域："></a>什么是作用域：</h4><p>浏览器给js的生存环境叫作用域。</p><h4 id="什么是变量提升："><a href="#什么是变量提升：" class="headerlink" title="什么是变量提升："></a>什么是变量提升：</h4><ol><li><p>Js代码执行前，浏览器会给一个全局作用域window</p></li><li><p>Window分两个模块一个是存储模块一个是执行模块</p></li><li><p>存储模块找到所有的var和function 关键字给这些变量添加内存地址</p></li><li><p>执行模块，代码从上到下执行，遇到变量就会去存储模块查找，有和没有</p></li><li><p>有就看你赋值没有，赋值了就是后面的值没有赋值就是undefined。</p></li><li><p>没有结果就是xxx is not defined</p></li></ol><h4 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h4><p>函数内部的变量被使用时，首先会在自己的私有作用域下查找是否有这个变量，有就直接使用，没有就向他的上一级查找，父级有就使用父级的，父级没有就以此继续向上查找直到查找带window有就使用没有就是is not defined。这种查找机制我们叫原型链。</p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alert(a);</span><br><span class="line">a();</span><br><span class="line">var a = 3;</span><br><span class="line">function a() &#123;</span><br><span class="line">  /* body... */</span><br><span class="line">  alert(10);</span><br><span class="line">&#125;           </span><br><span class="line">alert(a);</span><br><span class="line">a = 6;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti1.png" alt="kyrie irving"></p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var x = 1,</span><br><span class="line">    y = 0,</span><br><span class="line">    z = 0;</span><br><span class="line">function add(x) &#123;</span><br><span class="line">  /* body... */</span><br><span class="line">  return (x = x + 1);</span><br><span class="line">&#125;;</span><br><span class="line">y = add (x);</span><br><span class="line">console.log(y);</span><br><span class="line">function add(x) &#123;</span><br><span class="line">  return (x = x + 3);</span><br><span class="line">&#125;;</span><br><span class="line">z = add(x);</span><br><span class="line">console.log(z);</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti2.png" alt="kyrie irving"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;什么是作用域：&quot;&gt;&lt;a href=&quot;#什么是作用域：&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域：&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6</title>
    <link href="https://liushuai97.github.io/2019/09/20/ES6/"/>
    <id>https://liushuai97.github.io/2019/09/20/ES6/</id>
    <published>2019-09-20T02:25:31.000Z</published>
    <updated>2019-09-20T02:25:58.898Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;ECMAScript6 入门&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  1.let命令</span><br><span class="line">  基本用法，ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块有效。</span><br><span class="line">  上面代码在代码块之中，分别用let和var声明了两个变量。然后再代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明let声明的变量只在它所在的代码块有效。</span><br><span class="line"></span><br><span class="line">  for循环的计数器，就很适合使用let命令。</span><br><span class="line"></span><br><span class="line">  2.不存在变量提升</span><br><span class="line">  var 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该再声明语句之后才可以使用，为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</span><br><span class="line"></span><br><span class="line">  3.暂时性死区</span><br><span class="line">  只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死去”(temporal dead zone,简称 TDZ)。</span><br><span class="line"></span><br><span class="line">  “暂时性死区“也意味着typeof不再是一个百分之百安全的操作。</span><br><span class="line"></span><br><span class="line">  上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的”死区“，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</span><br><span class="line"></span><br><span class="line">  作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</span><br><span class="line"></span><br><span class="line">  4.不允许重复声明</span><br><span class="line"></span><br><span class="line">  let不允许在相同作用域内，重复声明同一个变量。</span><br><span class="line"></span><br><span class="line">  2.块级作用域</span><br><span class="line"></span><br><span class="line">  为什么需要块级作用域？</span><br><span class="line"></span><br><span class="line">  ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</span><br><span class="line"></span><br><span class="line">  第一种场景，内层变量可能会覆盖外层变量。</span><br><span class="line"></span><br><span class="line">  3.ES6的块级作用域</span><br><span class="line"></span><br><span class="line">  let实际上为JavaScript新增了块级作用域。</span><br><span class="line"></span><br><span class="line">  上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。</span><br><span class="line"></span><br><span class="line">  ES6 允许块级作用域的任意嵌套。</span><br><span class="line"></span><br><span class="line">  内层作用域可以定义外层作用不的同名变量。</span><br><span class="line"></span><br><span class="line">  窥觊作用域的出现，实际上是的获得广泛应用的匿名立即执行函数表达式（匿名IIFE）不再必要了。</span><br><span class="line"></span><br><span class="line">  4.块级作用域和函数声明</span><br><span class="line"></span><br><span class="line">  ES5固定，函数智能在顶层作用域和函数作用域之中声明，不能再块级作用域声明。</span><br><span class="line"></span><br><span class="line">  ES6引入了块级作用域，明确允许在块级作用域之中声明函数。ES6规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</span><br><span class="line"></span><br><span class="line">  为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</span><br><span class="line"></span><br><span class="line">  - 允许在块级作用域内声明函数</span><br><span class="line">  - 函数声明类似于var，即会提升到全局作用域或函数作用域的头部</span><br><span class="line">  - 同时，函数声明还会提升到所在的块级作用域的头部。</span><br><span class="line"></span><br><span class="line">  注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当做let处理。</span><br><span class="line"></span><br><span class="line">  根据这三条规则，浏览器的ES6环境中，块级作用域内声明的函数，行为类似于var声明的变量。</span><br><span class="line"></span><br><span class="line">  考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式而不是函数声明语句。</span><br><span class="line"></span><br><span class="line">  另外，还有一个需要注意的地方。ES6的块级作用域必须有大括号如果没有大括号，JavaScript引擎就认为不存在块级作用域。</span><br><span class="line"></span><br><span class="line">  3.const命令</span><br><span class="line"></span><br><span class="line">  基本用法，const声明一个只读的常量，一旦声明，常量的值就不能改变。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</span><br><span class="line"></span><br><span class="line">  const的作用域与let命令相同；挚爱声明所在的块级作用域内有效。</span><br><span class="line"></span><br><span class="line">  const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</span><br><span class="line"></span><br><span class="line">  const声明的常量，也与let一样不可重复声明。</span><br><span class="line"></span><br><span class="line">  本质，const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const智能保证这个指针是固定的（即总是指向一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明未常量必须非常小心。</span><br><span class="line"></span><br><span class="line">  ES6声明变量的六种方法</span><br><span class="line"></span><br><span class="line">  ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，另外两种声明变量的方法：import命令和class命令。</span><br><span class="line"></span><br><span class="line">  4.顶层对象的属性</span><br><span class="line"></span><br><span class="line">  顶处对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</span><br><span class="line"></span><br><span class="line">  顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样额设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；顶层对象的属性是到处可以读写的，这非常不利于模块化变成，另一个方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</span><br><span class="line"></span><br><span class="line">  ES6为了改变这一点，一方面固定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令，const命令、class命令声明的全局变量，不属于顶层对象的属性，也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。</span><br><span class="line"></span><br><span class="line">  5.gobalThis对象</span><br><span class="line"></span><br><span class="line">  JavaScript语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</span><br><span class="line"></span><br><span class="line">  - 浏览器里面，顶层对象是window，单Node和WebWorker没有window。</span><br><span class="line">  - 浏览器和WbeWorker里面，self也指向顶层对象，但是Node没有self。</span><br><span class="line">  - Node里面，顶层对象是global，但其他环境都不支持。</span><br><span class="line"></span><br><span class="line">  同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</span><br><span class="line"></span><br><span class="line">  - 全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。</span><br><span class="line">  - 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</span><br><span class="line">  - 不管是严格模式，还是普通模式，new Function(&apos;return this&apos;)(), 总是会返回全局对象。但是，如果浏览器用了CSP(Content Security Policy,内容安全策略)，那么eval、new Function这些方法都可能无法使用。</span><br><span class="line"></span><br><span class="line">  综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。</span><br><span class="line">  </span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // &#123;</span><br><span class="line">    //   let a = 10;</span><br><span class="line">    //   var b = 1;</span><br><span class="line">    // &#125;</span><br><span class="line">    // console.log(b);</span><br><span class="line">    // console.log(a);</span><br><span class="line"></span><br><span class="line">    // for(let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    // &#125;</span><br><span class="line">    // console.log(i);</span><br><span class="line"></span><br><span class="line">    // var tmp = 123;</span><br><span class="line"></span><br><span class="line">    // if(true)&#123;</span><br><span class="line">    //   tmp = &apos;abc&apos;;</span><br><span class="line">    //   let tmp;</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    // typeof x;</span><br><span class="line">    // let x;</span><br><span class="line"></span><br><span class="line">    // typeof undeclared_variable;</span><br><span class="line"></span><br><span class="line">    // function func () &#123;</span><br><span class="line">    //   // body... </span><br><span class="line">    //   let a = 10;</span><br><span class="line">    //   var a = 1;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // function func () &#123;</span><br><span class="line">    //   let a = 10;</span><br><span class="line">    //   let a = 1;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // function func(arg)&#123;</span><br><span class="line">    //   let arg;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // func(); // 报错</span><br><span class="line"></span><br><span class="line">    // function func(arg)&#123;</span><br><span class="line">    //   &#123;</span><br><span class="line">    //     let arg;</span><br><span class="line">    //   &#125;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // func() // 不报错</span><br><span class="line"></span><br><span class="line">    // var tmp = new Date();</span><br><span class="line"></span><br><span class="line">    // function f() &#123;</span><br><span class="line">    //   console.log(tmp);</span><br><span class="line">    //   if(false)&#123;</span><br><span class="line">    //     var tmp = &apos;hello world&apos;;</span><br><span class="line">    //   &#125;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // f();</span><br><span class="line"></span><br><span class="line">    // function f1() &#123;</span><br><span class="line">    //   let n = 5;</span><br><span class="line">    //   if(true)&#123;</span><br><span class="line">    //     let n = 10;</span><br><span class="line">    //   &#125;</span><br><span class="line">    //   console.log(n);</span><br><span class="line">    // &#125;</span><br><span class="line">    // f1();</span><br><span class="line"></span><br><span class="line">    // 情况一</span><br><span class="line">    // if(true)&#123;</span><br><span class="line">    //   function f() &#123;&#125;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // // 情况二</span><br><span class="line">    // try &#123;</span><br><span class="line">    //   function f() &#123;</span><br><span class="line"></span><br><span class="line">    //   &#125;</span><br><span class="line">    // &#125; catch(e) &#123;</span><br><span class="line">    //   // statements</span><br><span class="line">    //   console.log(e);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // 上面两种函数声明，根据ES5的规定都是非法的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 浏览器的ES6环境</span><br><span class="line"></span><br><span class="line">    // function f() &#123; console.log(&apos;I am outside!&apos;);&#125;</span><br><span class="line"></span><br><span class="line">    // (function()&#123;</span><br><span class="line">    //   var f = undefined;</span><br><span class="line">      </span><br><span class="line">    //   if(false)&#123;</span><br><span class="line">    //     function f() &#123;console.log(&apos;I am inside!&apos;);&#125;</span><br><span class="line">    //   &#125;</span><br><span class="line"></span><br><span class="line">    //   f();</span><br><span class="line"></span><br><span class="line">    // &#125;)();</span><br><span class="line"></span><br><span class="line">    // Uncaught TYpeError: f is not a function</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // const foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 为 foor添加一个属性，可以成功</span><br><span class="line">    // foo.prop = 123;</span><br><span class="line">    // foo.prop</span><br><span class="line"></span><br><span class="line">    // 将foo指向另一个对象，就会报错</span><br><span class="line"></span><br><span class="line">    // foo = &#123;&#125;; </span><br><span class="line"></span><br><span class="line">    // 方法一</span><br><span class="line">    // (typeof window !== &apos;undefined&apos;</span><br><span class="line">    //    ? window</span><br><span class="line">    //    : (typeof process === &apos;object&apos; &amp;&amp;</span><br><span class="line">    //       typeof require === &apos;function&apos; &amp;&amp;</span><br><span class="line">    //       typeof global === &apos;object&apos;)</span><br><span class="line">    //      ? global</span><br><span class="line">    //      : this);</span><br><span class="line"></span><br><span class="line">    // 方法二</span><br><span class="line">    // var getGlobal = function () &#123;</span><br><span class="line">    //   if (typeof self !== &apos;undefined&apos;) &#123; return self; &#125;</span><br><span class="line">    //   if (typeof window !== &apos;undefined&apos;) &#123; return window; &#125;</span><br><span class="line">    //   if (typeof global !== &apos;undefined&apos;) &#123; return global; &#125;</span><br><span class="line">    //   throw new Error(&apos;unable to locate global object&apos;);</span><br><span class="line">    // &#125;;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  变量的解构赋值</span><br><span class="line">  </span><br><span class="line">  1.数组的解构赋值</span><br><span class="line"></span><br><span class="line">  基本用法，ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</span><br><span class="line"></span><br><span class="line">  以前，为变量赋值，智能直接指定值</span><br><span class="line"></span><br><span class="line">  let a = 1;</span><br><span class="line">  let b = 2;</span><br><span class="line">  let c = 3;</span><br><span class="line">  </span><br><span class="line">  ES6允许写成下面这样</span><br><span class="line">  </span><br><span class="line">  let [a,b,c] = [1,2,3];</span><br><span class="line"></span><br><span class="line">  本质上，这种写法属于”模式匹配“，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</span><br><span class="line">  </span><br><span class="line">  如果解构不成功，变量的值就等于undefined.</span><br><span class="line"></span><br><span class="line">  2.默认值</span><br><span class="line"></span><br><span class="line">  解构赋值允许指定默认值。注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</span><br><span class="line"></span><br><span class="line">  3.对象的解构赋值</span><br><span class="line"></span><br><span class="line">  解构不仅可以用于数组，还可以用于对象。</span><br><span class="line"></span><br><span class="line">  对象的解析与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</span><br><span class="line"></span><br><span class="line">  4.默认值</span><br><span class="line"></span><br><span class="line">  对象的解构也可以指定默认值。</span><br><span class="line"></span><br><span class="line">  5.注意点</span><br><span class="line"></span><br><span class="line">  - 如果要将一个已经声明的变量用于解构赋值，必须非常小心。</span><br><span class="line">  - 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</span><br><span class="line">  - 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</span><br><span class="line"></span><br><span class="line">  6.字符串的解构赋值</span><br><span class="line"></span><br><span class="line">  字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</span><br><span class="line"></span><br><span class="line">  类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</span><br><span class="line"></span><br><span class="line">  7.数值和布尔值的解构赋值</span><br><span class="line"></span><br><span class="line">  解构赋值时，如果等号左边是数值和布尔值，则会先转为对象。</span><br><span class="line"></span><br><span class="line">  解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对他们进行解构赋值，都会报错。</span><br><span class="line"></span><br><span class="line">  8.函数参数的解构赋值，函数的参数也可以使用解构赋值。</span><br><span class="line"></span><br><span class="line">  9.圆括号问题</span><br><span class="line"></span><br><span class="line">  解构赋值虽然很方面吧，但是解析起来并不容易，对于编译器来说某一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</span><br><span class="line"></span><br><span class="line">  10.不能使用圆括号的情况</span><br><span class="line"></span><br><span class="line">  - 变量声明语句</span><br><span class="line">  - 函数参数</span><br><span class="line">  - 赋值语句的模式</span><br><span class="line">  </span><br><span class="line">  11.可以使用圆括号的情况</span><br><span class="line"></span><br><span class="line">  可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</span><br><span class="line"></span><br><span class="line">  12.用途</span><br><span class="line">  变量的解构赋值用途很多</span><br><span class="line">  - 交换变量的值</span><br><span class="line">  - 从函数返回多个值</span><br><span class="line">  - 函数参数的定义</span><br><span class="line">  - 提取JSON数据</span><br><span class="line">  - 函数参数的默认值</span><br><span class="line">  - 遍历Map结构</span><br><span class="line">  - 输入模块的指定方法</span><br><span class="line"></span><br><span class="line">  &lt;!-- 字符串的扩展 --&gt;</span><br><span class="line"></span><br><span class="line">  1.字符的Unicode表示法</span><br><span class="line"></span><br><span class="line">  ES6加强了对Unicode的支持，允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的Unicode码点。但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</span><br><span class="line"></span><br><span class="line">  ES6对这一点做出改进，只要将码点放入大括号，就能正确解读该字符。</span><br><span class="line"></span><br><span class="line">  大括号标识符与四字节的UTF-16编码是等价的。有了这种表示法之后，JavaScript共有6中方法可以表示一个字符。</span><br><span class="line"></span><br><span class="line">  &apos;\z&apos; === &apos;z&apos;  // true</span><br><span class="line">  &apos;\172&apos; === &apos;z&apos; // true</span><br><span class="line">  &apos;\x7A&apos; === &apos;z&apos; // true</span><br><span class="line">  &apos;\u007A&apos; === &apos;z&apos; // true</span><br><span class="line">  &apos;\u&#123;7A&#125;&apos; === &apos;z&apos; // true</span><br><span class="line"></span><br><span class="line">  2.字符串的遍历接口</span><br><span class="line"></span><br><span class="line">  ES6为字符串添加了遍历器接口，是的字符串可以被for...of循环遍历。</span><br><span class="line"></span><br><span class="line">  除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</span><br><span class="line"></span><br><span class="line">  3.直接输入U+2028盒U+2029</span><br><span class="line"></span><br><span class="line">  4.JSON.stringify()的改造</span><br><span class="line"></span><br><span class="line">  根据标准，JOSN数据必须是UTF-8编码。但是，现在的JSON.stringify()方法有可能返回不符合UTF-8标准的字符串。</span><br><span class="line"></span><br><span class="line">  5.模板字符串</span><br><span class="line"></span><br><span class="line">  ES6引入了模板字符串解决这个问题。模板字符串是增强版的字符串，用反引号(`)表示。</span><br><span class="line"></span><br><span class="line">  6.实例：模板编译</span><br><span class="line"></span><br><span class="line">  7.标签模板</span><br><span class="line"></span><br><span class="line">  模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用了爱处理这个模板字符串。这个被称为&quot;标签模板&quot;功能。</span><br><span class="line"></span><br><span class="line">  8.模板字符串的限制</span><br><span class="line"></span><br><span class="line">  前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</span><br><span class="line"></span><br><span class="line">  &lt;!-- 字符串的新增方法 --&gt;</span><br><span class="line">  1.String.fromCodePoint()</span><br><span class="line"></span><br><span class="line">  ES5 提供String.fromCharCode()方法，用于从 Unicode 码点返回对应字符，但是这个方法不能识别码点大于0xFFFF的字符。</span><br><span class="line"></span><br><span class="line">  2.String.raw()</span><br><span class="line"></span><br><span class="line">  ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。</span><br><span class="line"></span><br><span class="line">  3.codePointAt()</span><br><span class="line"></span><br><span class="line">  ES6 提供了codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</span><br><span class="line"></span><br><span class="line">  4.normalize()</span><br><span class="line"></span><br><span class="line">  ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</span><br><span class="line"></span><br><span class="line">  5.ES6 又提供了三种新方法。</span><br><span class="line">    </span><br><span class="line">  - includes()：返回布尔值，表示是否找到了参数字符串。</span><br><span class="line">  - startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</span><br><span class="line">  - endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</span><br><span class="line"></span><br><span class="line">  6.repeat()</span><br><span class="line"></span><br><span class="line">  repeat方法返回一个新字符串，表示将原字符串重复n次。</span><br><span class="line"></span><br><span class="line">  7.padStart()，padEnd()</span><br><span class="line"></span><br><span class="line">  ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</span><br><span class="line"></span><br><span class="line">  8.trimStart()，trimEnd() </span><br><span class="line"></span><br><span class="line">  ES2019 对字符串实例新增了trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</span><br><span class="line"></span><br><span class="line">  9.matchAll()</span><br><span class="line"></span><br><span class="line">  matchAll()方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</span><br><span class="line"></span><br><span class="line">  &lt;!-- 正则的扩展 --&gt;</span><br><span class="line"></span><br><span class="line">  1.RegExp 构造函数</span><br><span class="line"></span><br><span class="line">  - 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</span><br><span class="line">  - 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</span><br><span class="line"></span><br><span class="line">  2.字符串的正则方法</span><br><span class="line">    </span><br><span class="line">  字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。</span><br><span class="line"></span><br><span class="line">  3.u 修饰符</span><br><span class="line">  </span><br><span class="line">  ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</span><br><span class="line">  - 点字符</span><br><span class="line">  - Unicode 字符表示法</span><br><span class="line">  - 量词</span><br><span class="line">  - 预定义模式</span><br><span class="line">  - i 修饰符</span><br><span class="line">  - 转义</span><br><span class="line"></span><br><span class="line">  4.RegExp.prototype.unicode 属性</span><br><span class="line">  </span><br><span class="line">  正则实例对象新增unicode属性，表示是否设置了u修饰符。</span><br><span class="line"></span><br><span class="line">  5.y 修饰符</span><br><span class="line"></span><br><span class="line">  除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。</span><br><span class="line"></span><br><span class="line">  6.RegExp.prototype.sticky 属性</span><br><span class="line"></span><br><span class="line">  与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。</span><br><span class="line"></span><br><span class="line">  7.RegExp.prototype.flags 属性</span><br><span class="line">  </span><br><span class="line">  ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。</span><br><span class="line"></span><br><span class="line">  8.s 修饰符：dotAll 模式</span><br><span class="line"></span><br><span class="line">  正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。</span><br><span class="line"></span><br><span class="line">  所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。</span><br><span class="line"></span><br><span class="line">  - U+000A 换行符（\n）</span><br><span class="line">  - U+000D 回车符（\r）</span><br><span class="line">  - U+2028 行分隔符（line separator）</span><br><span class="line">  - U+2029 段分隔符（paragraph separator）</span><br><span class="line"></span><br><span class="line">  9.后行断言</span><br><span class="line">  </span><br><span class="line">  JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。</span><br><span class="line"></span><br><span class="line">  10.Unicode 属性类</span><br><span class="line"></span><br><span class="line">  ES2018 引入了一种新的类的写法\p&#123;...&#125;和\P&#123;...&#125;，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</span><br><span class="line"></span><br><span class="line">  11.具名组匹配</span><br><span class="line"></span><br><span class="line">  正则表达式使用圆括号进行组匹配。ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</span><br><span class="line">  </span><br><span class="line">  - 解构赋值和替换，有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</span><br><span class="line">  - 引用，如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。</span><br><span class="line">  </span><br><span class="line">  12.String.prototype.matchAll</span><br><span class="line"></span><br><span class="line">  如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。目前有一个提案，增加了String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</span><br><span class="line"></span><br><span class="line">  &lt;!-- 数值的扩展 --&gt;</span><br><span class="line"></span><br><span class="line">  1.二进制和八进制表示法</span><br><span class="line"></span><br><span class="line">  2.Number.isFinite(), Number.isNaN()</span><br><span class="line"></span><br><span class="line">  3.Number.parseInt(), Number.parseFloat()</span><br><span class="line"></span><br><span class="line">  4.Number.isInteger()</span><br><span class="line"></span><br><span class="line">  5.Number.EPSILON</span><br><span class="line"></span><br><span class="line">  6.安全整数和 Number.isSafeInteger()</span><br><span class="line"></span><br><span class="line">  7.Math 对象的扩展</span><br><span class="line"></span><br><span class="line">  8.指数运算符</span><br><span class="line"></span><br><span class="line">  &lt;!-- 函数的扩展 --&gt;</span><br><span class="line"></span><br><span class="line">  1.函数参数的默认值</span><br><span class="line">  </span><br><span class="line">  2.rest 参数</span><br><span class="line">  </span><br><span class="line">  3.严格模式</span><br><span class="line">  </span><br><span class="line">  4.name 属性</span><br><span class="line">  </span><br><span class="line">  5.箭头函数</span><br><span class="line">  </span><br><span class="line">  6.尾调用优化</span><br><span class="line">  </span><br><span class="line">  7.函数参数的尾逗号</span><br><span class="line">  </span><br><span class="line">  8.Function.prototype.toString()</span><br><span class="line">  </span><br><span class="line">  9.catch 命令的参数省略</span><br><span class="line"></span><br><span class="line">  &lt;!-- 数组的扩展 --&gt;</span><br><span class="line"></span><br><span class="line">  1.扩展运算符</span><br><span class="line">  </span><br><span class="line">  2.Array.from()</span><br><span class="line">  </span><br><span class="line">  3.Array.of()</span><br><span class="line">  </span><br><span class="line">  4.数组实例的 copyWithin()</span><br><span class="line">  </span><br><span class="line">  5.数组实例的 find() 和 findIndex()</span><br><span class="line">  </span><br><span class="line">  6.数组实例的 fill()</span><br><span class="line">  </span><br><span class="line">  7.数组实例的 entries()，keys() 和 values()</span><br><span class="line">  </span><br><span class="line">  8.数组实例的 includes()</span><br><span class="line">  </span><br><span class="line">  9.数组实例的 flat()，flatMap()</span><br><span class="line">  </span><br><span class="line">  10.数组的空位</span><br><span class="line">  </span><br><span class="line">  &lt;!-- 对象的扩展 --&gt;</span><br><span class="line"></span><br><span class="line">  1.属性的简洁表示法</span><br><span class="line">  </span><br><span class="line">  2.属性名表达式</span><br><span class="line">  </span><br><span class="line">  3.方法的 name 属性</span><br><span class="line">  </span><br><span class="line">  4.属性的可枚举性和遍历</span><br><span class="line">  </span><br><span class="line">  5.super 关键字</span><br><span class="line">  </span><br><span class="line">  6.对象的扩展运算符</span><br><span class="line"></span><br><span class="line">  &lt;!-- 对象的新增方法 --&gt;</span><br><span class="line"></span><br><span class="line">  1.Object.is()</span><br><span class="line">  </span><br><span class="line">  2.Object.assign()</span><br><span class="line">  </span><br><span class="line">  3.Object.getOwnPropertyDescriptors()</span><br><span class="line">  </span><br><span class="line">  4.__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</span><br><span class="line">  </span><br><span class="line">  5.Object.keys()，Object.values()，Object.entries()</span><br><span class="line">  </span><br><span class="line">  6.Object.fromEntries()</span><br><span class="line"></span><br><span class="line">  &lt;!-- Symbol --&gt;</span><br><span class="line"></span><br><span class="line">  1.概述</span><br><span class="line"></span><br><span class="line">  ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  2.Symbol.prototype.description</span><br><span class="line"></span><br><span class="line">  3.作为属性名的 Symbol</span><br><span class="line"></span><br><span class="line">  4.实例：消除魔术字符串</span><br><span class="line"></span><br><span class="line">  5.属性名的遍历</span><br><span class="line"></span><br><span class="line">  6.Symbol.for()，Symbol.keyFor()</span><br><span class="line"></span><br><span class="line">  7.实例：模块的 Singleton 模式</span><br><span class="line"></span><br><span class="line">  8.内置的 Symbol 值</span><br><span class="line"></span><br><span class="line">  &lt;!-- Set 和 Map 数据结构 --&gt;</span><br><span class="line"></span><br><span class="line">  1.Set</span><br><span class="line">    </span><br><span class="line">  ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</span><br><span class="line"></span><br><span class="line">  Set本身是一个构造函数，用来生成 Set 数据结构。</span><br><span class="line"></span><br><span class="line">  Set 结构的实例有以下属性。</span><br><span class="line"></span><br><span class="line">  - Set.prototype.constructor：构造函数，默认就是Set函数。</span><br><span class="line">  - Set.prototype.size：返回Set实例的成员总数。</span><br><span class="line"></span><br><span class="line">  Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</span><br><span class="line"></span><br><span class="line">  - Set.prototype.add(value)：添加某个值，返回 Set 结构本身。</span><br><span class="line">  - Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</span><br><span class="line">  - Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。</span><br><span class="line">  - Set.prototype.clear()：清除所有成员，没有返回值。</span><br><span class="line"></span><br><span class="line">  Set 结构的实例有四个遍历方法，可以用于遍历成员。</span><br><span class="line"></span><br><span class="line">  - Set.prototype.keys()：返回键名的遍历器</span><br><span class="line">  - Set.prototype.values()：返回键值的遍历器</span><br><span class="line">  - Set.prototype.entries()：返回键值对的遍历器</span><br><span class="line">  - Set.prototype.forEach()：使用回调函数遍历每个成员</span><br><span class="line"></span><br><span class="line">  2.WeakSet</span><br><span class="line">  </span><br><span class="line">  WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</span><br><span class="line"></span><br><span class="line">  首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</span><br><span class="line"></span><br><span class="line">  WeakSet 结构有以下三个方法。</span><br><span class="line"></span><br><span class="line">  - WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。</span><br><span class="line">  - WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。</span><br><span class="line">  - WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</span><br><span class="line"></span><br><span class="line">  3.Map</span><br><span class="line"></span><br><span class="line">  ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</span><br><span class="line"></span><br><span class="line">  Map 结构原生提供三个遍历器生成函数和一个遍历方法。</span><br><span class="line"></span><br><span class="line">  - Map.prototype.keys()：返回键名的遍历器。</span><br><span class="line">  - Map.prototype.values()：返回键值的遍历器。</span><br><span class="line">  - Map.prototype.entries()：返回所有成员的遍历器。</span><br><span class="line">  - Map.prototype.forEach()：遍历 Map 的所有成员。</span><br><span class="line">  </span><br><span class="line">  4.WeakMap</span><br><span class="line"></span><br><span class="line">  WeakMap结构与Map结构类似，也是用于生成键值对的集合。</span><br><span class="line"></span><br><span class="line">  WeakMap与Map的区别有两点。</span><br><span class="line"></span><br><span class="line">  首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</span><br><span class="line"></span><br><span class="line">  其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。</span><br><span class="line"></span><br><span class="line">  WeakMap只有四个方法可用：get()、set()、has()、delete()。</span><br><span class="line"></span><br><span class="line">  &lt;!-- ECMAScript 6 Iterator和for...of循环 --&gt;</span><br><span class="line"></span><br><span class="line">  1.Iterator（遍历器）的概念</span><br><span class="line"></span><br><span class="line">    Iterator的遍历过程是这样的。</span><br><span class="line"></span><br><span class="line">  （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</span><br><span class="line"></span><br><span class="line">  （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</span><br><span class="line"></span><br><span class="line">  （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</span><br><span class="line"></span><br><span class="line">  （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。</span><br><span class="line">  </span><br><span class="line">  2.数据结构的默认Iterator接口</span><br><span class="line">    </span><br><span class="line">    Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环（详见下文）。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</span><br><span class="line"></span><br><span class="line">    在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。</span><br><span class="line"></span><br><span class="line">  3.调用Iterator接口的场合</span><br><span class="line"></span><br><span class="line">    - 解构赋值，对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。</span><br><span class="line">    - 扩展运算符，扩展运算符（...）也会调用默认的iterator接口。</span><br><span class="line">    - yield*，yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</span><br><span class="line">    - 其他场合，由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</span><br><span class="line">      for...of</span><br><span class="line">      Array.from()</span><br><span class="line">      Map(), Set(), WeakMap(), WeakSet()（比如new Map([[&apos;a&apos;,1],[&apos;b&apos;,2]])）</span><br><span class="line">      Promise.all()</span><br><span class="line">      Promise.race()</span><br><span class="line">  </span><br><span class="line">  4.字符串的Iterator接口</span><br><span class="line">  </span><br><span class="line">  5.Iterator接口与Generator函数</span><br><span class="line">  </span><br><span class="line">  6.遍历器对象的return()，throw()</span><br><span class="line">  </span><br><span class="line">  7.for...of循环</span><br><span class="line"></span><br><span class="line">  &lt;!-- ECMAScript 6 Generator 函数 --&gt;</span><br><span class="line"></span><br><span class="line">  1.简介</span><br><span class="line"></span><br><span class="line">  Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。</span><br><span class="line">  </span><br><span class="line">  2.next方法的参数</span><br><span class="line">  </span><br><span class="line">  yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。</span><br><span class="line"></span><br><span class="line">  3.for...of循环</span><br><span class="line"></span><br><span class="line">  for...of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。</span><br><span class="line">  </span><br><span class="line">  4.Generator.prototype.throw()</span><br><span class="line"></span><br><span class="line">  Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。</span><br><span class="line">  </span><br><span class="line">  5.Generator.prototype.return()</span><br><span class="line"></span><br><span class="line">  Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</span><br><span class="line">  </span><br><span class="line">  6.yield*语句</span><br><span class="line"></span><br><span class="line">  如果在Generater函数内部，调用另一个Generator函数，默认情况下是没有效果的。</span><br><span class="line">  </span><br><span class="line">  7.作为对象属性的Generator函数</span><br><span class="line">  </span><br><span class="line">  8.Generator函数的this</span><br><span class="line"></span><br><span class="line">  Generator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。</span><br><span class="line">  </span><br><span class="line">  9.含义</span><br><span class="line"></span><br><span class="line">  Generator与状态机</span><br><span class="line">  - Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。</span><br><span class="line"></span><br><span class="line">  Generator与协程</span><br><span class="line">  - 协程与子例程的差异</span><br><span class="line">  - 协程与普通线程的差异</span><br><span class="line">  </span><br><span class="line">  10.应用</span><br><span class="line">  </span><br><span class="line">  Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。</span><br><span class="line">  - 异步操作的同步化表达</span><br><span class="line">  - 控制流管理</span><br><span class="line">  - 部署Iterator接口</span><br><span class="line">  - 作为数据结构</span><br><span class="line"></span><br><span class="line">  &lt;!-- ECMAScript 6 Promise对象 --&gt;</span><br><span class="line"></span><br><span class="line">  1.Promise的含义</span><br><span class="line">  </span><br><span class="line">  Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。</span><br><span class="line"></span><br><span class="line">  Promise对象有以下两个特点。</span><br><span class="line"></span><br><span class="line">  - 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</span><br><span class="line"></span><br><span class="line">  - 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</span><br><span class="line"></span><br><span class="line">  有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</span><br><span class="line"></span><br><span class="line">  Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</span><br><span class="line"></span><br><span class="line">  2.基本用法</span><br><span class="line"></span><br><span class="line">  ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</span><br><span class="line">  </span><br><span class="line">  3.Promise.prototype.then()</span><br><span class="line">  </span><br><span class="line">  4.Promise.prototype.catch()</span><br><span class="line">  </span><br><span class="line">  5.Promise.all()</span><br><span class="line">  </span><br><span class="line">  6.Promise.race()</span><br><span class="line">  </span><br><span class="line">  7.Promise.resolve()</span><br><span class="line">  </span><br><span class="line">  8.Promise.reject()</span><br><span class="line">  </span><br><span class="line">  9.两个有用的附加方法</span><br><span class="line">  </span><br><span class="line">  10.应用</span><br><span class="line">  </span><br><span class="line">  &lt;!-- ECMAScript 6 异步操作和Async函数 --&gt;</span><br><span class="line"></span><br><span class="line">  1.基本概念</span><br><span class="line"></span><br><span class="line">  ES6诞生以前，异步编程的方法，大概有下面四种。</span><br><span class="line"></span><br><span class="line">  - 回调函数</span><br><span class="line">  - 事件监听</span><br><span class="line">  - 发布/订阅</span><br><span class="line">  - Promise 对象</span><br><span class="line">  </span><br><span class="line">  ES6将JavaScript异步编程带入了一个全新的阶段，ES7的Async函数更是提出了异步编程的终极解决方案。</span><br><span class="line">  </span><br><span class="line">  2.Generator函数</span><br><span class="line">  </span><br><span class="line">  3.Thunk函数</span><br><span class="line">  </span><br><span class="line">  4.co模块</span><br><span class="line">  </span><br><span class="line">  5.async函数</span><br><span class="line"></span><br><span class="line">  &lt;!-- ECMAScript 6 Class --&gt;</span><br><span class="line"></span><br><span class="line">  1.Class基本语法</span><br><span class="line">  </span><br><span class="line">  2.Class的继承</span><br><span class="line">  </span><br><span class="line">  3.原生构造函数的继承</span><br><span class="line">  </span><br><span class="line">  4.Class的取值函数（getter）和存值函数（setter）</span><br><span class="line">  </span><br><span class="line">  5.Class的Generator方法</span><br><span class="line">  </span><br><span class="line">  6.Class的静态方法</span><br><span class="line">  </span><br><span class="line">  7.Class的静态属性和实例属性</span><br><span class="line">  </span><br><span class="line">  8.new.target属性</span><br><span class="line">  </span><br><span class="line">  9.Mixin模式的实现</span><br><span class="line"></span><br><span class="line">  &lt;!-- ECMAScript 6 修饰器（Decorator） --&gt;</span><br><span class="line">  </span><br><span class="line">  1.类的修饰</span><br><span class="line">  </span><br><span class="line">  2.方法的修饰</span><br><span class="line">  </span><br><span class="line">  3.为什么修饰器不能用于函数？</span><br><span class="line">  </span><br><span class="line">  4.core-decorators.js</span><br><span class="line">  </span><br><span class="line">  5.使用修饰器实现自动发布事件</span><br><span class="line">  </span><br><span class="line">  6.Mixin</span><br><span class="line">  </span><br><span class="line">  7.Trait</span><br><span class="line">  </span><br><span class="line">  8.Babel转码器的支持</span><br><span class="line"></span><br><span class="line">  &lt;!-- ECMAScript 6 Module --&gt;</span><br><span class="line"></span><br><span class="line">  1.严格模式</span><br><span class="line">  </span><br><span class="line">  2.export命令</span><br><span class="line">  </span><br><span class="line">  3.import命令</span><br><span class="line">  </span><br><span class="line">  4.模块的整体加载</span><br><span class="line">  </span><br><span class="line">  5.export default命令</span><br><span class="line">  </span><br><span class="line">  6.模块的继承</span><br><span class="line">  </span><br><span class="line">  7.ES6模块加载的实质</span><br><span class="line">  </span><br><span class="line">  8.循环加载</span><br><span class="line">  </span><br><span class="line">  9.跨模块常量</span><br><span class="line">  </span><br><span class="line">  10.ES6模块的转码</span><br><span class="line"></span><br><span class="line">  &lt;!-- ECMAScript 6 编程风格 --&gt;</span><br><span class="line"></span><br><span class="line">  1.块级作用域</span><br><span class="line">  </span><br><span class="line">  2.字符串</span><br><span class="line">  </span><br><span class="line">  3.解构赋值</span><br><span class="line">  </span><br><span class="line">  4.对象</span><br><span class="line">  </span><br><span class="line">  5.数组</span><br><span class="line">  </span><br><span class="line">  6.函数</span><br><span class="line">  </span><br><span class="line">  7.Map结构</span><br><span class="line">  </span><br><span class="line">  8.Class</span><br><span class="line">  </span><br><span class="line">  9.模块</span><br><span class="line">  </span><br><span class="line">  10.ESLint的使用</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 语言入门教程</title>
    <link href="https://liushuai97.github.io/2019/09/19/JavaScript-%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://liushuai97.github.io/2019/09/19/JavaScript-语言入门教程/</id>
    <published>2019-09-19T01:58:03.000Z</published>
    <updated>2019-09-19T01:58:35.941Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;JavaScript 语言入门教程&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;./assets/index.js&quot;&gt;&lt;/script&gt; --&gt;</span><br><span class="line">  &lt;!-- JavaScript 的基本语法 --&gt;</span><br><span class="line">  1.语句</span><br><span class="line">  JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。</span><br><span class="line">  2.变量</span><br><span class="line">  - 概念</span><br><span class="line">  变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</span><br><span class="line">  - 变量提升</span><br><span class="line">  JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</span><br><span class="line">  3.标识符</span><br><span class="line">  - 标识符（identifier）指的是用来识别各种值的合法名称。</span><br><span class="line">  4.注释</span><br><span class="line">  - 源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。</span><br><span class="line">  5.区块</span><br><span class="line">  - JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。</span><br><span class="line">  6.条件语句</span><br><span class="line">  JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。</span><br><span class="line">  - if结构</span><br><span class="line">  - if...else结构</span><br><span class="line">  - switch结构</span><br><span class="line">  - 三元运算符 (条件) ? 表达式1 : 表达式2</span><br><span class="line">    JavaScript 还有一个三元运算符（即该运算符需要三个运算子）?:，也可以用于逻辑判断。</span><br><span class="line">  7.循环语句</span><br><span class="line">  循环语句用于重复执行某个操作，它有多种形式。</span><br><span class="line">  - while 循环</span><br><span class="line">    While语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</span><br><span class="line">  - for 循环</span><br><span class="line">    for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。</span><br><span class="line">  - do...while循环</span><br><span class="line">    do...while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</span><br><span class="line">  - break 语句和 continue 语句</span><br><span class="line">    break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。</span><br><span class="line">  - 标签（label）</span><br><span class="line">    JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</span><br><span class="line">  &lt;!-- 数据类型 --&gt;</span><br><span class="line">  JavaScript 语言的每一个值，都属于某一种数据类型。JavaScript 的数据类型，共有六种。</span><br><span class="line">  - 数值（number）：整数和小数（比如1和3.14）</span><br><span class="line">  - 字符串（string）：文本（比如Hello World）。</span><br><span class="line">  - 布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）</span><br><span class="line">  - undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</span><br><span class="line">  - null：表示空值，即此处的值为空。</span><br><span class="line">  - 对象（object）：各种值组成的集合。</span><br><span class="line">  </span><br><span class="line">  1.原始类型（primitive type）</span><br><span class="line">  - 通常，数值、字符串、布尔值这三种类型，即它们是最基本的数据类型，不能再细分了。</span><br><span class="line">  2.合成类型（complex type）</span><br><span class="line">  - 一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。</span><br><span class="line">  3.特殊值</span><br><span class="line">  - undefined和null</span><br><span class="line">  </span><br><span class="line">  对象是最复杂的数据类型，又可以分成三个子类型。</span><br><span class="line">  - 狭义的对象（object）</span><br><span class="line">  - 数组（array）</span><br><span class="line">  - 函数（function）</span><br><span class="line"></span><br><span class="line">  4.typeof 运算符：检测数据类型</span><br><span class="line">  &lt;!-- null, undefined 和布尔值 --&gt;</span><br><span class="line">  null与undefined都可以表示“没有”，含义非常相似。</span><br><span class="line">  1.用法和含义</span><br><span class="line">  - null表示空值，即该处的值现在为空。</span><br><span class="line">  - undefined表示“未定义”。</span><br><span class="line">  2.布尔值</span><br><span class="line">  - 布尔值代表“真”和“假”两个状态。“真”用关键字true表示，“假”用关键字false表示。</span><br><span class="line">  下列运算符会返回布尔值：</span><br><span class="line">  - 前置逻辑运算符： ! (Not)</span><br><span class="line">  - 相等运算符：===，!==，==，!=</span><br><span class="line">  - 比较运算符：&gt;，&gt;=，&lt;，&lt;=</span><br><span class="line">  &lt;!-- 数值 --&gt;</span><br><span class="line">  1.整数和浮点数</span><br><span class="line">  JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。</span><br><span class="line">  - 数值精度</span><br><span class="line">  - 数值范围</span><br><span class="line">  2.数值的表示法</span><br><span class="line">  3.数值的进制</span><br><span class="line">  JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</span><br><span class="line">  4.特殊数值</span><br><span class="line">  - 正零和负零</span><br><span class="line">  - NaN是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</span><br><span class="line">  - Infinity表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小。</span><br><span class="line">  5.与数值相关的全局方法</span><br><span class="line">  - parseInt()方法用于将字符串转为整数。</span><br><span class="line">  - parseFloat方法用于将一个字符串转为浮点数。</span><br><span class="line">  - isNaN方法可以用来判断一个值是否为NaN。</span><br><span class="line">  - isFinite方法返回一个布尔值，表示某个值是否为正常的数值。</span><br><span class="line">  &lt;!-- 字符串 --&gt;</span><br><span class="line">  字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</span><br><span class="line">  1.转义</span><br><span class="line">  - 反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</span><br><span class="line">    \0 ：null</span><br><span class="line">    \b ：后退键</span><br><span class="line">    \f ：换页符</span><br><span class="line">    \n ：换行符</span><br><span class="line">    \r ：回车键</span><br><span class="line">    \t ：制表符</span><br><span class="line">    \v ：垂直制表符</span><br><span class="line">    \&apos; ：单引号</span><br><span class="line">    \&quot; ：双引号</span><br><span class="line">    \\ ：反斜杠</span><br><span class="line">  - 字符串与数组</span><br><span class="line">    字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</span><br><span class="line">  - length 属性</span><br><span class="line">    length属性返回字符串的长度，该属性也是无法改变的。</span><br><span class="line">  2.字符集</span><br><span class="line">  JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</span><br><span class="line">  3.Base64 转码</span><br><span class="line">  Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</span><br><span class="line">  - btoa()：任意值转为 Base64 编码</span><br><span class="line">  - atob()：Base64 编码转为原来的值</span><br><span class="line">  &lt;!-- 对象 --&gt;</span><br><span class="line">  1.对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。</span><br><span class="line">  - 键名，对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。</span><br><span class="line">  - 对象的引用，如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</span><br><span class="line">  - JavaScript 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块。</span><br><span class="line">  2.属性的操作</span><br><span class="line">  - 读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</span><br><span class="line">  - 点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</span><br><span class="line">  - 查看一个对象本身的所有属性，可以使用Object.keys方法。</span><br><span class="line">  - delete命令用于删除对象的属性，删除成功后返回true。</span><br><span class="line">  - in 运算符，用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false。</span><br><span class="line">  - for...in 循环，for...in循环用来遍历一个对象的全部属性。</span><br><span class="line">  3.with 语句</span><br><span class="line">  with (对象) &#123;</span><br><span class="line">    语句;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;!-- 函数 --&gt;</span><br><span class="line">  1.函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</span><br><span class="line">  - function 命令，function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。</span><br><span class="line">  - 函数表达式，除了用function命令声明函数，还可以采用变量赋值的写法。</span><br><span class="line">  - Function 构造函数，第三种声明函数的方式是Function构造函数。</span><br><span class="line">  - 函数的重复声明，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。</span><br><span class="line">  - 圆括号运算符，return 语句和递归</span><br><span class="line">  - JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。</span><br><span class="line">  - JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。</span><br><span class="line">  2.函数的属性和方法 </span><br><span class="line">  - name属性，函数的name属性返回函数的名字。</span><br><span class="line">  - length属性，函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</span><br><span class="line">  - toString()，函数的toString方法返回一个字符串，内容是函数的源码。</span><br><span class="line">  3.函数作用域</span><br><span class="line">  - 作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。</span><br><span class="line">  - 函数内部的变量提升，与全局作用域一样，函数作用域内部也会产生“变量提升”现象。</span><br><span class="line">  - 函数本身的作用域，函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</span><br><span class="line">  4.参数</span><br><span class="line">  - 函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</span><br><span class="line">  - 函数参数不是必需的，JavaScript 允许省略参数。</span><br><span class="line">  - 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</span><br><span class="line">  - 如果有同名的参数，则取最后出现的那个值。</span><br><span class="line">  - arguments 对象，由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。</span><br><span class="line">  - 与数组的关系，需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。</span><br><span class="line">  - callee 属性，arguments对象带有一个callee属性，返回它所对应的原函数。</span><br><span class="line">  5.函数的其他知识点</span><br><span class="line">  - 闭包，闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。</span><br><span class="line">  - 闭包的另一个用处，是封装对象的私有属性和私有方法。</span><br><span class="line">  - 立即调用的函数表达式（IIFE）</span><br><span class="line">  6.eval 命令</span><br><span class="line">  - eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。</span><br><span class="line">  - eval 的别名调用</span><br><span class="line">  &lt;!-- 数组 --&gt;</span><br><span class="line">  1.数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。</span><br><span class="line">  2.数组的本质，本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。</span><br><span class="line">  3.length 属性，数组的length属性，返回数组的成员数量。</span><br><span class="line">  4.in 运算符，检查某个键名是否存在的运算符in，适用于对象，也适用于数组。</span><br><span class="line">  5.for...in 循环和数组的遍历，for...in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</span><br><span class="line">  6.数组的空位，当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</span><br><span class="line">  7.类似数组的对象，如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</span><br><span class="line">  &lt;!-- 运算符 --&gt;</span><br><span class="line">  1.算术运算符</span><br><span class="line">  - 加法运算符：x + y</span><br><span class="line">  - 减法运算符： x - y</span><br><span class="line">  - 乘法运算符： x * y</span><br><span class="line">  - 除法运算符：x / y</span><br><span class="line">  - 指数运算符：x ** y</span><br><span class="line">  - 余数运算符：x % y</span><br><span class="line">  - 自增运算符：++x 或者 x++</span><br><span class="line">  - 自减运算符：--x 或者 x--</span><br><span class="line">  - 数值运算符： +x</span><br><span class="line">  - 负数值运算符：-x</span><br><span class="line">  2.比较运算符</span><br><span class="line">  - 大于运算符：&gt; </span><br><span class="line">  - 小于运算符：&lt; </span><br><span class="line">  - 小于或等于运算符：&lt;= </span><br><span class="line">  - 大于或等于运算符：&gt;= </span><br><span class="line">  - 相等运算符：== </span><br><span class="line">  - 严格相等运算符：=== </span><br><span class="line">  - 不相等运算符：!= </span><br><span class="line">  - 严格不相等运算符：!== </span><br><span class="line">  3.布尔运算符</span><br><span class="line">  - 取反运算符：!</span><br><span class="line">  - 且运算符：&amp;&amp;</span><br><span class="line">  - 或运算符：||</span><br><span class="line">  - 三元运算符：?:</span><br><span class="line">  4.二进制位运算符</span><br><span class="line">  - 二进制或运算符（or）：符号为|，表示若两个二进制位都为0，则结果为0，否则为1。</span><br><span class="line">  - 二进制与运算符（and）：符号为&amp;，表示若两个二进制位都为1，则结果为1，否则为0。</span><br><span class="line">  - 二进制否运算符（not）：符号为~，表示对一个二进制位取反。</span><br><span class="line">  - 异或运算符（xor）：符号为^，表示若两个二进制位不相同，则结果为1，否则为0。</span><br><span class="line">  - 左移运算符（left shift）：符号为&lt;&lt;，详见下文解释。</span><br><span class="line">  - 右移运算符（right shift）：符号为&gt;&gt;，详见下文解释。</span><br><span class="line">  - 头部补零的右移运算符（zero filled right shift）：符号为&gt;&gt;&gt;，详见下文解释。</span><br><span class="line">  5.其他运算符，运算顺序</span><br><span class="line">  - void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。</span><br><span class="line">  - 逗号运算符用于对两个表达式求值，并返回后一个表达式的值。</span><br><span class="line">  - 运算顺序</span><br><span class="line">  &lt;!-- 数据类型的转换 --&gt;</span><br><span class="line">  1.JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</span><br><span class="line">  2.强制转换</span><br><span class="line">  - Number()，使用Number函数，可以将任意类型的值转化成数值。</span><br><span class="line">  - String()，String函数可以将任意类型的值转化成字符串。</span><br><span class="line">  - Boolean()函数可以将任意类型的值转为布尔值。</span><br><span class="line">  3.自动转换</span><br><span class="line">  - 第一种情况，不同类型的数据互相运算。</span><br><span class="line">  - 第二种情况，对非布尔值类型的数据求布尔值。</span><br><span class="line">  - 第三种情况，对非数值类型的值使用一元运算符（即+和-）。</span><br><span class="line">  &lt;!-- 错误处理机制 --&gt;</span><br><span class="line">  1.Error 实例对象</span><br><span class="line">  - JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。</span><br><span class="line">  2.原生错误类型</span><br><span class="line">  - SyntaxError对象是解析代码时发生的语法错误。</span><br><span class="line">  - ReferenceError对象是引用一个不存在的变量时发生的错误。</span><br><span class="line">  - RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</span><br><span class="line">  - TypeError对象是变量或参数不是预期类型时发生的错误。</span><br><span class="line">  - URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</span><br><span class="line">  - EvalError 对象，eval函数没有被正确执行时，会抛出EvalError错误。</span><br><span class="line">  总结，以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</span><br><span class="line">  3.自定义错误，除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</span><br><span class="line">  4.throw语句的作用是手动中断程序执行，抛出一个错误。</span><br><span class="line">  5.try...catch 结构，一旦发生错误，程序就中止执行了。</span><br><span class="line">  6.finally 代码块，try...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。</span><br><span class="line">  &lt;!-- 编程风格 --&gt;</span><br><span class="line">  1.“编程风格”（programming style）指的是编写代码的样式规则。</span><br><span class="line">  2.缩进，行首的空格和 Tab 键，都可以产生代码缩进效果（indent）。</span><br><span class="line">  3.区块，如果循环和判断的代码体只有一行，JavaScript 允许该区块（block）省略大括号。</span><br><span class="line">  4.圆括号（parentheses），在 JavaScript 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）。</span><br><span class="line">  5.行尾的分号，分号表示一条语句的结束。JavaScript 允许省略行尾的分号。</span><br><span class="line">  6.全局变量，JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。</span><br><span class="line">  7.变量声明，JavaScript 会自动将变量声明“提升”（hoist）到代码块（block）的头部。</span><br><span class="line">  8.with 语句，with可以减少代码的书写，但是会造成混淆。</span><br><span class="line">  9.相等和严格相等，JavaScript 有两个表示相等的运算符：“相等”（==）和“严格相等”（===）。</span><br><span class="line">  10.语句的合并，有些程序员追求简洁，喜欢合并不同目的的语句。</span><br><span class="line">  11.自增（++）和自减（--）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。</span><br><span class="line">  12.switch...case 结构，switch...case结构要求，在每一个case的最后一行必须是break语句，否则会接着运行下一个case。</span><br><span class="line">  &lt;!-- console 对象与控制台 --&gt;</span><br><span class="line">  1.console.log()，console.info()，console.debug()</span><br><span class="line">  - 方法用于在控制台输出信息。</span><br><span class="line">  2.console.warn()，console.error()</span><br><span class="line">  - 方法用于在控制台输出警告信息。</span><br><span class="line">  3.console.table()</span><br><span class="line">  - 对于某些复合类型的数据，console.table方法可以将其转为表格显示。</span><br><span class="line">  4.console.count()</span><br><span class="line">  - count方法用于计数，输出它被调用了多少次。</span><br><span class="line">  5.console.dir()，console.dirxml()</span><br><span class="line">  - dir方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</span><br><span class="line">  6.console.assert()</span><br><span class="line">  - console.assert方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</span><br><span class="line">  7.console.time()，console.timeEnd()</span><br><span class="line">  - 这两个方法用于计时，可以算出一个操作所花费的准确时间。</span><br><span class="line">  8.console.group()，console.groupEnd()，console.groupCollapsed()</span><br><span class="line">  - console.group和console.groupEnd这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</span><br><span class="line">  9.console.trace()，console.clear()</span><br><span class="line">  - console.trace方法显示当前执行的代码在堆栈中的调用路径。</span><br><span class="line">  - console.clear方法用于清除当前控制台的所有输出，将光标回置到第一行。</span><br><span class="line">  10.控制台命令行 API</span><br><span class="line">  - $_属性返回上一个表达式的值。</span><br><span class="line">  - $0 - $4，控制台保存了最近5个在 Elements 面板选中的 DOM 元素，$0代表倒数第一个（最近一个），$1代表倒数第二个，以此类推直到$4。</span><br><span class="line">  - $(selector)返回第一个匹配的元素，等同于document.querySelector()。</span><br><span class="line">  - $$(selector)返回选中的 DOM 对象，等同于document.querySelectorAll。</span><br><span class="line">  - $x(path)方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</span><br><span class="line">  - inspect(object)方法打开相关面板，并选中相应的元素，显示它的细节。</span><br><span class="line">  - getEventListeners(object)方法返回一个对象，该对象的成员为object登记了回调函数的各种事件（比如click或keydown），每个事件对应一个数组，数组的成员为该事件的回调函数。</span><br><span class="line">  - keys(object)方法返回一个数组，包含object的所有键名。</span><br><span class="line">  - values(object)方法返回一个数组，包含object的所有键值。</span><br><span class="line">  - monitorEvents(object[, events])方法监听特定对象上发生的特定事件。事件发生时，会返回一个Event对象，包含该事件的相关信息。</span><br><span class="line">  - unmonitorEvents方法用于停止监听。</span><br><span class="line">  - monitorEvents允许监听同一大类的事件。所有事件可以分成四个大类。</span><br><span class="line">    mouse：&quot;mousedown&quot;, &quot;mouseup&quot;, &quot;click&quot;, &quot;dblclick&quot;, &quot;mousemove&quot;, &quot;mouseover&quot;, &quot;mouseout&quot;, &quot;mousewheel&quot;</span><br><span class="line">    key：&quot;keydown&quot;, &quot;keyup&quot;, &quot;keypress&quot;, &quot;textInput&quot;</span><br><span class="line">    touch：&quot;touchstart&quot;, &quot;touchmove&quot;, &quot;touchend&quot;, &quot;touchcancel&quot;</span><br><span class="line">    control：&quot;resize&quot;, &quot;scroll&quot;, &quot;zoom&quot;, &quot;focus&quot;, &quot;blur&quot;, &quot;select&quot;, &quot;change&quot;, &quot;submit&quot;, &quot;reset&quot;</span><br><span class="line">  11.其他方法</span><br><span class="line">  - clear()：清除控制台的历史。</span><br><span class="line">  - copy(object)：复制特定 DOM 元素到剪贴板。</span><br><span class="line">  - dir(object)：显示特定对象的所有属性，是console.dir方法的别名。</span><br><span class="line">  - dirxml(object)：显示特定对象的 XML 形式，是console.dirxml方法的别名。</span><br><span class="line">  12.debugger 语句</span><br><span class="line">  - debugger语句主要用于除错，作用是设置断点。</span><br><span class="line">  &lt;!-- Object 对象 --&gt;</span><br><span class="line">  1.Object()</span><br><span class="line">  - Object本身是一个函数，可以当作工具方法使用，将任意值转为对象。</span><br><span class="line">  2.Object 构造函数</span><br><span class="line">  - Object不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用new命令。</span><br><span class="line">  3.Object 的静态方法</span><br><span class="line">  - Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。</span><br><span class="line">  - Object.getOwnPropertyNames方法与Object.keys类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。</span><br><span class="line">  4.对象属性模型的相关方法</span><br><span class="line">  - Object.getOwnPropertyDescriptor()：获取某个属性的描述对象。</span><br><span class="line">  - Object.defineProperty()：通过描述对象，定义某个属性。</span><br><span class="line">  - Object.defineProperties()：通过描述对象，定义多个属性。</span><br><span class="line">  5.控制对象状态的方法</span><br><span class="line">  - Object.preventExtensions()：防止对象扩展。</span><br><span class="line">  - Object.isExtensible()：判断对象是否可扩展。</span><br><span class="line">  - Object.seal()：禁止对象配置。</span><br><span class="line">  - Object.isSealed()：判断一个对象是否可配置。</span><br><span class="line">  - Object.freeze()：冻结一个对象。</span><br><span class="line">  - Object.isFrozen()：判断一个对象是否被冻结。</span><br><span class="line">  6.原型链相关方法</span><br><span class="line">  - Object.create()：该方法可以指定原型对象和属性，返回一个新的对象。</span><br><span class="line">  - Object.getPrototypeOf()：获取对象的Prototype对象。</span><br><span class="line">  7.Object 的实例方法</span><br><span class="line">  - Object.prototype.valueOf()：返回当前对象对应的值。</span><br><span class="line">  - Object.prototype.toString()：返回当前对象对应的字符串形式。</span><br><span class="line">  - Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。</span><br><span class="line">  - Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</span><br><span class="line">  - Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。</span><br><span class="line">  - Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。</span><br><span class="line">  &lt;!-- 属性描述对象 --&gt;</span><br><span class="line">  JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。</span><br><span class="line">  属性描述对象提供6个元属性。</span><br><span class="line">  - value是该属性的属性值，默认为undefined。</span><br><span class="line">  - writable是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为true。</span><br><span class="line">  - enumerable是一个布尔值，表示该属性是否可遍历，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。</span><br><span class="line">  - configurable是一个布尔值，表示可配置性，默认为true。如果设为false，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。</span><br><span class="line">  - get是一个函数，表示该属性的取值函数（getter），默认为undefined。</span><br><span class="line">  - set是一个函数，表示该属性的存值函数（setter），默认为undefined。</span><br><span class="line"></span><br><span class="line">  1.Object.getOwnPropertyDescriptor()方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。</span><br><span class="line">  2.Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。</span><br><span class="line">  3.Object.defineProperty()方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象。</span><br><span class="line">  4.propertyIsEnumerable()方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回false。</span><br><span class="line">  5.原属性，属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。</span><br><span class="line">  - value属性是目标属性的值。</span><br><span class="line">  - writable属性是一个布尔值，决定了目标属性的值（value）是否可以被改变。</span><br><span class="line">  - enumerable（可遍历性）返回一个布尔值，表示目标属性是否可遍历。</span><br><span class="line">  - configurable(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象。</span><br><span class="line">  6.存取器</span><br><span class="line">  - 除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用属性描述对象的set属性；取值函数称为getter，使用属性描述对象的get属性。</span><br><span class="line">  7.对象的拷贝</span><br><span class="line">  - 为了解决这个问题，我们可以通过Object.defineProperty方法来拷贝属性。</span><br><span class="line">  8.控制对象状态</span><br><span class="line">  - Object.preventExtensions方法可以使得一个对象无法再添加新的属性。</span><br><span class="line">  - Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。</span><br><span class="line">  - Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。</span><br><span class="line">  - Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。</span><br><span class="line">  - Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。</span><br><span class="line">  - Object.isFrozen方法用于检查一个对象是否使用了Object.freeze方法。</span><br><span class="line">  - 局限性，上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。</span><br><span class="line">  &lt;!-- Array 对象 --&gt;</span><br><span class="line">  1.Array是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</span><br><span class="line">  2.Array.isArray()，方法返回一个布尔值，表示参数是否为数组。</span><br><span class="line">  3.valueOf()，方法是一个所有对象都拥有的方法，表示对该对象求值。</span><br><span class="line">  4.toString()，方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。</span><br><span class="line">  5.push()，push方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。</span><br><span class="line">  6.pop()，pop方法用于删除数组的最后一个元素，并返回该元素。</span><br><span class="line">  7.shift()，shift()方法用于删除数组的第一个元素，并返回该元素。</span><br><span class="line">  8.unshift()，unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。</span><br><span class="line">  9.join()，join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。</span><br><span class="line">  10.concat()，concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</span><br><span class="line">  11.reverse()，reverse方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组。</span><br><span class="line">  12.slice()，slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。</span><br><span class="line">  13.splice()，splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</span><br><span class="line">  14.sort()，sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</span><br><span class="line">  15.map()，map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</span><br><span class="line">  15.forEach()，forEach方法与map方法很相似，也是对数组的所有成员依次执行参数函数。但是，forEach方法不返回值，只用来操作数据。</span><br><span class="line">  16.filter()，filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</span><br><span class="line">  17.some()，some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。</span><br><span class="line">  18.every()，every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。</span><br><span class="line">  19.reduce()，reduce是从左到右处理（从第一个成员到最后一个成员）。</span><br><span class="line">  20.reduceRight()，reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。</span><br><span class="line">  21.indexOf()，indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</span><br><span class="line">  22.lastIndexOf()，lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</span><br><span class="line">  23.链式使用</span><br><span class="line">  &lt;!-- 包装对象 --&gt;</span><br><span class="line">  1.valueOf()</span><br><span class="line">  - valueOf()方法返回包装对象实例对应的原始类型的值。</span><br><span class="line">  2.toString()</span><br><span class="line">  - toString()方法返回对应的字符串形式。</span><br><span class="line">  3.原始类型与实例对象的自动转换</span><br><span class="line">  - 原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。</span><br><span class="line">  4.自定义方法</span><br><span class="line">  - 除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用。</span><br><span class="line">  &lt;!-- Boolean 对象 --&gt;</span><br><span class="line">  1.Boolean对象是 JavaScript 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例。</span><br><span class="line">  2.Boolean 函数的类型转换作用</span><br><span class="line">  - Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。</span><br><span class="line">  &lt;!-- Number 对象 --&gt;</span><br><span class="line">  1.Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。</span><br><span class="line">  2.静态属性</span><br><span class="line">  - Number.POSITIVE_INFINITY：正的无限，指向Infinity。</span><br><span class="line">  - Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。</span><br><span class="line">  - Number.NaN：表示非数值，指向NaN。</span><br><span class="line">  - Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。</span><br><span class="line">  - Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。</span><br><span class="line">  - Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。</span><br><span class="line">  3.实例方法</span><br><span class="line">  - Number.prototype.toString()，Number对象部署了自己的toString方法，用来将一个数值转为字符串形式。</span><br><span class="line">  - Number.prototype.toFixed()，toFixed()方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</span><br><span class="line">  - Number.prototype.toExponential()，toExponential方法用于将一个数转为科学计数法形式。</span><br><span class="line">  - Number.prototype.toPrecision()，toPrecision方法用于将一个数转为指定位数的有效数字。</span><br><span class="line">  4.自定义方法</span><br><span class="line">  - 与其他对象一样，Number.prototype对象上面可以自定义方法，被Number的实例继承。</span><br><span class="line">  &lt;!-- String 对象 --&gt;</span><br><span class="line">  1.String对象是 JavaScript 原生提供的三个包装对象之一，用来生成字符串对象。</span><br><span class="line">  2.静态方法</span><br><span class="line">  - String.fromCharCode()，该方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。</span><br><span class="line">  3.实例属性</span><br><span class="line">  - String.prototype.length，字符串实例的length属性返回字符串的长度。</span><br><span class="line">  4.实例方法</span><br><span class="line">  - String.prototype.charAt()，charAt方法返回指定位置的字符，参数是从0开始编号的位置。</span><br><span class="line">  - String.prototype.charCodeAt()，charCodeAt方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于String.fromCharCode()的逆操作。</span><br><span class="line">  - String.prototype.concat()，concat方法用于连接两个字符串，返回一个新字符串，不改变原字符串。</span><br><span class="line">  - String.prototype.slice()，slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</span><br><span class="line">  - String.prototype.substring()，substring方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。</span><br><span class="line">  - String.prototype.substr()，substr方法用于从原字符串取出子字符串并返回，不改变原字符串，跟slice和substring方法的作用相同。</span><br><span class="line">  - String.prototype.indexOf()，indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</span><br><span class="line">  - String.prototype.lastIndexOf()，lastIndexOf方法的用法跟indexOf方法一致，主要的区别是lastIndexOf从尾部开始匹配，indexOf则是从头部开始匹配。</span><br><span class="line">  - String.prototype.trim()，trim方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。</span><br><span class="line">  - String.prototype.toLowerCase()，toLowerCase方法用于将一个字符串全部转为小写，返回一个新字符串，不改变原字符串。</span><br><span class="line">  - String.prototype.toUpperCase()，toUpperCase则是全部转为大写，返回一个新字符串，不改变原字符串。</span><br><span class="line">  - String.prototype.match()，match方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。</span><br><span class="line">  - String.prototype.search()，search方法的用法基本等同于match，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</span><br><span class="line">  - String.prototype.replace()，replace方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。</span><br><span class="line">  - String.prototype.split()，split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。</span><br><span class="line">  - String.prototype.localeCompare()，localeCompare方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</span><br><span class="line">  &lt;!-- Math 对象 --&gt;</span><br><span class="line">  1.Math是 JavaScript 的原生对象，提供各种数学功能。</span><br><span class="line">  2.静态方法</span><br><span class="line">  - Math.abs()：绝对值</span><br><span class="line">  - Math.ceil()：向上取整</span><br><span class="line">  - Math.floor()：向下取整</span><br><span class="line">  - Math.max()：最大值</span><br><span class="line">  - Math.min()：最小值</span><br><span class="line">  - Math.pow()：指数运算</span><br><span class="line">  - Math.sqrt()：平方根</span><br><span class="line">  - Math.log()：自然对数</span><br><span class="line">  - Math.exp()：e的指数</span><br><span class="line">  - Math.round()：四舍五入</span><br><span class="line">  - Math.random()：随机数</span><br><span class="line">  3.三角函数方法</span><br><span class="line">  - Math.sin()：返回参数的正弦（参数为弧度值）</span><br><span class="line">  - Math.cos()：返回参数的余弦（参数为弧度值）</span><br><span class="line">  - Math.tan()：返回参数的正切（参数为弧度值）</span><br><span class="line">  - Math.asin()：返回参数的反正弦（返回值为弧度值）</span><br><span class="line">  - Math.acos()：返回参数的反余弦（返回值为弧度值）</span><br><span class="line">  - Math.atan()：返回参数的反正切（返回值为弧度值）</span><br><span class="line">  &lt;!-- Date 对象 --&gt;</span><br><span class="line">  1.Date对象是 JavaScript 原生的时间库。Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。</span><br><span class="line">  2.构造函数的用法，Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。</span><br><span class="line">  3.日期的运算</span><br><span class="line">  4.静态方法</span><br><span class="line">  - Date.now()，返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</span><br><span class="line">  - Date.parse()，用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。</span><br><span class="line">  - Date.UTC()，接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。</span><br><span class="line">  - Date.prototype.valueOf()，返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法。</span><br><span class="line">  5.实例方法，Date的实例对象，有几十个自己的方法，除了valueOf和toString，可以分为以下三类。</span><br><span class="line">  - to类：从Date对象返回一个字符串，表示指定的时间。</span><br><span class="line">  - get类：获取Date对象的日期和时间。</span><br><span class="line">  - set类：设置Date对象的日期和时间。</span><br><span class="line">  6.to 类方法</span><br><span class="line">  - Date.prototype.toString()，toString方法返回一个完整的日期字符串。</span><br><span class="line">  - Date.prototype.toUTCString()，toUTCString方法返回对应的 UTC 时间，也就是比北京时间晚8个小时。</span><br><span class="line">  - Date.prototype.toISOString()，toISOString方法返回对应时间的 ISO8601 写法。</span><br><span class="line">  - Date.prototype.toJSON()，toJSON方法返回一个符合 JSON 格式的 ISO 日期字符串，与toISOString方法的返回结果完全相同。</span><br><span class="line">  - Date.prototype.toDateString()，toDateString方法返回日期字符串（不含小时、分和秒）。</span><br><span class="line">  - Date.prototype.toTimeString()，toTimeString方法返回时间字符串（不含年月日）。</span><br><span class="line">  - 本地时间</span><br><span class="line">    Date.prototype.toLocaleString()：完整的本地时间。</span><br><span class="line">    Date.prototype.toLocaleDateString()：本地日期（不含小时、分和秒）。</span><br><span class="line">    Date.prototype.toLocaleTimeString()：本地时间（不含年月日）。</span><br><span class="line">  7.get 类方法</span><br><span class="line">  - getTime()：返回实例距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。</span><br><span class="line">  - getDate()：返回实例对象对应每个月的几号（从1开始）。</span><br><span class="line">  - getDay()：返回星期几，星期日为0，星期一为1，以此类推。</span><br><span class="line">  - getFullYear()：返回四位的年份。</span><br><span class="line">  - getMonth()：返回月份（0表示1月，11表示12月）。</span><br><span class="line">  - getHours()：返回小时（0-23）。</span><br><span class="line">  - getMilliseconds()：返回毫秒（0-999）。</span><br><span class="line">  - getMinutes()：返回分钟（0-59）。</span><br><span class="line">  - getSeconds()：返回秒（0-59）。</span><br><span class="line">  - getTimezoneOffset()：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素。</span><br><span class="line">  8.set 类方法</span><br><span class="line">  - setDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。</span><br><span class="line">  - setFullYear(year [, month, date])：设置四位年份。</span><br><span class="line">  - setHours(hour [, min, sec, ms])：设置小时（0-23）。</span><br><span class="line">  - setMilliseconds()：设置毫秒（0-999）。</span><br><span class="line">  - setMinutes(min [, sec, ms])：设置分钟（0-59）。</span><br><span class="line">  - setMonth(month [, date])：设置月份（0-11）。</span><br><span class="line">  - setSeconds(sec [, ms])：设置秒（0-59）。</span><br><span class="line">  - setTime(milliseconds)：设置毫秒时间戳。</span><br><span class="line">  &lt;!-- RegExp 对象 --&gt;</span><br><span class="line">  1.实例属性</span><br><span class="line">  - RegExp.prototype.ignoreCase：返回一个布尔值，表示是否设置了i修饰符。</span><br><span class="line">  - RegExp.prototype.global：返回一个布尔值，表示是否设置了g修饰符。</span><br><span class="line">  - RegExp.prototype.multiline：返回一个布尔值，表示是否设置了m修饰符。</span><br><span class="line">  - RegExp.prototype.flags：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</span><br><span class="line">  2.实例方法</span><br><span class="line">  - RegExp.prototype.test()，正则实例对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。</span><br><span class="line">  - RegExp.prototype.exec()，正则实例对象的exec方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回null。</span><br><span class="line">  3.字符串的实例方法</span><br><span class="line">  - String.prototype.match()：返回一个数组，成员是所有匹配的子字符串。</span><br><span class="line">  - String.prototype.search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</span><br><span class="line">  - String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串。</span><br><span class="line">  - String.prototype.split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</span><br><span class="line">  4.匹配规则</span><br><span class="line">  - 字面量字符和元字符</span><br><span class="line">  * 点字符（.)，点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。</span><br><span class="line">  * 位置字符用来提示字符所处的位置，主要有两个字符。^ 表示字符串的开始位置，$ 表示字符串的结束位置。</span><br><span class="line">  * 选择符（|），竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。</span><br><span class="line">  - 转义符，正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。</span><br><span class="line">  - 特殊字符，正则表达式对一些不能打印的特殊字符，提供了表达方法：</span><br><span class="line">    * \cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。</span><br><span class="line">    *   [\b] 匹配退格键(U+0008)，不要与\b混淆。</span><br><span class="line">    *  \n 匹配换行键。</span><br><span class="line">    *  \r 匹配回车键。</span><br><span class="line">    *  \t 匹配制表符 tab（U+0009）。</span><br><span class="line">    *  \v 匹配垂直制表符（U+000B）。</span><br><span class="line">    *  \f 匹配换页符（U+000C）。</span><br><span class="line">    *  \0 匹配null字符（U+0000）。</span><br><span class="line">    *  \xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。</span><br><span class="line">    * \uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的 Unicode 字符。</span><br><span class="line">  - 字符类，字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。</span><br><span class="line">    * 脱字符（^），如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。</span><br><span class="line">    * 连字符（-），某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。</span><br><span class="line">  - 预定义模式：</span><br><span class="line">    \d 匹配0-9之间的任一数字，相当于[0-9]。</span><br><span class="line">    \D 匹配所有0-9以外的字符，相当于[^0-9]。</span><br><span class="line">    \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</span><br><span class="line">    \W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。</span><br><span class="line">    \s 匹配空格（包括换行符、制表符、空格符等），相等于[ \t\r\n\v\f]。</span><br><span class="line">    \S 匹配非空格的字符，相当于[^ \t\r\n\v\f]。</span><br><span class="line">    \b 匹配词的边界。</span><br><span class="line">    \B 匹配非词边界，即在词的内部。</span><br><span class="line">  - 重复类，模式的精确匹配次数，使用大括号（&#123;&#125;）表示。</span><br><span class="line">  - 量词符：</span><br><span class="line">    ? 问号表示某个模式出现0次或1次，等同于&#123;0, 1&#125;。</span><br><span class="line">    * 星号表示某个模式出现0次或多次，等同于&#123;0,&#125;。</span><br><span class="line">    + 加号表示某个模式出现1次或多次，等同于&#123;1,&#125;。</span><br><span class="line">  - 贪婪模式，上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。</span><br><span class="line">  - 修饰符，修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</span><br><span class="line">    * g 修饰符，g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</span><br><span class="line">    * i 修饰符，默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignoreCase）。</span><br><span class="line">    * m 修饰符，m修饰符表示多行模式（multiline），会修改^和$的行为。</span><br><span class="line">  - 组匹配，正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</span><br><span class="line">  - 非捕获组，(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</span><br><span class="line">  - 先行断言，x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。</span><br><span class="line">  - 先行否定断言，x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。</span><br><span class="line">  &lt;!-- JSON 对象 --&gt;</span><br><span class="line">  1.JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，</span><br><span class="line">  - 规定：</span><br><span class="line">    复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</span><br><span class="line">    原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。</span><br><span class="line">    字符串必须使用双引号表示，不能使用单引号。</span><br><span class="line">    对象的键名必须放在双引号里面。</span><br><span class="line">    数组或对象最后一个成员的后面，不能加逗号。</span><br><span class="line">  - JSON.stringify()，JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。</span><br><span class="line">  - JSON.parse()，JSON.parse方法用于将 JSON 字符串转换成对应的值。</span><br><span class="line">  &lt;!-- 实例对象与 new 命令 --&gt;</span><br><span class="line">  1.对象是什么？</span><br><span class="line">  - 对象是单个实物的抽象。</span><br><span class="line">  - 对象是一个容器，封装了属性（property）和方法（method）。</span><br><span class="line">  2.构造函数</span><br><span class="line">  - 函数体内部使用了this关键字，代表了所要生成的对象实例。</span><br><span class="line">  - 生成对象的时候，必须使用new命令。</span><br><span class="line">  3.new 命令</span><br><span class="line">  - new 命令的原理：</span><br><span class="line">    创建一个空对象，作为将要返回的对象实例。</span><br><span class="line">    将这个空对象的原型，指向构造函数的prototype属性。</span><br><span class="line">    将这个空对象赋值给函数内部的this关键字。</span><br><span class="line">    开始执行构造函数内部的代码。</span><br><span class="line">  - new.target</span><br><span class="line">    函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。</span><br><span class="line">  4.Object.create() 创建实例对象</span><br><span class="line">  构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用Object.create()方法。</span><br><span class="line">  &lt;!-- this 关键字 --&gt;</span><br><span class="line">  1.this就是属性或方法“当前”所在的对象。</span><br><span class="line">  2.JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</span><br><span class="line">  3.使用场合</span><br><span class="line">  - 全局环境，全局环境使用this，它指的就是顶层对象window。</span><br><span class="line">  - 构造函数，构造函数中的this，指的是实例对象。</span><br><span class="line">  - 对象的方法，如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。</span><br><span class="line">  4.使用注意点 </span><br><span class="line">  - 避免多层 this，由于this的指向是不确定的，所以切勿在函数中包含多层的this。</span><br><span class="line">  - 避免数组处理方法中的 this，数组的map和foreach方法，允许提供一个函数作为参数。</span><br><span class="line">  - 避免回调函数中的 this，回调函数中的this往往会改变指向，最好避免使用。</span><br><span class="line">  5.绑定 this 的方法</span><br><span class="line">  - Function.prototype.call()，函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</span><br><span class="line">  - Function.prototype.apply()，apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。一的区别就是，它接收一个数组作为函数执行时的参数。</span><br><span class="line">  - Function.prototype.bind()，bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。</span><br><span class="line">  &lt;!-- 对象的继承 --&gt;</span><br><span class="line">  1.构造函数的缺点，同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</span><br><span class="line">  2.prototype 属性的作用，JavaScript 规定，每个函数都有一个prototype属性，指向一个对象。</span><br><span class="line">  3.原型链，JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</span><br><span class="line">  4.constructor 属性，prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。</span><br><span class="line">  5.instanceof 运算符，instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</span><br><span class="line">  6.构造函数的继承</span><br><span class="line">    // 第一步，子类继承父类的实例</span><br><span class="line">    function Rectangle() &#123;</span><br><span class="line">      Shape.call(this); // 调用父类构造函数</span><br><span class="line">    &#125;</span><br><span class="line">    // 另一种写法</span><br><span class="line">    function Rectangle() &#123;</span><br><span class="line">      this.base = Shape;</span><br><span class="line">      this.base();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第二步，子类继承父类的原型</span><br><span class="line">    Rectangle.prototype = Object.create(Shape.prototype);</span><br><span class="line">    Rectangle.prototype.constructor = Rectangle;</span><br><span class="line">  7.多重继承</span><br><span class="line">    function M1() &#123;</span><br><span class="line">      this.hello = &apos;hello&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function M2() &#123;</span><br><span class="line">      this.world = &apos;world&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function S() &#123;</span><br><span class="line">      M1.call(this);</span><br><span class="line">      M2.call(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 继承 M1</span><br><span class="line">    S.prototype = Object.create(M1.prototype);</span><br><span class="line">    // 继承链上加入 M2</span><br><span class="line">    Object.assign(S.prototype, M2.prototype);</span><br><span class="line"></span><br><span class="line">    // 指定构造函数</span><br><span class="line">    S.prototype.constructor = S;</span><br><span class="line"></span><br><span class="line">    var s = new S();</span><br><span class="line">    s.hello // &apos;hello&apos;</span><br><span class="line">    s.world // &apos;world&apos;</span><br><span class="line">  8.模块</span><br><span class="line">  - 模块是实现特定功能的一组属性和方法的封装。</span><br><span class="line">  var module1 = new Object(&#123;</span><br><span class="line">  　_count : 0,</span><br><span class="line">  　m1 : function ()&#123;</span><br><span class="line">  　　//...</span><br><span class="line">  　&#125;,</span><br><span class="line">  　m2 : function ()&#123;</span><br><span class="line">    　//...</span><br><span class="line">  　&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  - 封装私有变量：构造函数的写法</span><br><span class="line">  function StringBuilder() &#123;</span><br><span class="line">    var buffer = [];</span><br><span class="line"></span><br><span class="line">    this.add = function (str) &#123;</span><br><span class="line">       buffer.push(str);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.toString = function () &#123;</span><br><span class="line">      return buffer.join(&apos;&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  - 封装私有变量：立即执行函数的写法</span><br><span class="line">  var module1 = (function () &#123;</span><br><span class="line">  　var _count = 0;</span><br><span class="line">  　var m1 = function () &#123;</span><br><span class="line">  　  //...</span><br><span class="line">  　&#125;;</span><br><span class="line">  　var m2 = function () &#123;</span><br><span class="line">  　　//...</span><br><span class="line">  　&#125;;</span><br><span class="line">  　return &#123;</span><br><span class="line">  　　m1 : m1,</span><br><span class="line">  　　m2 : m2</span><br><span class="line">  　&#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">  9.模块的放大模式</span><br><span class="line">  var module1 = (function (mod)&#123;</span><br><span class="line">  　mod.m3 = function () &#123;</span><br><span class="line">  　　//...</span><br><span class="line">  　&#125;;</span><br><span class="line">  　return mod;</span><br><span class="line">  &#125;)(module1);</span><br><span class="line">  10.输入全局变量：独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</span><br><span class="line">  var module1 = (function ($, YAHOO) &#123;</span><br><span class="line">  　//...</span><br><span class="line">  &#125;)(jQuery, YAHOO);</span><br><span class="line">  &lt;!-- Object 对象的相关方法 --&gt;</span><br><span class="line">  1.Object.getPrototypeOf()，Object.getPrototypeOf方法返回参数对象的原型。这是获取原型对象的标准方法。</span><br><span class="line">  2.Object.setPrototypeOf()，Object.setPrototypeOf方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</span><br><span class="line">  3.Object.create()，生成实例对象的常用方法是，使用new命令让构造函数返回一个实例。</span><br><span class="line">  4.Object.prototype.isPrototypeOf()，实例对象的isPrototypeOf方法，用来判断该对象是否为参数对象的原型。</span><br><span class="line">  5.Object.prototype.__proto__，实例对象的__proto__属性（前后各两个下划线），返回该对象的原型。该属性可读写。</span><br><span class="line">  6.获取原型对象方法的比较，获取实例对象obj的原型对象，有三种方法。</span><br><span class="line">  - obj.__proto__</span><br><span class="line">  - obj.constructor.prototype</span><br><span class="line">  - Object.getPrototypeOf(obj)</span><br><span class="line">  7.Object.getOwnPropertyNames()，Object.getOwnPropertyNames方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。</span><br><span class="line">  8.Object.prototype.hasOwnProperty()，对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</span><br><span class="line">  9.in 运算符和 for...in 循环，in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。</span><br><span class="line">  10.对象的拷贝Object.getOwnPropertyDescriptors方法。</span><br><span class="line">  &lt;!-- 严格模式 --&gt;</span><br><span class="line">  1.设计目的</span><br><span class="line">  - 明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</span><br><span class="line">  - 增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</span><br><span class="line">  - 提高编译器效率，增加运行速度。</span><br><span class="line">  - 为未来新版本的 JavaScript 语法做好铺垫。</span><br><span class="line">  2.启用方法，进入严格模式的标志，是一行字符串use strict。</span><br><span class="line">  3.显式报错，严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。</span><br><span class="line">  - 只读属性不可写</span><br><span class="line">  - 只设置了取值器的属性不可写</span><br><span class="line">  - 禁止扩展的对象不可扩展</span><br><span class="line">  - eval、arguments 不可用作标识名</span><br><span class="line">  - 函数不能有重名的参数</span><br><span class="line">  - 禁止八进制的前缀0表示法</span><br><span class="line">  4.增强的安全措施</span><br><span class="line">  - 全局变量显式声明 </span><br><span class="line">  - 禁止 this 关键字指向全局对象</span><br><span class="line">  - 禁止使用 fn.callee、fn.caller</span><br><span class="line">  - 禁止使用 arguments.callee、arguments.caller</span><br><span class="line">  - 禁止删除变量</span><br><span class="line">  5.静态绑定</span><br><span class="line">  - 禁止使用 with 语句</span><br><span class="line">  - 创设 eval 作用域</span><br><span class="line">  - arguments 不再追踪参数的变化</span><br><span class="line">  6.向下一个版本的 JavaScript 过渡</span><br><span class="line">  - 非函数代码块不得声明函数</span><br><span class="line">  - 保留字</span><br><span class="line">  &lt;!-- 异步操作概述 --&gt;</span><br><span class="line">  1.单线程模型，单线程模型指的是，JavaScript 只在一个线程上运行。</span><br><span class="line">  2.同步任务和异步任务，程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</span><br><span class="line">  3.任务队列和事件循环，JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。</span><br><span class="line">  4.异步操作的模式</span><br><span class="line">  - 回调函数，回调函数是异步操作最基本的方法。</span><br><span class="line">  - 事件监听，另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</span><br><span class="line">  - 发布/订阅，事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）。</span><br><span class="line">  5.异步操作的流程控制</span><br><span class="line">  - 串行执行，我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</span><br><span class="line">  - 并行执行，流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。</span><br><span class="line">  - 并行与串行的结合，所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务，这样就避免了过分占用系统资源。</span><br><span class="line">  &lt;!-- 定时器 --&gt;</span><br><span class="line">  JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。</span><br><span class="line">  1.setTimeout()，setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</span><br><span class="line">  2.setInterval()，setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</span><br><span class="line">  3.clearTimeout()，clearInterval()，setTimeout和setInterval函数，都返回一个整数值，表示计数器编号。将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。</span><br><span class="line">  4.实例：debounce 函数</span><br><span class="line">  5.运行机制，setTimeout和setInterval的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。</span><br><span class="line">  6.setTimeout(f, 0)，setTimeout(f, 0)会在下一轮事件循环一开始就执行。</span><br><span class="line">  7.应用，setTimeout(f, 0)有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。</span><br><span class="line">  &lt;!-- Promise 对象 --&gt;</span><br><span class="line">  Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。</span><br><span class="line">  1.Promise 对象的状态，Promise 实例具有三种状态。</span><br><span class="line">  - 异步操作未完成（pending）</span><br><span class="line">  - 异步操作成功（fulfilled）</span><br><span class="line">  - 异步操作失败（rejected）</span><br><span class="line">  2.Promise 构造函数，JavaScript 提供原生的Promise构造函数，用来生成 Promise 实例。</span><br><span class="line">  3.Promise.prototype.then()，Promise 实例的then方法，用来添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时（变为fulfilled状态）的回调函数，第二个是异步操作失败（变为rejected）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</span><br><span class="line">  4.then() 用法辨析</span><br><span class="line">  5.实例：图片加载</span><br><span class="line">  var preloadImage = function (path) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">      var image = new Image();</span><br><span class="line">      image.onload  = resolve;</span><br><span class="line">      image.onerror = reject;</span><br><span class="line">      image.src = path;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。</span><br><span class="line">  6.微任务，Promise 的回调函数属于异步任务，会在同步任务之后执行。</span><br><span class="line">  new Promise(function (resolve, reject) &#123;</span><br><span class="line">    resolve(1);</span><br><span class="line">  &#125;).then(console.log);</span><br><span class="line"></span><br><span class="line">  console.log(2);</span><br><span class="line">  // 2</span><br><span class="line">  // 1</span><br><span class="line">  &lt;!-- DOM 概述 --&gt;</span><br><span class="line">  1.DOM 的最小组成单位叫做节点（node）。节点的类型有七种。</span><br><span class="line">  - Document：整个文档树的顶层节点</span><br><span class="line">  - DocumentType：doctype标签（比如&lt;!DOCTYPE html&gt;）</span><br><span class="line">  - Element：网页的各种HTML标签（比如&lt;body&gt;、&lt;a&gt;等）</span><br><span class="line">  - Attribute：网页元素的属性（比如class=&quot;right&quot;）</span><br><span class="line">  - Text：标签之间或标签包含的文本</span><br><span class="line">  - Comment：注释</span><br><span class="line">  - DocumentFragment：文档的片段</span><br><span class="line">  2.节点树</span><br><span class="line">  一个文档的所有节点，按照所在的层级，可以抽象成一种树状结构。这种树状结构就是 DOM 树。除了根节点，其他节点都有三种层级关系。</span><br><span class="line">  - 父节点关系（parentNode）：直接的那个上级节点</span><br><span class="line">  - 子节点关系（childNodes）：直接的下级节点</span><br><span class="line">  - 同级节点关系（sibling）：拥有同一个父节点的节点</span><br><span class="line">  3.DOM 提供操作接口，用来获取这三种关系的节点。</span><br><span class="line">  - 子节点接口包括firstChild（第一个子节点）lastChild（最后一个子节点）等属性</span><br><span class="line">  - 同级节点接口包括nextSibling（紧邻在后的那个同级节点）previousSibling（紧邻在前的那个同级节点）属性。</span><br><span class="line">  &lt;!-- Node 接口 --&gt;</span><br><span class="line">  1.Node.prototype.nodeType，nodeType属性返回一个整数值，表示节点的类型。</span><br><span class="line">  2.Node.prototype.nodeName，nodeName属性返回节点的名称。</span><br><span class="line">  不同节点的nodeName属性值如下。</span><br><span class="line">  - 文档节点（document）：#document</span><br><span class="line">  - 元素节点（element）：大写的标签名</span><br><span class="line">  - 属性节点（attr）：属性的名称</span><br><span class="line">  - 文本节点（text）：#text</span><br><span class="line">  - 文档片断节点（DocumentFragment）：#document-fragment</span><br><span class="line">  - 文档类型节点（DocumentType）：文档的类型</span><br><span class="line">  - 注释节点（Comment）：#comment</span><br><span class="line">  3.Node.prototype.nodeValue，nodeValue属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的nodeValue可以返回结果，其他类型的节点一律返回null。</span><br><span class="line">  4.Node.prototype.textContent，textContent属性返回当前节点和它的所有后代节点的文本内容。</span><br><span class="line">  5.Node.prototype.baseURI，baseURI属性返回一个字符串，表示当前网页的绝对路径。</span><br><span class="line">  6.Node.prototype.ownerDocument，Node.ownerDocument属性返回当前节点所在的顶层文档对象，即document对象。</span><br><span class="line">  7.Node.prototype.nextSibling，Node.nextSibling属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回null。</span><br><span class="line">  8.Node.prototype.previousSibling，previousSibling属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回null。</span><br><span class="line">  9.Node.prototype.parentNode，parentNode属性返回当前节点的父节点。对于一个节点来说，它的父节点只可能是三种类型：元素节点（element）、文档节点（document）和文档片段节点（documentfragment）。</span><br><span class="line">  10.Node.prototype.parentElement，parentElement属性返回当前节点的父元素节点。如果当前节点没有父节点，或者父节点类型不是元素节点，则返回null。</span><br><span class="line">  11.Node.prototype.firstChild，Node.prototype.lastChild，firstChild属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回null。lastChild属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回null。用法与firstChild属性相同。</span><br><span class="line">  12.Node.prototype.childNodes，childNodes属性返回一个类似数组的对象（NodeList集合），成员包括当前节点的所有子节点。</span><br><span class="line">  13.Node.prototype.isConnected，isConnected属性返回一个布尔值，表示当前节点是否在文档之中。</span><br><span class="line">  14.Node.prototype.appendChild()，appendChild()方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点。该方法的返回值就是插入文档的子节点。</span><br><span class="line">  15.Node.prototype.hasChildNodes()，hasChildNodes方法返回一个布尔值，表示当前节点是否有子节点。</span><br><span class="line">  - node.hasChildNodes()</span><br><span class="line">  - node.firstChild !== null</span><br><span class="line">  - node.childNodes &amp;&amp; node.childNodes.length &gt; 0</span><br><span class="line">  hasChildNodes方法结合firstChild属性和nextSibling属性，可以遍历当前节点的所有后代节点。</span><br><span class="line">  16.Node.prototype.cloneNode()，cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。它的返回值是一个克隆出来的新节点。</span><br><span class="line">  17.Node.prototype.insertBefore()，insertBefore方法用于将某个节点插入父节点内部的指定位置。</span><br><span class="line">  18.Node.prototype.removeChild()，removeChild方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。</span><br><span class="line">  19.Node.prototype.replaceChild()，replaceChild方法用于将一个新的节点，替换当前节点的某一个子节点。</span><br><span class="line">  20.Node.prototype.contains()，contains方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。</span><br><span class="line">  - 参数节点为当前节点。</span><br><span class="line">  - 参数节点为当前节点的子节点。</span><br><span class="line">  - 参数节点为当前节点的后代节点。</span><br><span class="line">  21.Node.prototype.compareDocumentPosition()，compareDocumentPosition方法的用法，与contains方法完全一致，返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。</span><br><span class="line">  22.Node.prototype.isEqualNode()，Node.prototype.isSameNode()，isEqualNode方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</span><br><span class="line">  23.Node.prototype.normalize()，normalize方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点。</span><br><span class="line">  24.Node.prototype.getRootNode()，getRootNode()方法返回当前节点所在文档的根节点document，与ownerDocument属性的作用相同。</span><br><span class="line">  &lt;!-- NodeList 接口，HTMLCollection 接口 --&gt;</span><br><span class="line">  1.NodeList 接口，NodeList实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例。</span><br><span class="line">  - Node.childNodes</span><br><span class="line">  - document.querySelectorAll()等节点搜索方法</span><br><span class="line">  2.NodeList.prototype.length，length属性返回 NodeList 实例包含的节点数量。</span><br><span class="line">  3.NodeList.prototype.forEach()，forEach方法用于遍历 NodeList 的所有成员。它接受一个回调函数作为参数，每一轮遍历就执行一次这个回调函数，用法与数组实例的forEach方法完全一致。</span><br><span class="line">  4.NodeList.prototype.item()，item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</span><br><span class="line">  5.NodeList.prototype.keys()，NodeList.prototype.values()，NodeList.prototype.entries() ，这三个方法都返回一个 ES6 的遍历器对象，可以通过for...of循环遍历获取每一个成员的信息。区别在于，keys()返回键名的遍历器，values()返回键值的遍历器，entries()返回的遍历器同时包含键名和键值的信息。</span><br><span class="line">  6.HTMLCollection 接口，HTMLCollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。</span><br><span class="line">  7.HTMLCollection.prototype.length，length属性返回HTMLCollection实例包含的成员数量。</span><br><span class="line">  8.HTMLCollection.prototype.item()，item方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。</span><br><span class="line">  9.HTMLCollection.prototype.namedItem()，namedItem方法的参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有对应的节点，则返回null。</span><br><span class="line">  &lt;!-- ParentNode 接口，ChildNode 接口 --&gt;</span><br><span class="line">  ParentNode接口表示当前节点是一个父节点，提供一些处理子节点的方法。ChildNode接口表示当前节点是一个子节点，提供一些相关方法。</span><br><span class="line">  1.ParentNode.children，children属性返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。</span><br><span class="line">  2.ParentNode.firstElementChild，firstElementChild属性返回当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null。</span><br><span class="line">  3.ParentNode.lastElementChild，lastElementChild属性返回当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null。</span><br><span class="line">  4.ParentNode.childElementCount，childElementCount属性返回一个整数，表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点，则返回0。</span><br><span class="line">  5.ParentNode.append()，ParentNode.prepend()</span><br><span class="line">  - append方法为当前节点追加一个或多个子节点，位置是最后一个元素子节点的后面。该方法不仅可以添加元素子节点，还可以添加文本子节点。</span><br><span class="line">  - prepend方法为当前节点追加一个或多个子节点，位置是第一个元素子节点的前面。它的用法与append方法完全一致，也是没有返回值。</span><br><span class="line">  6.ChildNode 接口</span><br><span class="line">  - ChildNode.remove()，remove方法用于从父节点移除当前节点。</span><br><span class="line">  - ChildNode.before()，ChildNode.after()，before方法用于在当前节点的前面，插入一个或多个同级节点。两者拥有相同的父节点。注意，该方法不仅可以插入元素节点，还可以插入文本节点。after方法用于在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。用法与before方法完全相同。</span><br><span class="line">  - ChildNode.replaceWith()，replaceWith方法使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点。</span><br><span class="line">  &lt;!-- Document 节点 --&gt;</span><br><span class="line">  1.document节点对象代表整个文档，每张网页都有自己的document对象。document对象有不同的办法可以获取。</span><br><span class="line">  - 正常的网页，直接使用document或window.document。</span><br><span class="line">  - iframe框架里面的网页，使用iframe节点的contentDocument属性。</span><br><span class="line">  - Ajax 操作返回的文档，使用XMLHttpRequest对象的responseXML属性。</span><br><span class="line">  - 内部节点的ownerDocument属性。</span><br><span class="line">  2.快捷方式属性</span><br><span class="line">  - document.defaultView，document.defaultView属性返回document对象所属的window对象。如果当前文档不属于window对象，该属性返回null。</span><br><span class="line">  - document.doctype，对于 HTML 文档来说，document对象一般有两个子节点。第一个子节点是document.doctype，指向&lt;DOCTYPE&gt;节点，即文档类型（Document Type Declaration，简写DTD）节点。HTML 的文档类型节点，一般写成&lt;!DOCTYPE html&gt;。如果网页没有声明 DTD，该属性返回null。</span><br><span class="line">  - document.documentElement，document.documentElement属性返回当前文档的根元素节点（root）。它通常是document节点的第二个子节点，紧跟在document.doctype节点后面。HTML网页的该属性，一般是&lt;html&gt;节点。</span><br><span class="line">  - document.body，document.head，document.body属性指向&lt;body&gt;节点，document.head属性指向&lt;head&gt;节点。这两个属性总是存在的，如果网页源码里面省略了&lt;head&gt;或&lt;body&gt;，浏览器会自动创建。另外，这两个属性是可写的，如果改写它们的值，相当于移除所有子节点。</span><br><span class="line">  - document.scrollingElement，document.scrollingElement属性返回文档的滚动元素。也就是说，当文档整体滚动时，到底是哪个元素在滚动。标准模式下，这个属性返回的文档的根元素document.documentElement（即&lt;html&gt;）。兼容（quirk）模式下，返回的是&lt;body&gt;元素，如果该元素不存在，返回null。</span><br><span class="line">  - document.activeElement，document.activeElement属性返回获得当前焦点（focus）的 DOM 元素。通常，这个属性返回的是&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;等表单元素，如果当前没有焦点元素，返回&lt;body&gt;元素或null。</span><br><span class="line">  - document.fullscreenElement，document.fullscreenElement属性返回当前以全屏状态展示的 DOM 元素。如果不是全屏状态，该属性返回null。</span><br><span class="line">  3.节点集合属性</span><br><span class="line">  - document.links，document.links属性返回当前文档所有设定了href属性的&lt;a&gt;及&lt;area&gt;节点。</span><br><span class="line">  - document.forms，document.forms属性返回所有&lt;form&gt;表单节点。</span><br><span class="line">  - document.images，document.images属性返回页面所有&lt;img&gt;图片节点。</span><br><span class="line">  - document.embeds，document.plugins，document.embeds属性和document.plugins属性，都返回所有&lt;embed&gt;节点。</span><br><span class="line">  - document.scripts，document.scripts属性返回所有&lt;script&gt;节点。</span><br><span class="line">  - document.styleSheets，document.styleSheets属性返回文档内嵌或引入的样式表集合</span><br><span class="line">    document.links instanceof HTMLCollection // true</span><br><span class="line">    document.images instanceof HTMLCollection // true</span><br><span class="line">    document.forms instanceof HTMLCollection // true</span><br><span class="line">    document.embeds instanceof HTMLCollection // true</span><br><span class="line">    document.scripts instanceof HTMLCollection // true</span><br><span class="line">    HTMLCollection实例是类似数组的对象，所以这些属性都有length属性，都可以使用方括号运算符引用成员。如果成员有id或name属性，还可以用这两个属性的值，在HTMLCollection实例上引用到这个成员。</span><br><span class="line">  - 文档静态信息属性</span><br><span class="line">  - document.documentURI，document.URL，document.documentURI属性和document.URL属性都返回一个字符串，表示当前文档的网址。不同之处是它们继承自不同的接口，documentURI继承自Document接口，可用于所有文档；URL继承自HTMLDocument接口，只能用于 HTML 文档。</span><br><span class="line">  - document.domain，document.domain属性返回当前文档的域名，不包含协议和端口。比如，网页的网址是http://www.example.com:80/hello.html，那么document.domain属性就等于www.example.com。如果无法获取域名，该属性返回null。</span><br><span class="line">  - document.location，Location对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过window.location和document.location属性，可以拿到这个对象。</span><br><span class="line">  - document.lastModified，document.lastModified属性返回一个字符串，表示当前文档最后修改的时间。不同浏览器的返回值，日期格式是不一样的。</span><br><span class="line">  - document.title，document.title属性返回当前文档的标题。默认情况下，返回&lt;title&gt;节点的值。但是该属性是可写的，一旦被修改，就返回修改后的值。</span><br><span class="line">  - document.characterSet，document.characterSet属性返回当前文档的编码，比如UTF-8、ISO-8859-1等等。</span><br><span class="line">  - document.referrer，document.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。</span><br><span class="line">  - document.dir，document.dir返回一个字符串，表示文字方向。它只有两个可能的值：rtl表示文字从右到左，阿拉伯文是这种方式；ltr表示文字从左到右，包括英语和汉语在内的大多数文字采用这种方式。</span><br><span class="line">  - document.compatMode，compatMode属性返回浏览器处理文档的模式，可能的值为BackCompat（向后兼容模式）和CSS1Compat（严格模式）。</span><br><span class="line">  4.文档状态属性</span><br><span class="line">  - document.hidden，document.hidden属性返回一个布尔值，表示当前页面是否可见。如果窗口最小化、浏览器切换了 Tab，都会导致导致页面不可见，使得document.hidden返回true。</span><br><span class="line">  - document.visibilityState，document.visibilityState返回文档的可见状态。</span><br><span class="line">    visible：页面可见。注意，页面可能是部分可见，即不是焦点窗口，前面被其他窗口部分挡住了。</span><br><span class="line">    hidden：页面不可见，有可能窗口最小化，或者浏览器切换到了另一个 Tab。</span><br><span class="line">    prerender：页面处于正在渲染状态，对于用户来说，该页面不可见。</span><br><span class="line">    unloaded：页面从内存里面卸载了。</span><br><span class="line">  - document.readyState，document.readyState属性返回当前文档的状态，共有三种可能的值。</span><br><span class="line">    loading：加载 HTML 代码阶段（尚未完成解析）</span><br><span class="line">    interactive：加载外部资源阶段</span><br><span class="line">    complete：加载完成</span><br><span class="line">  - document.cookie，document.cookie属性用来操作浏览器 Cookie</span><br><span class="line">  - document.designMode，document.designMode属性控制当前文档是否可编辑。</span><br><span class="line">  - document.implementation，document.implementation属性返回一个DOMImplementation对象。该对象有三个方法，主要用于创建独立于当前文档的新的 Document 对象。</span><br><span class="line">    DOMImplementation.createDocument()：创建一个 XML 文档。</span><br><span class="line">    DOMImplementation.createHTMLDocument()：创建一个 HTML 文档。</span><br><span class="line">    DOMImplementation.createDocumentType()：创建一个 DocumentType 对象。</span><br><span class="line">  5.方法</span><br><span class="line">  - document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。</span><br><span class="line">  - document.close方法用来关闭document.open()打开的文档。</span><br><span class="line">  - document.write方法用于向当前文档写入内容。在网页的首次渲染阶段，只要页面没有关闭写入（即没有执行document.close()），document.write写入的内容就会追加在已有内容的后面。</span><br><span class="line">  - document.querySelector()，document.querySelectorAll()，document.querySelector方法接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回null。</span><br><span class="line">  - document.getElementsByTagName()，document.getElementsByTagName方法搜索 HTML 标签名，返回符合条件的元素。它的返回值是一个类似数组对象（HTMLCollection实例），可以实时反映 HTML 文档的变化。如果没有任何匹配的元素，就返回一个空集。</span><br><span class="line">  - document.getElementsByClassName()，document.getElementsByClassName方法返回一个类似数组的对象（HTMLCollection实例），包括了所有class名字符合指定条件的元素，元素的变化实时反映在返回结果中。</span><br><span class="line">  - document.getElementsByName()，document.getElementsByName方法用于选择拥有name属性的 HTML 元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等），返回一个类似数组的的对象（NodeList实例），因为name属性相同的元素可能不止一个。</span><br><span class="line">  - document.getElementById()，document.getElementById方法返回匹配指定id属性的元素节点。如果没有发现匹配的节点，则返回null。</span><br><span class="line">  - document.elementFromPoint()，document.elementsFromPoint()，document.elementFromPoint方法返回位于页面指定位置最上层的元素节点。document.elementsFromPoint()返回一个数组，成员是位于指定坐标（相对于视口）的所有元素。</span><br><span class="line">  - document.createElement()，document.createElement方法用来生成元素节点，并返回该节点。</span><br><span class="line">  - document.createTextNode()，document.createTextNode方法用来生成文本节点（Text实例），并返回该节点。它的参数是文本节点的内容。</span><br><span class="line">  - document.createAttribute()，document.createAttribute方法生成一个新的属性节点（Attr实例），并返回它。</span><br><span class="line">  - document.createComment()，document.createComment方法生成一个新的注释节点，并返回该节点。</span><br><span class="line">  - document.createDocumentFragment()，document.createDocumentFragment方法生成一个空的文档片段对象（DocumentFragment实例）。</span><br><span class="line">  - document.createEvent()，document.createEvent方法生成一个事件对象（Event实例），该对象可以被element.dispatchEvent方法使用，触发指定事件。</span><br><span class="line">  - document.hasFocus()，document.hasFocus方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</span><br><span class="line">  - document.adoptNode()，document.importNode()，document.adoptNode方法将某个节点及其子节点，从原来所在的文档或DocumentFragment里面移除，归属当前document对象，返回插入后的新节点。插入的节点对象的ownerDocument属性，会变成当前的document对象，而parentNode属性是null。</span><br><span class="line">  - document.createNodeIterator()，document.createNodeIterator方法返回一个子节点遍历器。</span><br><span class="line">  - document.createTreeWalker()，document.createTreeWalker方法返回一个 DOM 的子树遍历器。它与document.createNodeIterator方法基本是类似的，区别在于它返回的是TreeWalker实例，后者返回的是NodeIterator实例。另外，它的第一个节点不是根节点。document.createTreeWalker方法的第一个参数是所要遍历的根节点，第二个参数指定所要遍历的节点类型（与document.createNodeIterator方法的第二个参数相同）。</span><br><span class="line">  - document.execCommand()，如果document.designMode属性设为on，那么整个文档用户可编辑；如果元素的contenteditable属性设为true，那么该元素可编辑。</span><br><span class="line">  - document.execCommand()的返回值是一个布尔值。如果为false，表示这个方法无法生效。</span><br><span class="line">  - document.execCommand()方法可以执行的样式改变有很多种，下面是其中的一些：bold、insertLineBreak、selectAll、createLink、insertOrderedList、subscript、delete、insertUnorderedList、superscript、formatBlock、insertParagraph、undo、forwardDelete、insertText、unlink、insertImage、italic、unselect、insertHTML、redo。</span><br><span class="line">  - document.queryCommandSupported()，document.queryCommandSupported()方法返回一个布尔值，表示浏览器是否支持document.execCommand()的某个命令。</span><br><span class="line">  - document.queryCommandEnabled()，document.queryCommandEnabled()方法返回一个布尔值，表示当前是否可用document.execCommand()的某个命令。</span><br><span class="line">  - document.getSelection() ，这个方法指向window.getSelection()。</span><br><span class="line">  // Element 节点</span><br><span class="line">  1.Element.id，Element.id属性返回指定元素的id属性，该属性可读写。</span><br><span class="line">  2.Element.tagName，Element.tagName属性返回指定元素的大写标签名，与nodeName属性的值相等。</span><br><span class="line">  3.Element.dir，Element.dir属性用于读写当前元素的文字方向，可能是从左到右（&quot;ltr&quot;），也可能是从右到左（&quot;rtl&quot;）。</span><br><span class="line">  4.Element.accessKey，Element.accessKey属性用于读写分配给当前元素的快捷键。</span><br><span class="line">  5.Element.draggable，Element.draggable属性返回一个布尔值，表示当前元素是否可拖动。该属性可读写。</span><br><span class="line">  6.Element.lang，Element.lang属性返回当前元素的语言设置。该属性可读写。</span><br><span class="line">  7.Element.tabIndex，Element.tabIndex属性返回一个整数，表示当前元素在 Tab 键遍历时的顺序。该属性可读写。</span><br><span class="line">  8.Element.title，Element.title属性用来读写当前元素的 HTML 属性title。该属性通常用来指定，鼠标悬浮时弹出的文字提示框。</span><br><span class="line">  9.Element.hidden，Element.hidden属性返回一个布尔值，表示当前元素的hidden属性，用来控制当前元素是否可见。</span><br><span class="line">  10.Element.contentEditable，Element.isContentEditable，Element.contentEditable属性返回一个字符串，表示是否设置了contenteditable属性，有三种可能的值。该属性可写。</span><br><span class="line">      &quot;true&quot;：元素内容可编辑</span><br><span class="line">      &quot;false&quot;：元素内容不可编辑</span><br><span class="line">      &quot;inherit&quot;：元素是否可编辑，继承了父元素的设置</span><br><span class="line">    Element.isContentEditable属性返回一个布尔值，同样表示是否设置了contenteditable属性。该属性只读。</span><br><span class="line">  11.Element.attributes，Element.attributes属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点。</span><br><span class="line">  12.Element.className，Element.classList，className属性用来读写当前元素节点的class属性。它的值是一个字符串，每个class之间用空格分割。</span><br><span class="line">classList属性返回一个类似数组的对象，当前元素节点的每个class就是这个对象的一个成员。</span><br><span class="line">  classList对象有下列方法。</span><br><span class="line">    add()：增加一个 class。</span><br><span class="line">    remove()：移除一个 class。</span><br><span class="line">    contains()：检查当前元素是否包含某个 class。</span><br><span class="line">    toggle()：将某个 class 移入或移出当前元素。</span><br><span class="line">    item()：返回指定索引位置的 class。</span><br><span class="line">    toString()：将 class 的列表转为字符串。</span><br><span class="line">  13.Element.dataset，网页元素可以自定义data-属性，用来添加数据。</span><br><span class="line">  14.Element.innerHTML，Element.innerHTML属性返回一个字符串，等同于该元素包含的所有 HTML 代码。该属性可读写，常用来设置某个节点的内容。它能改写所有元素节点的内容，包括&lt;HTML&gt;和&lt;body&gt;元素。</span><br><span class="line">  15.Element.outerHTML，Element.outerHTML属性返回一个字符串，表示当前元素节点的所有 HTML 代码，包括该元素本身和所有子元素。</span><br><span class="line">  16.Element.clientHeight，Element.clientWidth</span><br><span class="line">  17.Element.clientLeft，Element.clientTop</span><br><span class="line">  18.Element.scrollHeight，Element.scrollWidth</span><br><span class="line">  19.Element.scrollLeft，Element.scrollTop</span><br><span class="line">  20.Element.offsetParent </span><br><span class="line">  21.Element.offsetHeight，Element.offsetWidth</span><br><span class="line">  22.Element.offsetLeft，Element.offsetTop</span><br><span class="line">  23.Element.style</span><br><span class="line">  24.Element.children，Element.childElementCount</span><br><span class="line">  25.Element.firstElementChild，Element.lastElementChild</span><br><span class="line">  26.Element.nextElementSibling，Element.previousElementSibling</span><br><span class="line">  27.属性相关方法，元素节点提供六个方法，用来操作属性。</span><br><span class="line">  - getAttribute()：读取某个属性的值</span><br><span class="line">  - getAttributeNames()：返回当前元素的所有属性名</span><br><span class="line">  - setAttribute()：写入属性值</span><br><span class="line">  - hasAttribute()：某个属性是否存在</span><br><span class="line">  - hasAttributes()：当前元素是否有属性</span><br><span class="line">  - removeAttribute()：删除属性</span><br><span class="line">  28.Element.querySelector()，Element.querySelector方法接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。如果没有找到匹配的子元素，就返回null。</span><br><span class="line">  29.Element.querySelectorAll()，Element.querySelectorAll方法接受 CSS 选择器作为参数，返回一个NodeList实例，包含所有匹配的子元素。</span><br><span class="line">  30.Element.getElementsByClassName()，Element.getElementsByClassName方法返回一个HTMLCollection实例，成员是当前元素节点的所有具有指定 class 的子元素节点。该方法与document.getElementsByClassName方法的用法类似，只是搜索范围不是整个文档，而是当前元素节点。</span><br><span class="line">  31.Element.getElementsByTagName()，Element.getElementsByTagName方法返回一个HTMLCollection实例，成员是当前节点的所有匹配指定标签名的子元素节点。</span><br><span class="line">  23.Element.closest() ，Element.closest方法接受一个 CSS 选择器作为参数，返回匹配该选择器的、最接近当前节点的一个祖先节点（包括当前节点本身）。如果没有任何节点匹配 CSS 选择器，则返回null。</span><br><span class="line">  24.Element.matches()，Element.matches方法返回一个布尔值，表示当前元素是否匹配给定的 CSS 选择器。</span><br><span class="line">  25.事件相关方法，以下三个方法与Element节点的事件相关。这些方法都继承自EventTarget接口，</span><br><span class="line">  - Element.addEventListener()：添加事件的回调函数</span><br><span class="line">  - Element.removeEventListener()：移除事件监听函数</span><br><span class="line">  - Element.dispatchEvent()：触发事件</span><br><span class="line">  26.Element.scrollIntoView()，Element.scrollIntoView方法滚动当前元素，进入浏览器的可见区域，类似于设置window.location.hash的效果。</span><br><span class="line">  27.Element.getBoundingClientRect()，Element.getBoundingClientRect方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息。</span><br><span class="line">    - x：元素左上角相对于视口的横坐标</span><br><span class="line">    - y：元素左上角相对于视口的纵坐标</span><br><span class="line">    - height：元素高度</span><br><span class="line">    - width：元素宽度</span><br><span class="line">    - left：元素左上角相对于视口的横坐标，与x属性相等</span><br><span class="line">    - right：元素右边界相对于视口的横坐标（等于x + width）</span><br><span class="line">    - top：元素顶部相对于视口的纵坐标，与y属性相等</span><br><span class="line">    - bottom：元素底部相对于视口的纵坐标（等于y + height）</span><br><span class="line">  28.Element.getClientRects()，Element.getClientRects方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形（所以方法名中的Rect用的是复数）。</span><br><span class="line">  29.Element.insertAdjacentElement()，Element.insertAdjacentElement方法在相对于当前元素的指定位置，插入一个新的节点。该方法返回被插入的节点，如果插入失败，返回null。</span><br><span class="line">  30.Element.insertAdjacentHTML()，Element.insertAdjacentText()</span><br><span class="line">  31.Element.remove()，Element.remove方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。</span><br><span class="line">  32.Element.focus()，Element.blur()，Element.focus方法用于将当前页面的焦点，转移到指定元素上。</span><br><span class="line">  33.Element.click()，Element.click方法用于在当前元素上模拟一次鼠标点击，相当于触发了click事件。</span><br><span class="line">  // 属性的操作</span><br><span class="line">  Element.attributes 属性</span><br><span class="line">  元素的标准属性</span><br><span class="line">  属性操作的标准方法</span><br><span class="line">  概述</span><br><span class="line">  Element.getAttribute()</span><br><span class="line">  Element.getAttributeNames()</span><br><span class="line">  Element.setAttribute()</span><br><span class="line">  Element.hasAttribute()</span><br><span class="line">  Element.hasAttributes()</span><br><span class="line">  Element.removeAttribute()</span><br><span class="line">  dataset 属性</span><br><span class="line">  // Text 节点和 DocumentFragment 节点</span><br><span class="line">  Text 节点的属性</span><br><span class="line">  data</span><br><span class="line">  wholeText</span><br><span class="line">  length</span><br><span class="line">  nextElementSibling，previousElementSibling</span><br><span class="line">  Text 节点的方法</span><br><span class="line">  appendData()，deleteData()，insertData()，replaceData()，subStringData()</span><br><span class="line">  remove()</span><br><span class="line">  splitText()</span><br><span class="line">  DocumentFragment 节点</span><br><span class="line">  // CSS 操作</span><br><span class="line">  HTML 元素的 style 属性</span><br><span class="line">  CSSStyleDeclaration 接口</span><br><span class="line">  简介</span><br><span class="line">  CSSStyleDeclaration 实例属性</span><br><span class="line">  CSSStyleDeclaration 实例方法</span><br><span class="line">  CSS 模块的侦测</span><br><span class="line">  CSS 对象</span><br><span class="line">  CSS.escape()</span><br><span class="line">  CSS.supports()</span><br><span class="line">  window.getComputedStyle()</span><br><span class="line">  CSS 伪元素</span><br><span class="line">  StyleSheet 接口</span><br><span class="line">  概述</span><br><span class="line">  实例属性</span><br><span class="line">  实例方法</span><br><span class="line">  实例：添加样式表</span><br><span class="line">  CSSRuleList 接口</span><br><span class="line">  CSSRule 接口</span><br><span class="line">  概述</span><br><span class="line">  CSSRule 实例的属性</span><br><span class="line">  CSSStyleRule 接口</span><br><span class="line">  CSSMediaRule 接口</span><br><span class="line">  window.matchMedia()</span><br><span class="line">  基本用法</span><br><span class="line">  MediaQueryList 接口的实例属性</span><br><span class="line">  MediaQueryList 接口的实例方法</span><br><span class="line">  // Mutation Observer API</span><br><span class="line">  MutationObserver 构造函数</span><br><span class="line">  MutationObserver 的实例方法</span><br><span class="line">  observe()</span><br><span class="line">  disconnect()，takeRecords（）</span><br><span class="line">  MutationRecord 对象</span><br><span class="line">  应用示例</span><br><span class="line">  子元素的变动</span><br><span class="line">  属性的变动</span><br><span class="line">  取代 DOMContentLoaded 事件</span><br><span class="line">  // EventTarget 接口</span><br><span class="line">  1.DOM 的事件操作（监听和触发），都定义在EventTarget接口。</span><br><span class="line">  - addEventListener：绑定事件的监听函数</span><br><span class="line">  - removeEventListener：移除事件的监听函数</span><br><span class="line">  - dispatchEvent：触发事件</span><br><span class="line">  2.EventTarget.addEventListener()</span><br><span class="line">  - EventTarget.addEventListener()用于在当前节点或对象上，定义一个特定事件的监听函数。一旦这个事件发生，就会执行监听函数。该方法没有返回值。</span><br><span class="line">  3.EventTarget.removeEventListener()</span><br><span class="line">  - EventTarget.removeEventListener方法用来移除addEventListener方法添加的事件监听函数。该方法没有返回值。</span><br><span class="line">  4.EventTarget.dispatchEvent()</span><br><span class="line">  -EventTarget.dispatchEvent方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了Event.preventDefault()，则返回值为false，否则为true。</span><br><span class="line">  // 事件模型</span><br><span class="line">  1.监听函数</span><br><span class="line">  浏览器的事件模型，就是通过监听函数（listener）对事件做出反应。事件发生后，浏览器监听到了这个事件，就会执行对应的监听函数。这是事件驱动编程模式（event-driven）的主要编程方式。</span><br><span class="line">  - HTML 的 on- 属性，HTML 语言允许在元素的属性中，直接定义某些事件的监听代码。</span><br><span class="line">  - 元素节点的事件属性，元素节点对象的事件属性，同样可以指定监听函数。</span><br><span class="line">  - EventTarget.addEventListener()，所有 DOM 节点实例都有addEventListener方法，用来为该节点定义事件的监听函数。</span><br><span class="line">  2.this 的指向，监听函数内部的this指向触发事件的那个元素节点。</span><br><span class="line">  3.事件的传播，一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段。</span><br><span class="line">  - 第一阶段：从window对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</span><br><span class="line">  - 第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。</span><br><span class="line">  - 第三阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</span><br><span class="line">  4.事件处理，由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</span><br><span class="line">  // Event 对象</span><br><span class="line">  1.Event，事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例，或者说继承了Event.prototype对象。</span><br><span class="line">  2.实例属性</span><br><span class="line">  - Event.bubbles属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，Event构造函数生成的事件，默认是不冒泡的。</span><br><span class="line">  - Event.eventPhase属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</span><br><span class="line">    Event.eventPhase的返回值有四种可能。</span><br><span class="line">    0，事件目前没有发生。</span><br><span class="line">    1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</span><br><span class="line">    2，事件到达目标节点，即Event.target属性指向的那个节点。</span><br><span class="line">    3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</span><br><span class="line">  - Event.cancelable属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</span><br><span class="line">  - Event.cancelBubble属性是一个布尔值，如果设为true，相当于执行Event.stopPropagation()，可以阻止事件的传播。</span><br><span class="line">  - Event.defaultPrevented属性返回一个布尔值，表示该事件是否调用过Event.preventDefault方法。该属性只读。</span><br><span class="line">  - Event.currentTarget属性返回事件当前所在的节点，即事件当前正在通过的节点，也就是当前正在执行的监听函数所在的那个节点。随着事件的传播，这个属性的值会变。</span><br><span class="line">  - Event.target属性返回原始触发事件的那个节点，即事件最初发生的节点。这个属性不会随着事件的传播而改变。</span><br><span class="line">  - Event.type属性返回一个字符串，表示事件类型。事件的类型是在生成事件的时候指定的。该属性只读。</span><br><span class="line">  - Event.timeStamp属性返回一个毫秒时间戳，表示事件发生的时间。它是相对于网页加载成功开始计算的。</span><br><span class="line">  - Event.isTrusted属性返回一个布尔值，表示该事件是否由真实的用户行为产生。</span><br><span class="line">  - Event.detail属性只有浏览器的 UI （用户界面）事件才具有。该属性返回一个数值，表示事件的某种信息。具体含义与事件类型相关。</span><br><span class="line">  3.实例方法</span><br><span class="line">  - Event.preventDefault方法取消浏览器对当前事件的默认行为。</span><br><span class="line">  - Event.stopPropagation()，stopPropagation方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</span><br><span class="line">  - Event.stopImmediatePropagation()，Event.stopImmediatePropagation方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。</span><br><span class="line">  - Event.composedPath()，Event.composedPath()返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</span><br><span class="line">  // 鼠标事件</span><br><span class="line">  1.鼠标事件的种类</span><br><span class="line">  - click：按下鼠标（通常是按下主按钮）时触发。</span><br><span class="line">  - dblclick：在同一个元素上双击鼠标时触发。</span><br><span class="line">  - mousedown：按下鼠标键时触发。</span><br><span class="line">  - mouseup：释放按下的鼠标键时触发。</span><br><span class="line">  - mousemove：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</span><br><span class="line">  - mouseenter：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。</span><br><span class="line">  - mouseover：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。</span><br><span class="line">  - mouseout：鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。</span><br><span class="line">  - mouseleave：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。</span><br><span class="line">  - contextmenu：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。</span><br><span class="line">  - wheel：滚动鼠标的滚轮时触发，该事件继承的是WheelEvent接口。</span><br><span class="line">  2.MouseEvent 接口概述，MouseEvent接口代表了鼠标相关的事件，单击（click）、双击（dblclick）、松开鼠标键（mouseup）、按下鼠标键（mousedown）等动作，所产生的事件对象都是MouseEvent实例。此外，滚轮事件和拖拉事件也是MouseEvent实例。该对象可以配置以下属性，所有属性都是可选的。</span><br><span class="line">    - screenX：数值，鼠标相对于屏幕的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</span><br><span class="line">    - screenY：数值，鼠标相对于屏幕的垂直位置（单位像素），其他与screenX相同。</span><br><span class="line">    - clientX：数值，鼠标相对于程序窗口的水平位置（单位像素），默认值为0，设置该属性不会移动鼠标。</span><br><span class="line">    - clientY：数值，鼠标相对于程序窗口的垂直位置（单位像素），其他与clientX相同。</span><br><span class="line">    - ctrlKey：布尔值，是否同时按下了 Ctrl 键，默认值为false。</span><br><span class="line">    - shiftKey：布尔值，是否同时按下了 Shift 键，默认值为false。</span><br><span class="line">    - altKey：布尔值，是否同时按下 Alt 键，默认值为false。</span><br><span class="line">    - metaKey：布尔值，是否同时按下 Meta 键，默认值为false。</span><br><span class="line">    - button：数值，表示按下了哪一个鼠标按键，默认值为0，表示按下主键（通常是鼠标的左键）或者当前事件没有定义这个属性；1表示按下辅助键（通常是鼠标的中间键），2表示按下次要键（通常是鼠标的右键）。</span><br><span class="line">    - buttons：数值，表示按下了鼠标的哪些键，是一个三个比特位的二进制值，默认为0（没有按下任何键）。1（二进制001）表示按下主键（通常是左键），2（二进制010）表示按下次要键（通常是右键），4（二进制100）表示按下辅助键（通常是中间键）。因此，如果返回3（二进制011）就表示同时按下了左键和右键。</span><br><span class="line">    - relatedTarget：节点对象，表示事件的相关节点，默认为null。mouseenter和mouseover事件时，表示鼠标刚刚离开的那个元素节点；mouseout和mouseleave事件时，表示鼠标正在进入的那个元素节点。</span><br><span class="line">  3.MouseEvent 接口的实例属性</span><br><span class="line">    MouseEvent.altKey、MouseEvent.ctrlKey、MouseEvent.metaKey、MouseEvent.shiftKey这四个属性都返回一个布尔值，表示事件发生时，是否按下对应的键。它们都是只读属性。</span><br><span class="line">    - altKey属性：Alt 键</span><br><span class="line">    - ctrlKey属性：Ctrl 键</span><br><span class="line">    - metaKey属性：Meta 键（Mac 键盘是一个四瓣的小花，Windows 键盘是 Windows 键）</span><br><span class="line">    - shiftKey属性：Shift 键</span><br><span class="line"></span><br><span class="line">    MouseEvent.button属性返回一个数值，表示事件发生时按下了鼠标的哪个键。该属性只读。</span><br><span class="line">    - 0：按下主键（通常是左键），或者该事件没有初始化这个属性（比如mousemove事件）。</span><br><span class="line">    - 1：按下辅助键（通常是中键或者滚轮键）。</span><br><span class="line">    - 2：按下次键（通常是右键）。</span><br><span class="line"></span><br><span class="line">    MouseEvent.buttons属性返回一个三个比特位的值，表示同时按下了哪些键。它用来处理同时按下多个鼠标键的情况。该属性只读。</span><br><span class="line">    - 1：二进制为001（十进制的1），表示按下左键。</span><br><span class="line">    - 2：二进制为010（十进制的2），表示按下右键。</span><br><span class="line">    - 4：二进制为100（十进制的4），表示按下中键或滚轮键。</span><br><span class="line"></span><br><span class="line">    MouseEvent.clientX属性返回鼠标位置相对于浏览器窗口左上角的水平坐标（单位像素），MouseEvent.clientY属性返回垂直坐标。这两个属性都是只读属性。</span><br><span class="line"></span><br><span class="line">    MouseEvent.movementX属性返回当前位置与上一个mousemove事件之间的水平距离（单位像素）。</span><br><span class="line">    MouseEvent.movementY属性返回当前位置与上一个mousemove事件之间的垂直距离（单位像素）。</span><br><span class="line"></span><br><span class="line">    MouseEvent.screenX属性返回鼠标位置相对于屏幕左上角的水平坐标（单位像素），MouseEvent.screenY属性返回垂直坐标。这两个属性都是只读属性。</span><br><span class="line"></span><br><span class="line">    MouseEvent.offsetX属性返回鼠标位置与目标节点左侧的padding边缘的水平距离（单位像素），MouseEvent.offsetY属性返回与目标节点上方的padding边缘的垂直距离。这两个属性都是只读属性。</span><br><span class="line"></span><br><span class="line">    MouseEvent.pageX属性返回鼠标位置与文档左侧边缘的距离（单位像素），MouseEvent.pageY属性返回与文档上侧边缘的距离（单位像素）。它们的返回值都包括文档不可见的部分。这两个属性都是只读。</span><br><span class="line"></span><br><span class="line">    MouseEvent.relatedTarget属性返回事件的相关节点。对于那些没有相关节点的事件，该属性返回null。该属性只读。</span><br><span class="line"></span><br><span class="line">    事件名称      target 属性   relatedTarget 属性</span><br><span class="line">    focusin     接受焦点的节点   丧失焦点的节点</span><br><span class="line">    focusout    丧失焦点的节点   接受焦点的节点</span><br><span class="line">    mouseenter  将要进入的节点   将要离开的节点</span><br><span class="line">    mouseleave  将要离开的节点   将要进入的节点</span><br><span class="line">    mouseout    将要离开的节点   将要进入的节点</span><br><span class="line">    mouseover   将要进入的节点   将要离开的节点</span><br><span class="line">    dragenter   将要进入的节点   将要离开的节点</span><br><span class="line">    dragexit    将要离开的节点   将要进入的节点</span><br><span class="line"></span><br><span class="line">    4.MouseEvent 接口的实例方法</span><br><span class="line">    - MouseEvent.getModifierState方法返回一个布尔值，表示有没有按下特定的功能键。</span><br><span class="line"></span><br><span class="line">    5.WheelEvent 接口，WheelEvent 接口继承了 MouseEvent 实例，代表鼠标滚轮事件的实例对象。该对象的属性除了Event、UIEvent的配置属性以外，还可以接受以下几个属性，所有属性都是可选的。</span><br><span class="line">      - deltaX：数值，表示滚轮的水平滚动量，默认值是 0.0。</span><br><span class="line">      - deltaY：数值，表示滚轮的垂直滚动量，默认值是 0.0。</span><br><span class="line">      - deltaZ：数值，表示滚轮的 Z 轴滚动量，默认值是 0.0。</span><br><span class="line">      - deltaMode：数值，表示相关的滚动事件的单位，适用于上面三个属性。0表示滚动单位为像素，1表示单位为行，2表示单位为页，默认为0。</span><br><span class="line"></span><br><span class="line">    6.WheelEvent事件实例除了具有Event和MouseEvent的实例属性和实例方法，还有一些自己的实例属性，但是没有自己的实例方法。</span><br><span class="line">      下面的属性都是只读属性。</span><br><span class="line">      - WheelEvent.deltaX：数值，表示滚轮的水平滚动量。</span><br><span class="line">      - WheelEvent.deltaY：数值，表示滚轮的垂直滚动量。</span><br><span class="line">      - WheelEvent.deltaZ：数值，表示滚轮的 Z 轴滚动量。</span><br><span class="line">      - WheelEvent.deltaMode：数值，表示上面三个属性的单位，0是像素，1是行，2是页。</span><br><span class="line"></span><br><span class="line">    // 键盘事件</span><br><span class="line">    1.键盘事件的种类</span><br><span class="line">    - keydown：按下键盘时触发。</span><br><span class="line">    - keypress：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发keydown事件，再触发这个事件。</span><br><span class="line">    - keyup：松开键盘时触发该事件。</span><br><span class="line">    如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</span><br><span class="line">      keydown</span><br><span class="line">      keypress</span><br><span class="line">      keydown</span><br><span class="line">      keypress</span><br><span class="line">      ...（重复以上过程）</span><br><span class="line">      keyup</span><br><span class="line"></span><br><span class="line">    2.KeyboardEvent 接口概述，KeyboardEvent接口用来描述用户与键盘的互动。这个接口继承了Event接口，并且定义了自己的实例属性和实例方法。KeyboardEvent构造函数接受两个参数。第一个参数是字符串，表示事件类型；第二个参数是一个事件配置对象，该参数可选。除了Event接口提供的属性，还可以配置以下字段，它们都是可选。</span><br><span class="line">    - key：字符串，当前按下的键，默认为空字符串。</span><br><span class="line">    - code：字符串，表示当前按下的键的字符串形式，默认为空字符串。</span><br><span class="line">    - location：整数，当前按下的键的位置，默认为0。</span><br><span class="line">    - ctrlKey：布尔值，是否按下 Ctrl 键，默认为false。</span><br><span class="line">    - shiftKey：布尔值，是否按下 Shift 键，默认为false。</span><br><span class="line">    - altKey：布尔值，是否按下 Alt 键，默认为false。</span><br><span class="line">    - metaKey：布尔值，是否按下 Meta 键，默认为false。</span><br><span class="line">    - repeat：布尔值，是否重复按键，默认为false。</span><br><span class="line"></span><br><span class="line">    3.KeyboardEvent 的实例属性</span><br><span class="line">    - KeyboardEvent.altKey：是否按下 Alt 键</span><br><span class="line">    - KeyboardEvent.ctrlKey：是否按下 Ctrl 键</span><br><span class="line">    - KeyboardEvent.metaKey：是否按下 meta 键（Mac 系统是一个四瓣的小花，Windows 系统是 windows 键）</span><br><span class="line">    - KeyboardEvent.shiftKey：是否按下 Shift 键</span><br><span class="line">    - KeyboardEvent.code属性返回一个字符串，表示当前按下的键的字符串形式。该属性只读。</span><br><span class="line">      下面是一些常用键的字符串形式，其他键请查文档。</span><br><span class="line">      数字键0 - 9：返回digital0 - digital9</span><br><span class="line">      字母键A - z：返回KeyA - KeyZ</span><br><span class="line">      功能键F1 - F12：返回 F1 - F12</span><br><span class="line">      方向键：返回ArrowDown、ArrowUp、ArrowLeft、ArrowRight</span><br><span class="line">      Alt 键：返回AltLeft或AltRight</span><br><span class="line">      Shift 键：返回ShiftLeft或ShiftRight</span><br><span class="line">      Ctrl 键：返回ControlLeft或ControlRight</span><br><span class="line">    - KeyboardEvent.key属性返回一个字符串，表示按下的键名。该属性只读。</span><br><span class="line">    - KeyboardEvent.location属性返回一个整数，表示按下的键处在键盘的哪一个区域。它可能取以下值。</span><br><span class="line">      0：处在键盘的主区域，或者无法判断处于哪一个区域。</span><br><span class="line">      1：处在键盘的左侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</span><br><span class="line">      2：处在键盘的右侧，只适用那些有两个位置的键（比如 Ctrl 和 Shift 键）。</span><br><span class="line">      3：处在数字小键盘。</span><br><span class="line">    - KeyboardEvent.repeat返回一个布尔值，代表该键是否被按着不放，以便判断是否重复这个键，即浏览器会持续触发keydown和keypress事件，直到用户松开手为止。</span><br><span class="line">    - KeyboardEvent.getModifierState()方法返回一个布尔值，表示是否按下或激活指定的功能键。它的常用参数如下。</span><br><span class="line">      Alt：Alt 键</span><br><span class="line">      CapsLock：大写锁定键</span><br><span class="line">      Control：Ctrl 键</span><br><span class="line">      Meta：Meta 键</span><br><span class="line">      NumLock：数字键盘开关键</span><br><span class="line">      Shift：Shift 键</span><br><span class="line"></span><br><span class="line">    // 进度事件</span><br><span class="line">    1.进度事件的种类，进度事件用来描述资源加载的进度，主要由 AJAX 请求、&lt;img&gt;、&lt;audio&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;等外部资源的加载触发，继承了ProgressEvent接口。它主要包含以下几种事件。</span><br><span class="line">    - abort：外部资源中止加载时（比如用户取消）触发。如果发生错误导致中止，不会触发该事件。</span><br><span class="line">    - error：由于错误导致外部资源无法加载时触发。</span><br><span class="line">    - load：外部资源加载成功时触发。</span><br><span class="line">    - loadstart：外部资源开始加载时触发。</span><br><span class="line">    - loadend：外部资源停止加载时触发，发生顺序排在error、abort、load等事件的后面。</span><br><span class="line">    - progress：外部资源加载过程中不断触发。</span><br><span class="line">    - timeout：加载超时时触发。</span><br><span class="line">    注意，除了资源下载，文件上传也存在这些事件。</span><br><span class="line"></span><br><span class="line">    2.ProgressEvent 接口，ProgressEvent接口主要用来描述外部资源加载的进度，比如 AJAX 加载、&lt;img&gt;、&lt;video&gt;、&lt;style&gt;、&lt;link&gt;等外部资源加载。进度相关的事件都继承了这个接口。</span><br><span class="line"></span><br><span class="line">    // 表单事件</span><br><span class="line">    1.表单事件的种类</span><br><span class="line">    - input事件当&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;的值发生变化时触发。上面代码中，改变下拉框选项时，会触发input事件，从而执行回调函数inputHandler。</span><br><span class="line">    - select事件当在&lt;input&gt;、&lt;textarea&gt;里面选中文本时触发。选中的文本可以通过event.target元素的selectionDirection、selectionEnd、selectionStart和value属性拿到。</span><br><span class="line">    - change事件当&lt;input&gt;、&lt;select&gt;、&lt;textarea&gt;的值发生变化时触发。它与input事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面input事件必然伴随change事件。具体来说，分成以下几种情况。</span><br><span class="line">      </span><br><span class="line">      激活单选框（radio）或复选框（checkbox）时触发。</span><br><span class="line">      用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。</span><br><span class="line">      当文本框或&lt;textarea&gt;元素的值发生改变，并且丧失焦点时触发。</span><br><span class="line"></span><br><span class="line">    - invalid 事件，用户提交表单时，如果表单元素的值不满足校验条件，就会触发invalid事件。</span><br><span class="line">    - reset事件当表单重置（所有表单成员变回默认值）时触发。</span><br><span class="line">    - submit事件当表单数据向服务器提交时触发。</span><br><span class="line"></span><br><span class="line">    2.InputEvent 接口</span><br><span class="line">    - InputEvent接口主要用来描述input事件的实例。该接口继承了Event接口，还定义了一些自己的实例属性和实例方法。</span><br><span class="line">    - InputEvent.data属性返回一个字符串，表示变动的内容。</span><br><span class="line">    - InputEvent.inputType属性返回一个字符串，表示字符串发生变更的类型。</span><br><span class="line">    - InputEvent.dataTransfer属性返回一个 DataTransfer 实例。该属性只在文本框接受粘贴内容（insertFromPaste）或拖拽内容（insertFromDrop）时才有效。</span><br><span class="line"></span><br><span class="line">    // 触摸事件</span><br><span class="line">    1.浏览器的触摸 API 由三个部分组成。</span><br><span class="line">      - Touch：一个触摸点</span><br><span class="line">      - TouchList：多个触摸点的集合</span><br><span class="line">      - TouchEvent：触摸引发的事件实例</span><br><span class="line">    2.Touch 接口，Touch构造函数接受一个配置对象作为参数，它有以下属性。</span><br><span class="line">      - identifier：必需，类型为整数，表示触摸点的唯一 ID。</span><br><span class="line">      - target：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</span><br><span class="line">      - clientX：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</span><br><span class="line">      - clientY：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</span><br><span class="line">      - screenX：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</span><br><span class="line">      - screenY：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</span><br><span class="line">      - pageX：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</span><br><span class="line">      - pageY：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</span><br><span class="line">      - radiusX：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</span><br><span class="line">      - radiusY：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</span><br><span class="line">      - rotationAngle：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</span><br><span class="line">      - force：可选，类型为数值，范围在0到1之间，表示触摸压力。0代表没有压力，1代表硬件所能识别的最大压力，默认为0。</span><br><span class="line">    3.Touch 接口的实例属性</span><br><span class="line">      - Touch.identifier属性返回一个整数，表示触摸点的唯一 ID。这个值在整个触摸过程保持不变，直到触摸事件结束。</span><br><span class="line">      - Touch.screenX属性和Touch.screenY属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。</span><br><span class="line">      - Touch.clientX属性和Touch.clientY属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。</span><br><span class="line">      - Touch.pageX属性和Touch.pageY属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。</span><br><span class="line">      - Touch.radiusX属性和Touch.radiusY属性，分别返回触摸点周围受到影响的椭圆范围的 X 轴半径和 Y 轴半径，单位为像素。乘以 2 就可以得到触摸范围的宽度和高度。</span><br><span class="line">      - Touch.rotationAngle属性表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间。</span><br><span class="line">      - Touch.force属性返回一个0到1之间的数值，表示触摸压力。0代表没有压力，1代表硬件所能识别的最大压力。</span><br><span class="line">      - Touch.target属性返回一个元素节点，代表触摸发生时所在的那个元素节点。即使触摸点已经离开了这个节点，该属性依然不变。</span><br><span class="line">    4.TouchList 接口</span><br><span class="line">      TouchList接口表示一族的解除点的集合。它的实例是一个类似数组的对象，成员是Touch的实例对象，表示所有触摸点。用户用三根手指触摸，产生的TouchList实例就会包含三个成员，每根手指的接触点对应一个Touch实例对象。</span><br><span class="line"></span><br><span class="line">      它的实例属性和实例方法只有两个。</span><br><span class="line">      TouchList.length：数值，表示成员数量（即触摸点的数量）。</span><br><span class="line">      TouchList.item()：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）</span><br><span class="line"></span><br><span class="line">    5.TouchEvent接口继承了 Event 接口，表示由触摸引发的事件实例，通常来自触摸屏或轨迹板。除了被继承的属性以外，它还有一些自己的属性。除了Event接口的配置属性，该接口还有一些自己的配置属性。</span><br><span class="line">      - touches：TouchList实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组[]。</span><br><span class="line">      - targetTouches：TouchList实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组[]。</span><br><span class="line">      - changedTouches：TouchList实例，代表本次触摸事件的相关触摸点，默认值是一个空数组[]。</span><br><span class="line">      - ctrlKey：布尔值，表示 Ctrl 键是否同时按下，默认值为false。</span><br><span class="line">      - shiftKey：布尔值，表示 Shift 键是否同时按下，默认值为false。</span><br><span class="line">      - altKey：布尔值，表示 Alt 键是否同时按下，默认值为false。</span><br><span class="line">      - metaKey：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为false。</span><br><span class="line">    </span><br><span class="line">      实例属性：</span><br><span class="line">      - TouchEvent.altKey：布尔值，表示触摸时是否按下了 Alt 键。</span><br><span class="line">      - TouchEvent.ctrlKey：布尔值，表示触摸时是否按下了 Ctrl 键。</span><br><span class="line">      - TouchEvent.shiftKey：布尔值：表示触摸时是否按下了 Shift 键。</span><br><span class="line">      - TouchEvent.metaKey：布尔值，表示触摸时是否按下了 Meta 键（或 Windows 键）。</span><br><span class="line">      - TouchEvent.changedTouches属性返回一个TouchList实例，成员是一组Touch实例对象，表示本次触摸事件的相关触摸点。对于不同的时间，该属性的含义有所不同。</span><br><span class="line">        touchstart事件：被激活的触摸点</span><br><span class="line">        touchmove事件：发生变化的触摸点</span><br><span class="line">        touchend事件：消失的触摸点（即不再被触碰的点）</span><br><span class="line">      - TouchEvent.touches属性返回一个TouchList实例，成员是所有仍然处于活动状态（即触摸中）的触摸点。一般来说，一个手指就是一个触摸点。</span><br><span class="line">      - TouchEvent.targetTouches属性返回一个TouchList实例，成员是触摸事件的目标元素节点内部、所有仍然处于活动状态（即触摸中）的触摸点。</span><br><span class="line"></span><br><span class="line">      6.触摸事件的种类，可以通过TouchEvent.type属性，查看到底发生的是哪一种事件。</span><br><span class="line">      - touchstart：用户开始触摸时触发，它的target属性返回发生触摸的元素节点。</span><br><span class="line">      - touchend：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的target属性与touchstart事件一致的，就是开始触摸时所在的元素节点。它的changedTouches属性返回一个TouchList实例，包含所有不再触摸的触摸点（即Touch实例对象）。</span><br><span class="line">      - touchmove：用户移动触摸点时触发，它的target属性与touchstart事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。</span><br><span class="line">      - touchcancel：触摸点取消时触发，比如在触摸区域跳出一个模态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。</span><br><span class="line"></span><br><span class="line">      // 拖拉事件</span><br><span class="line">      1.拖拉事件的种类，draggable属性可用于任何元素节点，但是图片（&lt;img&gt;）和链接（&lt;a&gt;）不加这个属性，就可以拖拉。</span><br><span class="line">      当元素节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。</span><br><span class="line">      - drag：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。</span><br><span class="line">      - dragstart：用户开始拖拉时，在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</span><br><span class="line">      - dragend：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。它与dragstart事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，dragend事件总是会触发的。</span><br><span class="line">      - dragenter：拖拉进入当前节点时，在当前节点上触发一次，该事件的target属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</span><br><span class="line">      - dragover：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的target属性是当前节点。该事件与dragenter事件的区别是，dragenter事件在进入该节点时触发，然后只要没有离开这个节点，dragover事件会持续触发。</span><br><span class="line">      - dragleave：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的target属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</span><br><span class="line">      - drop：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许drop，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</span><br><span class="line"></span><br><span class="line">      2.DragEvent 接口</span><br><span class="line">      - 拖拉事件都继承了DragEvent接口，这个接口又继承了MouseEvent接口和Event接口。浏览器原生提供一个DragEvent()构造函数，用来生成拖拉事件的实例对象。</span><br><span class="line"></span><br><span class="line">      3.DataTransfer 接口概述</span><br><span class="line">      - 所有拖拉事件的实例都有一个DragEvent.dataTransfer属性，用来读写需要传递的数据。这个属性的值是一个DataTransfer接口的实例。</span><br><span class="line"></span><br><span class="line">      4.DataTransfer 的实例属性</span><br><span class="line">      - DataTransfer.dropEffect属性用来设置放下（drop）被拖拉节点时的效果，会影响到拖拉经过相关区域时鼠标的形状。它可能取下面的值。</span><br><span class="line">        copy：复制被拖拉的节点</span><br><span class="line">        move：移动被拖拉的节点</span><br><span class="line">        link：创建指向被拖拉的节点的链接</span><br><span class="line">        none：无法放下被拖拉的节点</span><br><span class="line"></span><br><span class="line">      - DataTransfer.effectAllowed属性设置本次拖拉中允许的效果。它可能取下面的值。</span><br><span class="line">        copy：复制被拖拉的节点</span><br><span class="line">        move：移动被拖拉的节点</span><br><span class="line">        link：创建指向被拖拉节点的链接</span><br><span class="line">        copyLink：允许copy或link</span><br><span class="line">        copyMove：允许copy或move</span><br><span class="line">        linkMove：允许link或move</span><br><span class="line">        all：允许所有效果</span><br><span class="line">        none：无法放下被拖拉的节点</span><br><span class="line">        uninitialized：默认值，等同于all</span><br><span class="line"></span><br><span class="line">      - DataTransfer.files属性是一个 FileList 对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则该属性为空的 FileList 对象。</span><br><span class="line"></span><br><span class="line">      - DataTransfer.types属性是一个只读的数组，每个成员是一个字符串，里面是拖拉的数据格式（通常是 MIME 值）。</span><br><span class="line"></span><br><span class="line">      - DataTransfer.items属性返回一个类似数组的只读对象（DataTransferItemList 实例），每个成员就是本次拖拉的一个对象（DataTransferItem 实例）。如果本次拖拉不包含对象，则返回一个空对象。</span><br><span class="line">        DataTransferItemList 实例具有以下的属性和方法。</span><br><span class="line">        - length：返回成员的数量</span><br><span class="line">        - add(data, type)：增加一个指定内容和类型（比如text/html和text/plain）的字符串作为成员</span><br><span class="line">        - add(file)：add方法的另一种用法，增加一个文件作为成员</span><br><span class="line">        - remove(index)：移除指定位置的成员</span><br><span class="line">        - clear()：移除所有的成员</span><br><span class="line"></span><br><span class="line">        DataTransferItem 实例具有以下的属性和方法。</span><br><span class="line">        - kind：返回成员的种类（string还是file）。</span><br><span class="line">        - type：返回成员的类型（通常是 MIME 值）。</span><br><span class="line">        - getAsFile()：如果被拖拉是文件，返回该文件，否则返回null。</span><br><span class="line">        - getAsString(callback)：如果被拖拉的是字符串，将该字符传入指定的回调函数处理。该方法是异步的，所以需要传入回调函数。</span><br><span class="line"></span><br><span class="line">      5.DataTransfer 的实例方法</span><br><span class="line">      - DataTransfer.setData()方法用来设置拖拉事件所带有的数据。该方法没有返回值。</span><br><span class="line">      - DataTransfer.getData()方法接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用setData方法添加的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有drop事件触发后，才能取出数据。</span><br><span class="line">      - DataTransfer.clearData()方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则调用该方法不会产生任何效果。</span><br><span class="line">      - DataTransfer.setDragImage()方法可以自定义这张图片。它接受三个参数。第一个是&lt;img&gt;节点或者&lt;canvas&gt;节点，如果省略或为null，则使用被拖动的节点的外观；第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。</span><br><span class="line"></span><br><span class="line">      // 其他常见事件</span><br><span class="line">      资源事件</span><br><span class="line">      beforeunload 事件</span><br><span class="line">      unload 事件</span><br><span class="line">      load 事件，error 事件</span><br><span class="line">      session 历史事件</span><br><span class="line">      pageshow 事件，pagehide 事件</span><br><span class="line">      popstate 事件</span><br><span class="line">      hashchange 事件</span><br><span class="line">      网页状态事件</span><br><span class="line">      DOMContentLoaded 事件</span><br><span class="line">      readystatechange 事件</span><br><span class="line">      窗口事件</span><br><span class="line">      scroll 事件</span><br><span class="line">      resize 事件</span><br><span class="line">      fullscreenchange 事件，fullscreenerror 事件</span><br><span class="line">      剪贴板事件</span><br><span class="line">      焦点事件</span><br><span class="line">      CustomEvent 接口</span><br><span class="line"></span><br><span class="line">      // GlobalEventHandlers 接口</span><br><span class="line">      1.GlobalEventHandlers.onabort，某个对象的abort事件（停止加载）发生时，就会调用onabort属性指定的回调函数。</span><br><span class="line">      2.GlobalEventHandlers.onerror，error事件发生时，就会调用onerror属性指定的回调函数。</span><br><span class="line">        - window.onerror的处理函数共接受五个参数，含义如下。</span><br><span class="line">          message：错误信息字符串</span><br><span class="line">          source：报错脚本的 URL</span><br><span class="line">          lineno：报错的行号，是一个整数</span><br><span class="line">          colno：报错的列号，是一个整数</span><br><span class="line">          error： 错误对象</span><br><span class="line">      3.GlobalEventHandlers.onload、GlobalEventHandlers.onloadstart，元素完成加载时，会触发load事件，执行onload()。</span><br><span class="line">      4.GlobalEventHandlers.onfocus，GlobalEventHandlers.onblur，当前元素获得焦点时，会触发element.onfocus；失去焦点时，会触发element.onblur。</span><br><span class="line">      5.GlobalEventHandlers.onscroll，页面或元素滚动时，会触发scroll事件，导致执行onscroll()。</span><br><span class="line">      6.GlobalEventHandlers.oncontextmenu，GlobalEventHandlers.onshow，用户在页面上按下鼠标的右键，会触发contextmenu事件，导致执行oncontextmenu()。如果该属性执行后返回false，就等于禁止了右键菜单。document.oncontextmenu与window.oncontextmenu效果一样。</span><br><span class="line">      7.其他的事件属性</span><br><span class="line">        鼠标的事件属性。</span><br><span class="line"></span><br><span class="line">        onclick</span><br><span class="line">        ondblclick</span><br><span class="line">        onmousedown</span><br><span class="line">        onmouseenter</span><br><span class="line">        onmouseleave</span><br><span class="line">        onmousemove</span><br><span class="line">        onmouseout</span><br><span class="line">        onmouseover</span><br><span class="line">        onmouseup</span><br><span class="line">        onwheel</span><br><span class="line">        键盘的事件属性。</span><br><span class="line"></span><br><span class="line">        onkeydown</span><br><span class="line">        onkeypress</span><br><span class="line">        onkeyup</span><br><span class="line">        焦点的事件属性。</span><br><span class="line"></span><br><span class="line">        onblur</span><br><span class="line">        onfocus</span><br><span class="line">        表单的事件属性。</span><br><span class="line"></span><br><span class="line">        oninput</span><br><span class="line">        onchange</span><br><span class="line">        onsubmit</span><br><span class="line">        onreset</span><br><span class="line">        oninvalid</span><br><span class="line">        onselect</span><br><span class="line">        触摸的事件属性。</span><br><span class="line"></span><br><span class="line">        ontouchcancel</span><br><span class="line">        ontouchend</span><br><span class="line">        ontouchmove</span><br><span class="line">        ontouchstart</span><br><span class="line">        拖动的事件属性分成两类：一类与被拖动元素相关，另一类与接收被拖动元素的容器元素相关。</span><br><span class="line"></span><br><span class="line">        被拖动元素的事件属性。</span><br><span class="line"></span><br><span class="line">        ondragstart：拖动开始</span><br><span class="line">        ondrag：拖动过程中，每隔几百毫秒触发一次</span><br><span class="line">        ondragend：拖动结束</span><br><span class="line">        接收被拖动元素的容器元素的事件属性。</span><br><span class="line"></span><br><span class="line">        ondragenter：被拖动元素进入容器元素。</span><br><span class="line">        ondragleave：被拖动元素离开容器元素。</span><br><span class="line">        ondragover：被拖动元素在容器元素上方，每隔几百毫秒触发一次。</span><br><span class="line">        ondrop：松开鼠标后，被拖动元素放入容器元素。</span><br><span class="line">        &lt;dialog&gt;对话框元素的事件属性。</span><br><span class="line"></span><br><span class="line">        oncancel</span><br><span class="line">        onclose</span><br><span class="line"></span><br><span class="line">        // 浏览器模型</span><br><span class="line">        window 对象</span><br><span class="line">        Navigator 对象，Screen 对象</span><br><span class="line">        Cookie</span><br><span class="line">        XMLHttpRequest 对象</span><br><span class="line">        同源限制</span><br><span class="line">        CORS 通信</span><br><span class="line">        Storage 接口</span><br><span class="line">        History 对象</span><br><span class="line">        Location 对象，URL 对象，URLSearchParams 对象</span><br><span class="line">        ArrayBuffer 对象，Blob 对象</span><br><span class="line">        File 对象，FileList 对象，FileReader 对象</span><br><span class="line">        表单，FormData 对象</span><br><span class="line">        IndexedDB API</span><br><span class="line">        Web Worker</span><br><span class="line"></span><br><span class="line">        // 网页元素接口</span><br><span class="line">        &lt;a&gt;</span><br><span class="line">        &lt;img&gt;</span><br><span class="line">        &lt;form&gt;</span><br><span class="line">        &lt;input&gt;</span><br><span class="line">        &lt;button&gt;</span><br><span class="line">        &lt;option&gt;</span><br><span class="line">        &lt;video&gt;，&lt;audio&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript</title>
    <link href="https://liushuai97.github.io/2019/09/18/ECMAScript/"/>
    <id>https://liushuai97.github.io/2019/09/18/ECMAScript/</id>
    <published>2019-09-18T02:47:10.000Z</published>
    <updated>2019-09-18T02:47:36.678Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;ECMAScript&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- ECMAScript语法 --&gt;</span><br><span class="line">  1.变量是弱类型的</span><br><span class="line">  2.每行结尾的分号可有可无</span><br><span class="line">  3.注释与 Java、C 和 PHP 语言的注释相同</span><br><span class="line">  4.括号表示代码块</span><br><span class="line">  &lt;!-- ECMAScript 变量 --&gt;</span><br><span class="line">  1.声明变量</span><br><span class="line">  2.命名变量</span><br><span class="line">  * 第一个字符必须是字母、下划线（_）或美元符号（$）</span><br><span class="line">  * 余下的字符可以是下划线、美元符号或任何字母或数字字符</span><br><span class="line">  3.著名的变量命名规则</span><br><span class="line">  * Camel 标记法：首字母是小写的，接下来的字母都以大写字符开头。</span><br><span class="line">  * Pascal 标记法：首字母是大写的，接下来的字母都以大写字符开头。</span><br><span class="line">  * 匈牙利类型标记法：在以 Pascal 标记法命名的变量前附加一个小写字母（或小写字母序列），说明该变量的类型。</span><br><span class="line">  4.变量声明不是必须的</span><br><span class="line">  &lt;!-- 关键字 --&gt;</span><br><span class="line">  1.ECMAScript 关键字：关键字是保留的，不能用作变量名或函数名。</span><br><span class="line">  &lt;!-- 保留字 --&gt;</span><br><span class="line">  1.ECMAScript 保留字：保留字在某种意思上是为将来的关键字而保留的单词。因此保留字不能被用作变量名或函数名。</span><br><span class="line">  &lt;!-- ECMAScript 原始值和引用值 --&gt;</span><br><span class="line">  1.变量可以存在两种类型的值，即原始值和引用值。</span><br><span class="line">  * 原始值：存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。</span><br><span class="line">  * 引用值：存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</span><br><span class="line">  2.原始类型</span><br><span class="line">  * ECMAScript有5种原始类型（primitive type），即Undefined、Null、Boolean、Number和String。</span><br><span class="line">  &lt;!-- ECMAScript 原始类型 --&gt;</span><br><span class="line">  1.typeof运算符，返回值：</span><br><span class="line">  * undefined - 如果变量是Undefined类型的</span><br><span class="line">  * boolean - 如果变量是Boolean类型的</span><br><span class="line">  * number - 如果变量是Number类型的</span><br><span class="line">  * string - 如果变量是String类型的</span><br><span class="line">  * object - 如果变量是一种引用类型或Null类型的</span><br><span class="line">  &lt;!-- ECMAScript 引用类型 --&gt;</span><br><span class="line">  1.引用类型</span><br><span class="line">  * 引用类型通常叫做类（class），也就是说，遇到引用值，所处理的就是对象。</span><br><span class="line">  2.Object 对象</span><br><span class="line">  * Object 对象具有下列属性：</span><br><span class="line">  - constructor，对创建对象的函数的引用（指针）。对于Object对象，该指针指向原始的Object()函数。</span><br><span class="line">  - Prototype，对该对象的对象原型的引用。对于所有的对象，它默认返回Object对象的一个实例。</span><br><span class="line">  * Object 对象还具有几个方法：</span><br><span class="line">  - hasOwnProperty(property)，判断对象是否有某个特定的属性。必须用字符串指定该属性。</span><br><span class="line">  - IsPrototypeOf(object)，判断该对象是否为另一个对象的原型。</span><br><span class="line">  - PropertyIsEnumerable，判断给定的属性是否可以用for...in语句进行枚举。</span><br><span class="line">  - ToString()，返回对象的原始字符串表示。</span><br><span class="line">  - ValueOf()，返回最适合该对象的原始值。对于许多对象，该方法返回的值都与ToString()的返回值相同。</span><br><span class="line">  3.Boolean 对象</span><br><span class="line">  * Boolean对象是Boolean原始类型的引用类型。</span><br><span class="line">  4.Number 对象</span><br><span class="line">  * Number对象是Number原始类型的引用类型。</span><br><span class="line">  - toFixed() 方法，返回的是具有指定位数小数的数字的字符串表示。例如：alert(oNumberObject.toFixed(2));  //输出 &quot;68.00&quot;</span><br><span class="line">  - toExponential() 方法，返回的是用科学计数法表示的数字的字符串形式。例如：alert(oNumberObject.toExponential(1));  //输出 &quot;6.8e+1&quot;</span><br><span class="line">  - toPrecision() 方法，根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如：alert(oNumberObject.toPrecision(1));  //输出 &quot;7e+1&quot;</span><br><span class="line">  5.String 对象</span><br><span class="line">  * String对象是String原始类型的对象表示法</span><br><span class="line">  - valueOf()方法，返回String类型的原始值。</span><br><span class="line">  - toString()方法，返回String类型的原始值。例如：alert(oStringObject.valueOf() == oStringObject.toString());  //输出 &quot;true&quot;</span><br><span class="line">  - charAt()方法，返回字符串中的单个字符。例如：alert(oStringObject.charAt(1)); //输出 &quot;e&quot;</span><br><span class="line">  - charCodeAt()方法，返回字符串中的字符代码。例如：alert(oStringObject.charCodeAt(1));  //输出 &quot;101&quot;</span><br><span class="line">  - concat() 方法，用于把一个或多个字符串连接到String对象的原始值上。该方法返回的是String原始值。例如：var sResult = oStringObject.concat(&quot;world&quot;); alert(sResult);    //输出 &quot;hello world&quot;</span><br><span class="line">  - indexOf()方法，从字符串的开头（位置0）开始检索字符串。例如：alert(oStringObject.indexOf(&quot;o&quot;));   输出 &quot;4&quot;</span><br><span class="line">  - lastIndexOf()方法，从字符串的结尾开始检索子串。例如：alert(oStringObject.lastIndexOf(&quot;o&quot;)); 输出 &quot;7&quot;</span><br><span class="line">  - localeCompare()方法，对字符串进行排序。该方法有一个参数 - 要进行比较的字符串，返回的是下列三个值之一：</span><br><span class="line">    1). 如果String对象按照字母顺序排在参数中的字符串之前，返回负数。例如：alert(oStringObject.localeCompare(&quot;zoo&quot;));    //输出 &quot;-1&quot;</span><br><span class="line">    2). 如果String对象等于参数中的字符串，返回0。例如：alert(oStringObject.localeCompare(&quot;yellow&quot;));    //输出 &quot;0&quot;</span><br><span class="line">    3). 如果String对象按照字母顺序排在参数中的字符串之后，返回正数。例如：alert(oStringObject.localeCompare(&quot;brick&quot;));    //输出 &quot;1&quot;</span><br><span class="line">  - slice()、substring()方法，返回要处理的字符串的子串，接受一个或两个参数。</span><br><span class="line">  - toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()方法，涉及大小写转换。</span><br><span class="line">    例如：</span><br><span class="line">    var oStringObject = new String(&quot;Hello World&quot;);</span><br><span class="line">    alert(oStringObject.toLocaleUpperCase()); //输出 &quot;HELLO WORLD&quot;</span><br><span class="line">    alert(oStringObject.toUpperCase());   //输出 &quot;HELLO WORLD&quot;</span><br><span class="line">    alert(oStringObject.toLocaleLowerCase()); //输出 &quot;hello world&quot;</span><br><span class="line">    alert(oStringObject.toLowerCase());   //输出 &quot;hello world&quot;</span><br><span class="line">  * String对象属性：</span><br><span class="line">  - length 属性，返回字符串中的字符个数。例如：alert(oStringObject.length); //输出 &quot;11&quot;</span><br><span class="line">  * instanceof 运算符，instanceof方法要求开发者明确地确认对象为某特定类型。例如：alert(oStringObject instanceof String);  //输出 &quot;true&quot;</span><br><span class="line">  &lt;!-- ECMAScript 位运算符 --&gt;</span><br><span class="line">  * ECMAScript整数有两种类型，即有符号整数（允许用正数和负数）和无符号整数（只允许用正数）。</span><br><span class="line">  * 位运算 NOT：位运算NOT由否定号（~）表示，它是ECMAScript中为数不多的与二进制算术有关的运算符之一。</span><br><span class="line">  * 位运算 AND：位运算AND由和号（&amp;）表示，直接对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后用下面的规则对同一位置上的两个数位进行AND运算。</span><br><span class="line">  * 位运算 OR：位运算OR由符号（|）表示，也是直接对数字的二进制形式进行运算。</span><br><span class="line">  * 位运算 XOR：位运算XOR由符号（^）表示，当然，也是直接对二进制形式进行运算。</span><br><span class="line">  * 左移运算：左移运算由两个小于号表示（&lt;&lt;）。它把数字中的所有数位向左移动指定的数量。</span><br><span class="line">  * 有符号右移运算：有符号右移运算符由两个大于号表示（&gt;&gt;）。它把32位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。</span><br><span class="line">  * 无符号右移运算：无符号右移运算符由三个大于号（&gt;&gt;&gt;）表示，它将无符号32位数的所有数位整体右移。对于正数，无符号右移运算的结果与有符号右移运算一样。</span><br><span class="line">  &lt;!-- ECMAScript Boolean 运算符 --&gt;</span><br><span class="line">  * 逻辑 NOT 运算符：由感叹号（!）表示。与逻辑OR和逻辑AND运算符不同的是，逻辑NOT运算符返回的一定是Boolean值。</span><br><span class="line">  * 逻辑 AND 运算符：在ECMAScript中，逻辑AND运算符用双和号（&amp;&amp;）表示。</span><br><span class="line">  * 逻辑 OR 运算符：ECMAScript中的逻辑OR运算符与Java中的相同，都由双竖线（||）表示。</span><br><span class="line">  &lt;!-- ECMAScript 乘性运算符 --&gt;</span><br><span class="line">  * 乘法运算符，乘法运算符由星号（*）表示，用于两数相乘。</span><br><span class="line">  * 除法运算符，除法运算符由斜杠（/）表示，用第二个运算数除第一个运算数。</span><br><span class="line">  * 取模运算符，除法（余数）运算符由百分号（%）表示。</span><br><span class="line">  &lt;!-- ECMAScript 加性运算符 --&gt;</span><br><span class="line">  * 加法运算符，加法运算符由加号（+）表示。</span><br><span class="line">  * 减法运算符，减法运算符（-），也是一个常用的运算符。</span><br><span class="line">  &lt;!-- ECMAScript 关系运算符 --&gt;</span><br><span class="line">  * 关系运算符小于、大于、小于等于和大于等于执行的是两个数的比较运算，比较方式与算术比较运算相同。</span><br><span class="line">  &lt;!-- ECMAScript 等性运算符 --&gt;</span><br><span class="line">  * ECMAScript 提供了两套等性运算符：等号和非等号用于处理原始值，全等号和非全等号用于处理对象。</span><br><span class="line">  1.等号和非等号</span><br><span class="line">  * 等号由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。非等号由感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回 true。</span><br><span class="line">  2.全等号和非全等号</span><br><span class="line">  * 等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。</span><br><span class="line">  - 全等号由三个等号表示（===），只有在无需类型转换运算数就相等的情况下，才返回 true。</span><br><span class="line">  - 非全等号由感叹号加两个等号（!==）表示，只有在无需类型转换运算数不相等的情况下，才返回 true。</span><br><span class="line">  &lt;!-- ECMAScript 条件运算符 --&gt;</span><br><span class="line">  * 条件运算符，例如：variable = boolean_expression ? true_value : false_value。</span><br><span class="line">  &lt;!-- ECMAScript 赋值运算符 --&gt;</span><br><span class="line">  * 赋值运算符：简单的赋值运算符由等号（=）实现，只是把等号右边的值赋予等号左边的变量。</span><br><span class="line">  &lt;!-- ECMAScript 逗号运算符 --&gt;</span><br><span class="line">  * 逗号运算符：用逗号运算符可以在一条语句中执行多个运算。</span><br><span class="line">  &lt;!-- ECMAScript if 语句 --&gt;</span><br><span class="line">  * if 语句是 ECMAScript 中最常用的语句之一。</span><br><span class="line">  &lt;!-- ECMAScript 迭代语句 --&gt;</span><br><span class="line">  * 迭代语句又叫循环语句，声明一组要反复执行的命令，直到满足某些条件为止。循环通常用于迭代数组的值（因此而得名），或者执行重复的算术任务。</span><br><span class="line">  1.do-while 语句：do-while 语句是后测试循环，即退出条件在执行循环内部的代码之后计算。</span><br><span class="line">  2.while 语句：while 语句是前测试循环。这意味着退出条件是在执行循环内部的代码之前计算的。</span><br><span class="line">  3.for 语句：for 语句是前测试循环，而且在进入循环之前，能够初始化变量，并定义循环后要执行的代码。</span><br><span class="line">  4.for-in 语句：for-in 语句是严格的迭代语句，用于枚举对象的属性。</span><br><span class="line">  &lt;!-- ECMAScript 标签语句 --&gt;</span><br><span class="line">  * 有标签的语句</span><br><span class="line">  &lt;!-- ECMAScript break 和 continue 语句 --&gt;</span><br><span class="line">  * break 和 continue 语句对循环中的代码执行提供了更严格的控制。</span><br><span class="line">  * break 和 continue 语句的不同之处</span><br><span class="line">  - break 语句可以立即退出循环，阻止再次反复执行任何代码。</span><br><span class="line">  - continue 语句只是退出当前循环，根据控制表达式还允许继续进行下一次循环。</span><br><span class="line">  * 与有标签的语句一起使用</span><br><span class="line">  - break 语句和 continue 语句都可以与有标签的语句联合使用，返回代码中的特定位置。</span><br><span class="line">  - 例如：</span><br><span class="line">    var iNum = 0;</span><br><span class="line"></span><br><span class="line">    outermost:</span><br><span class="line">    for (var i=0; i&lt;10; i++) &#123;</span><br><span class="line">      for (var j=0; j&lt;10; j++) &#123;</span><br><span class="line">        if (i == 5 &amp;&amp; j == 5) &#123;</span><br><span class="line">        </span><br><span class="line">    break outermost;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      iNum++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    alert(iNum);  //输出 &quot;55&quot;</span><br><span class="line">  &lt;!-- ECMAScript with 语句 --&gt;</span><br><span class="line">  * 有标签的语句：with 语句用于设置代码在特定对象中的作用域。</span><br><span class="line">  &lt;!-- ECMAScript switch 语句 --&gt;</span><br><span class="line">  * switch 语句：switch 语句是 if 语句的兄弟语句。</span><br><span class="line">  * 语法：</span><br><span class="line">    switch (expression)</span><br><span class="line">      case value: statement;</span><br><span class="line">        break;</span><br><span class="line">      case value: statement;</span><br><span class="line">        break;</span><br><span class="line">      case value: statement;</span><br><span class="line">        break;</span><br><span class="line">      case value: statement;</span><br><span class="line">        break;</span><br><span class="line">    ...</span><br><span class="line">      case value: statement;</span><br><span class="line">        break;</span><br><span class="line">      default: statement;</span><br><span class="line">  * 每个情况（case）都是表示“如果 expression 等于 value，就执行 statement”。</span><br><span class="line">  &lt;!-- ECMAScript 函数概述 --&gt;</span><br><span class="line">  * 什么是函数？函数是由这样的方式进行声明的：关键字 function、函数名、一组参数，以及置于括号中的待执行代码。</span><br><span class="line">  * 如何调用函数？函数可以通过其名字加上括号中的参数进行调用，如果有多个参数。</span><br><span class="line">  * 函数如何返回值？即使函数确实有值，也不必明确地声明它。该函数只需要使用 return 运算符后跟要返回的值即可。</span><br><span class="line">  &lt;!-- ECMAScript arguments 对象 --&gt;</span><br><span class="line">  * 在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。</span><br><span class="line">  * 检测参数个数，还可以用 arguments 对象检测函数的参数个数，引用属性 arguments.length 即可。</span><br><span class="line">  * 模拟函数重载，用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载。</span><br><span class="line">  &lt;!-- ECMAScript Function 对象（类） --&gt;</span><br><span class="line">  * ECMAScript 的函数实际上是功能完整的对象。</span><br><span class="line">  * Function 对象（类）</span><br><span class="line">  - Function 对象的 length 属性</span><br><span class="line">  - Function 对象的方法，与所有对象共享的 valueOf() 方法和 toString() 方法。</span><br><span class="line">  &lt;!-- ECMAScript 闭包（closure） --&gt;</span><br><span class="line">  * 在ECMAScript中 最容易让人误解的一点是——它支持闭包（closure）。闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。</span><br><span class="line">  &lt;!-- ECMAScript 面向对象技术 --&gt;</span><br><span class="line">  * 一种面向对象语言需要向开发者提供四种基本能力：</span><br><span class="line">    封装 - 把相关的信息（无论数据或方法）存储在对象中的能力</span><br><span class="line">    聚集 - 把一个对象存储在另一个对象内的能力</span><br><span class="line">    继承 - 由另一个类（或多个类）得来类的属性和方法的能力</span><br><span class="line">    多态 - 编写能以多种方法运行的函数或方法的能力</span><br><span class="line">  &lt;!-- ECMAScript 对象应用 --&gt;</span><br><span class="line">  * 对象的创建和销毁都在 JavaScript 执行过程中发生，理解这种范式的含义对理解整个语言至关重要。</span><br><span class="line">  1.声明和实例化</span><br><span class="line">  2.对象引用</span><br><span class="line">  3.对象废除</span><br><span class="line">  4.早绑定和晚绑定</span><br><span class="line">  - 早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。</span><br><span class="line">  - 晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。</span><br><span class="line">  &lt;!-- ECMAScript 对象类型 --&gt;</span><br><span class="line">  * 在 ECMAScript 中，所有对象并非同等创建的。一般来说，可以创建并使用的对象有三种：本地对象、内置对象和宿主对象。</span><br><span class="line">  &lt;!-- ECMAScript 对象作用域 --&gt;</span><br><span class="line">  * 作用域指的是变量的适用范围。</span><br><span class="line">  1.公用、私有和受保护作用域：ECMAScript 只有公用作用域。</span><br><span class="line">  2.静态作用域：ECMAScript 没有静态作用域</span><br><span class="line">  3.关键字 this：关键字 this 总是指向调用该方法的对象。</span><br><span class="line">  &lt;!-- ECMAScript 定义类或对象 --&gt;</span><br><span class="line">  * 使用预定义对象只是面向对象语言的能力的一部分，它真正强大之处在于能够创建自己专用的类和对象。</span><br><span class="line">  1.工厂方式：</span><br><span class="line">  function createCar() &#123;</span><br><span class="line">    var oTempCar = new Object;</span><br><span class="line">    oTempCar.color = &quot;blue&quot;;</span><br><span class="line">    oTempCar.doors = 4;</span><br><span class="line">    oTempCar.mpg = 25;</span><br><span class="line">    oTempCar.showColor = function() &#123;</span><br><span class="line">      alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line">    return oTempCar;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var oCar1 = createCar();</span><br><span class="line">  var oCar2 = createCar();</span><br><span class="line">  2.构造函数方式：</span><br><span class="line">  function Car(sColor,iDoors,iMpg) &#123;</span><br><span class="line">    this.color = sColor;</span><br><span class="line">    this.doors = iDoors;</span><br><span class="line">    this.mpg = iMpg;</span><br><span class="line">    this.showColor = function() &#123;</span><br><span class="line">      alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var oCar1 = new Car(&quot;red&quot;,4,23);</span><br><span class="line">  var oCar2 = new Car(&quot;blue&quot;,3,25);</span><br><span class="line">  3.原型方式：</span><br><span class="line">  function Car() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Car.prototype.color = &quot;blue&quot;;</span><br><span class="line">  Car.prototype.doors = 4;</span><br><span class="line">  Car.prototype.mpg = 25;</span><br><span class="line">  Car.prototype.showColor = function() &#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var oCar1 = new Car();</span><br><span class="line">  var oCar2 = new Car();</span><br><span class="line">  4.混合的构造函数/原型方式：</span><br><span class="line">  function Car(sColor,iDoors,iMpg) &#123;</span><br><span class="line">    this.color = sColor;</span><br><span class="line">    this.doors = iDoors;</span><br><span class="line">    this.mpg = iMpg;</span><br><span class="line">    this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Car.prototype.showColor = function() &#123;</span><br><span class="line">    alert(this.color);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var oCar1 = new Car(&quot;red&quot;,4,23);</span><br><span class="line">  var oCar2 = new Car(&quot;blue&quot;,3,25);</span><br><span class="line"></span><br><span class="line">  oCar1.drivers.push(&quot;Bill&quot;);</span><br><span class="line"></span><br><span class="line">  alert(oCar1.drivers); //输出 &quot;Mike,John,Bill&quot;</span><br><span class="line">  alert(oCar2.drivers); //输出 &quot;Mike,John&quot;</span><br><span class="line">  5.动态原型方法：</span><br><span class="line">  class Car &#123;</span><br><span class="line">    public String color = &quot;blue&quot;;</span><br><span class="line">    public int doors = 4;</span><br><span class="line">    public int mpg = 25;</span><br><span class="line"></span><br><span class="line">    public Car(String color, int doors, int mpg) &#123;</span><br><span class="line">      this.color = color;</span><br><span class="line">      this.doors = doors;</span><br><span class="line">      this.mpg = mpg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void showColor() &#123;</span><br><span class="line">      System.out.println(color);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  6.混合工厂方式：</span><br><span class="line">  function Car() &#123;</span><br><span class="line">    var oTempCar = new Object;</span><br><span class="line">    oTempCar.color = &quot;blue&quot;;</span><br><span class="line">    oTempCar.doors = 4;</span><br><span class="line">    oTempCar.mpg = 25;</span><br><span class="line">    oTempCar.showColor = function() &#123;</span><br><span class="line">      alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line">    return oTempCar;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;!-- ECMAScript 修改对象 --&gt;</span><br><span class="line">  * prototype 属性不仅可以定义构造函数的属性和方法，还可以为本地对象添加属性和方法。</span><br><span class="line">  1.通过已有的方法创建新方法</span><br><span class="line">  2.重命名已有方法</span><br><span class="line">  3.添加与已有方法无关的方法</span><br><span class="line">  4.为本地对象添加新方法</span><br><span class="line">  5.重定义已有方法</span><br><span class="line">  6.极晚绑定（Very Late Binding）</span><br><span class="line">  &lt;!-- ECMAScript 继承机制实例 --&gt;</span><br><span class="line">  * 继承机制的实现：要用 ECMAScript 实现继承机制，您可以从要继承的基类入手。所有开发者定义的类都可作为基类。</span><br><span class="line">  * 继承的方式，所有的继承细节并非完全由解释程序处理。作为开发者，你有权决定最适用的继承方式：</span><br><span class="line">  - 对象冒充，构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。例如：</span><br><span class="line">    function ClassA(sColor) &#123;</span><br><span class="line">      this.color = sColor;</span><br><span class="line">      this.sayColor = function () &#123;</span><br><span class="line">          alert(this.color);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function ClassB(sColor) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  - 对象冒充可以实现多重继承，也就是说，一个类可以继承多个超类。例如：</span><br><span class="line">    function ClassZ() &#123;</span><br><span class="line">      this.newMethod = ClassX;</span><br><span class="line">      this.newMethod();</span><br><span class="line">      delete this.newMethod;</span><br><span class="line"></span><br><span class="line">      this.newMethod = ClassY;</span><br><span class="line">      this.newMethod();</span><br><span class="line">      delete this.newMethod;</span><br><span class="line">    &#125;</span><br><span class="line">  * call() 方法：call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。</span><br><span class="line">  - 例如：</span><br><span class="line">    function sayColor(sPrefix,sSuffix) &#123;</span><br><span class="line">      alert(sPrefix + this.color + sSuffix);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var obj = new Object();</span><br><span class="line">    obj.color = &quot;blue&quot;;</span><br><span class="line"></span><br><span class="line">    sayColor.call(obj, &quot;The color is &quot;, &quot;a very nice color indeed.&quot;);</span><br><span class="line">  * apply() 方法：apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。</span><br><span class="line">  - 例如：</span><br><span class="line">    function sayColor(sPrefix,sSuffix) &#123;</span><br><span class="line">        alert(sPrefix + this.color + sSuffix);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var obj = new Object();</span><br><span class="line">    obj.color = &quot;blue&quot;;</span><br><span class="line"></span><br><span class="line">    sayColor.apply(obj, new Array(&quot;The color is &quot;, &quot;a very nice color indeed.&quot;));</span><br><span class="line">  * 原型链（prototype chaining）：继承这种形式在 ECMAScript 中原本是用于原型链的。</span><br><span class="line">  - 例如：</span><br><span class="line">    function ClassA() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassA.prototype.color = &quot;blue&quot;;</span><br><span class="line">    ClassA.prototype.sayColor = function () &#123;</span><br><span class="line">        alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function ClassB() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassB.prototype = new ClassA();</span><br><span class="line">  * 混合方式：这种继承方式使用构造函数定义类，并非使用任何原型。</span><br><span class="line">  - 例如：</span><br><span class="line">    function ClassA(sColor) &#123;</span><br><span class="line">      this.color = sColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassA.prototype.sayColor = function () &#123;</span><br><span class="line">      alert(this.color);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function ClassB(sColor, sName) &#123;</span><br><span class="line">      ClassA.call(this, sColor);</span><br><span class="line">      this.name = sName;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ClassB.prototype = new ClassA();</span><br><span class="line">    ClassB.prototype.sayName = function () &#123;</span><br><span class="line">      alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript DOM2和DOM3扩展</title>
    <link href="https://liushuai97.github.io/2019/09/17/JavaScript-DOM2%E5%92%8CDOM3%E6%89%A9%E5%B1%95/"/>
    <id>https://liushuai97.github.io/2019/09/17/JavaScript-DOM2和DOM3扩展/</id>
    <published>2019-09-17T06:12:17.000Z</published>
    <updated>2019-09-17T06:13:08.576Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;JavaScript DOM2和DOM3扩展&lt;/title&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/transitions.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">     // 立即执行函数</span><br><span class="line">    (function () &#123;</span><br><span class="line">      // 严格模式</span><br><span class="line">      &quot;use strict&quot;;</span><br><span class="line">      // DOM的变化</span><br><span class="line">      // DOM2级和3级的目的在于扩展DOM API，以满足操作XML的所有需求，同事提供更好的错误处理及特性检测能力。从某种意义上来讲，实现这一目的的很大程度意味着对命名空间的支持</span><br><span class="line"></span><br><span class="line">      // 针对XML命名空间的变化</span><br><span class="line"></span><br><span class="line">      // 1.Node类型的变化</span><br><span class="line">      </span><br><span class="line">      // 在DOM2级中，Node类型包含下列特定于命名空间的属性：</span><br><span class="line">      // localName - 不带命名空间前缀的节点名称</span><br><span class="line">      // namespaceURI - 命名空间URI或者（在未指定的情况下是）null</span><br><span class="line">      // prefix - 命名空间前缀或者（在未指定的情况下是）null</span><br><span class="line"></span><br><span class="line">      // DOM3级在此基础上更进一步，又引入了下列与命名空间有关的方法：</span><br><span class="line">      // isDefaultNamespace(namespace: DOMString) - 在指定的namespaceURI是当前节点的默认命名空间的情况下返回true</span><br><span class="line">      // lookupNamespaceURI(prefix: DOMString) - 返回给定prefix的命名空间</span><br><span class="line">      // lookupPrefix(namespace: DOMString) - 返回给定 namespaceURI的前缀</span><br><span class="line"></span><br><span class="line">      // 2.Document类型的变化</span><br><span class="line"></span><br><span class="line">      // DOM2级中的Document类型也发生了变化，包含下列命名空间有关的方法：</span><br><span class="line">      // createElementNS(namespace: DOMString, qualifiedName: DOMString) - 使用给定的 tagName 创建一个属于命名空间 namespaceURI 的新元素</span><br><span class="line">      // createAttributeNS(namespaceURI, attributName) - 使用给定的attributName 创建一个属于命名空间 namespaceURI的新元素</span><br><span class="line">      // getElementsByTagNameNS(namespace: DOMString, localName: DOMString) - 返回属于命名空间 namespaceURI 的 tagName 元素的 NodeList</span><br><span class="line"></span><br><span class="line">      // 3.Element类型的变化</span><br><span class="line"></span><br><span class="line">      // DOM2级核心中有关Element的变化，主要涉及操作特性，新增的方法如下：</span><br><span class="line">      // getAttributeNS(namespace: DOMString, localName: DOMString) - 取得属于命名空间 namespaceURI 且名为 localName 的特性</span><br><span class="line">      // getAttributeNodeNS(namespaceURI, tagName) - 返回属于命名空间 namespaceURI 且名为 localName 的特性</span><br><span class="line">      // getElementsByTagNameNS(namespace: DOMString, localName: DOMString) - 返回属于命名空间 namespaceURI 的 tagName 元素的 NodeList</span><br><span class="line">      // hasAttributeNS(namespace: DOMString, localName: DOMString) - 确定当前元素是否有一个名为 localName 的特性，而且该特性的命名空间是 namespaceURI。</span><br><span class="line">      // removeAttributeNS(namespace: DOMString, localName: DOMString) - 删除属于命名空间 namespaceURI 且名为 localName 的特性。</span><br><span class="line">      // setAttributeNS(namespace: DOMString, name: DOMString, value: DOMString) - 设置属于命名空间 namespaceURI 且名为 qualifiedName 的特性的值为 value。</span><br><span class="line">      // setAttributeNodeNs(attNode) - 设置属于命名空间 namespaceURI的特性节点。</span><br><span class="line"></span><br><span class="line">      // 4.NamedNodeMap类型的变化</span><br><span class="line"></span><br><span class="line">      // NamedNodeMap类型也新增了下列与命名空间有关的方法。由于特性是通过NamedNodeMap表示的，因此这些方法多数情况下只针对特性使用。</span><br><span class="line">      // getNamedItemNS(namespaceURI, localName) - 取得属于命名空间 namespaceURI 且名为 localName 的项</span><br><span class="line">      // removeNamedItemNS(namespaceURI, localName) - 移出属于命名空间 namespaceURI 且名为 localName 的项。</span><br><span class="line">      // setNamedItemNS(node) - 添加node，这个节点已经实现指定了命名空间信息。</span><br><span class="line"></span><br><span class="line">      // 其他方面的变化</span><br><span class="line"></span><br><span class="line">      // 1.DocumentType 类型的变化</span><br><span class="line"></span><br><span class="line">      // DocumentType 类型新增了3个属性：publicId、systemId 和 internalSubset。其中，前两个属性表示的是文档类型声明中的两个信息段，这两个信息段在DOM1级中是没有办法访问到的。</span><br><span class="line"></span><br><span class="line">      // 2.Document 类型的变化</span><br><span class="line"></span><br><span class="line">      // Document类型的变化中唯一与命名空间无关的方法是importNode()。这个方法的用途是从一个文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档结构的一部分。需要注意的是，每个节点都有一个ownerDocument属性，表示所属的文档。</span><br><span class="line">      // 如果调用appendChild()时传入的节点属于不同的文档（ownerDocument属性的值不一样），则会导致错误。</span><br><span class="line">      // 但在调用importNode()时传入不同文档的节点则会返回一个新节点，这个新节点的所有权归当前文档所有。</span><br><span class="line"></span><br><span class="line">      // importNode()方法与Element与cloneNode()方法非常相似，它接受两个参数：要复制的节点和一个表示是否复制子节点的布尔值。返回的结果是原来节点的副本，但能够在当前文档中使用。</span><br><span class="line"></span><br><span class="line">      // var newNode = document.importNode(oldNode, true) //导入节点机器所有子节点</span><br><span class="line">      // document.body.appendChild(newNode)</span><br><span class="line"></span><br><span class="line">      // DOM2级视图模块添加了一个名为defaultView的属性，其中保存着一个指针，指向拥有给定文档的窗口（或框架）。</span><br><span class="line"></span><br><span class="line">      // var parentWindow = document.defaultView || document.parentWindow;</span><br><span class="line"></span><br><span class="line">      // DOM2级核心为document.implementation对象规定了两个新方法：createDocumentType() 和 createDocument()。前者用于创建一个新的DocumentType节点，接收3个参数：文档类型名称、publicId、systemId。</span><br><span class="line"></span><br><span class="line">      // createDocumentType()只在创建新文档时有用：创建新文档时需要用到createDocument()方法。这个方法接受3个参数：针对文档中元素的namespaceURI、文档元素的标签名、新文档的文档类型。</span><br><span class="line"></span><br><span class="line">      // var doctype = document.implementation.createDocumentType(&quot;html&quot;,&quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;, &quot;http://www.w3.org/TR/xhtml/DTD/xhtml-strict.dtd&quot;);</span><br><span class="line"></span><br><span class="line">      // var doc = document.implementation.createDocument(&quot;http://www.w3.org/1999/xhtml&quot;,&quot;html&quot;,doctype);</span><br><span class="line"></span><br><span class="line">      // DOM2级HTML模块也为document.implementation新增了一个方法，名叫createHTMLdocument()。这个方法用途是创建一个完整的HTML文档，包括&lt;html&gt;、&lt;head&gt;、&lt;title&gt;和&lt;body&gt;元素。这个方法只接受一个参数，即新创建文档的标题(放在&lt;title&gt;元素中的字符串)，返回新的HTML文档。</span><br><span class="line"></span><br><span class="line">      // var htmldoc = document.implementation.createHTMLDocument(&quot;New Doc&quot;);</span><br><span class="line">      // console.log(htmldoc.title);</span><br><span class="line">      // console.log(typeof htmldoc.body);</span><br><span class="line"></span><br><span class="line">      // 3.Node类型的变化</span><br><span class="line">      // Node类型中唯一与命名空间无关的变化，及时添加了isSupported()方法。用于确定当前节点具有什么能力。</span><br><span class="line"></span><br><span class="line">      // if(document.body.isSupported(&quot;html&quot;, &quot;2.0&quot;))&#123;</span><br><span class="line">      //   执行只有“DOM2 级HTML”才支持的操作</span><br><span class="line">      // &#125;</span><br><span class="line"></span><br><span class="line">      // DOM3级引入了两个辅助比较节点的方法 isSameNode() 和isEqualNode()。这两个方法都接收一个节点参数，并在窜入节点与引用的节点相同或相等时返回true。所谓相同，指的是两个节点引用的是同一个对象。</span><br><span class="line"></span><br><span class="line">      // var div1 = document.createElement(&apos;div&apos;);</span><br><span class="line">      // div1.setAttribute(&apos;class&apos;,&apos;box&apos;);</span><br><span class="line"></span><br><span class="line">      // var div2 = document.createElement(&apos;div&apos;);</span><br><span class="line">      // div2.setAttribute(&apos;class&apos;, &apos;box&apos;);</span><br><span class="line"></span><br><span class="line">      // console.log(div1.isSameNode(div2));</span><br><span class="line">      // console.log(div1.isEqualNode(div2));</span><br><span class="line">      // console.log(div1.isSameNode(div2));</span><br><span class="line"></span><br><span class="line">      // DOM3级还针对DOM节点添加额外数据引入了新方法。其中，setUserData() 方法会将数据指定节点，它接受3个参数：要设置的键、实际的数据（可以是任何数据类型）和处理函数。一下代码可以将数据指定给一个节点。</span><br><span class="line"></span><br><span class="line">      // document.body.setUserData(&quot;name&quot;,&quot;Nicholas&quot;,function()&#123;&#125;);</span><br><span class="line"></span><br><span class="line">      // var value = document.body.getUserData(&quot;name&quot;);</span><br><span class="line"></span><br><span class="line">      // 传入 setUserData()中的处理函数会在带有数据的节点被复制、删除、重命名或引入一个文档时调用，因而你可以实现决定在上述操作发生时如何处理用户数据。处理函数接受5个参数：表示操作类型的数值（1 - 表示复制 2 - 表示导入 3 - 表示删除 4 - 表示重命名）、数据键、数据值、源节点和目标节点。再删除节点时，源节点null；复制节点时，目标节点时null。</span><br><span class="line"></span><br><span class="line">      // var div = document.createElement(&apos;div&apos;);</span><br><span class="line">      // div.setUserData(&apos;name&apos;,&apos;Nicholas&apos;,function(operation,key,value,src,dest)&#123;</span><br><span class="line">      //   if(operation === 1)&#123;</span><br><span class="line">      //     dest.setUserData(key,value,function()&#123;&#125;);</span><br><span class="line">      //   &#125;</span><br><span class="line">      // &#125;);</span><br><span class="line"></span><br><span class="line">      // var newDiv = div.cloneNode(true);</span><br><span class="line">      // console.log(newDiv.getUserData(&apos;name&apos;));</span><br><span class="line"></span><br><span class="line">      // 4.框架的变化</span><br><span class="line">      // 框架和内嵌框架分别用HTMLFrameElement和HTMLFrameElement表示，它们在DOM2级中都有了一个新属性，名叫contentDocument。这个属性包含一个指针，指向表示框架内容的文档对象。</span><br><span class="line"></span><br><span class="line">      // var iframe = document.getElementById(&apos;myIframe&apos;);</span><br><span class="line">      // var iframeDoc = iframe.contentDocument;  // 在IE8以前的版本中无效</span><br><span class="line"></span><br><span class="line">      // IE8之前支持的一个属性contentWindow的属性。改属性返回框架的window对象，而这个window对象又有一个document属性。因此，要向在上述所有浏览器汇总访问内嵌框架的文档对象</span><br><span class="line"></span><br><span class="line">      // var iframe = document.getElementById(&apos;myIframe&apos;);</span><br><span class="line">      // var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</span><br><span class="line"></span><br><span class="line">      // 样式</span><br><span class="line"></span><br><span class="line">      // 访问元素的样式</span><br><span class="line">      // css属性              —— javascript属性</span><br><span class="line">      // background-image        style.backgroundImage</span><br><span class="line">      // color                   style.color</span><br><span class="line">      // display                 style.display</span><br><span class="line">      // font-family             style.fontFamily</span><br><span class="line"></span><br><span class="line">      // 1.DOM样式属性和方法</span><br><span class="line">      </span><br><span class="line">      // DOM2级样式规范还未style对象定义了一些属性和方法。</span><br><span class="line">      // cssText: 通过它能够访问到style特性中的CSS代码。</span><br><span class="line">      // length: 应用给元素的CSS属性的数量</span><br><span class="line">      // parentRule: 表示CSS信息CSSRule对象。</span><br><span class="line">      // getPropertyCSSValue(propertyName): 返回包含给定属性值的CSSValu对象。</span><br><span class="line">      // getProperPriority(propertyName): 如果给定属性使用了!important设置，则返回“important”,否则返回空字符串。</span><br><span class="line">      // getPropertyValue(propertyName): 返回给定属性的字符串值。</span><br><span class="line">      // item(index): 返回给定位置的CSS属性的名称。</span><br><span class="line">      // removeProperty(propertyName): 从样式中删除给定属性。</span><br><span class="line">      // setProperty(propertyName,value,priority): 将给定属性设置为相应的值，并加上优化权标志（“important”或者一个空字符串）。</span><br><span class="line"></span><br><span class="line">      // 2.计算的样式</span><br><span class="line"></span><br><span class="line">      // DOM2级样式增强了document.defaultView，提供了getComputedStyle()方法。这个方法接受两个参数：要取得计算样式的元素和一个微元素字符串（例如：“:after”）.如果不需要伪元素信息，第二个参数可以是null。getComputedStyle()方法返回一个CSSStyleDeclaration对象（与style属性的类型相同），其中包含当前元素的所有计算的样式。</span><br><span class="line"></span><br><span class="line">      // 操作样式表</span><br><span class="line"></span><br><span class="line">      // CSSStyleSheet类型表示的是样式表，报错通过&lt;link&gt;元素包含的样式表在&lt;sytle&gt;元素中定义的样式表。从StyleSheet接口继承而来的属性如下：</span><br><span class="line">      // disabled: 表示样式表是否被禁用的布尔值。</span><br><span class="line">      // href：如果样式表示通过&lt;link&gt;包含的，则样式表的URL，否则，是NULL。</span><br><span class="line">      // media：当前样式表支持的所有媒体类型的集合。</span><br><span class="line">      // ownerNode：指向拥有当前样式表的节点的指针。样式表可能在HTML通过&lt;link&gt;或&lt;style/&gt;引入的（在XML中可能是通过处理指令引入的）。如果当前样式表是其他样式表通过@import导入的情况下，这个属性值为null。</span><br><span class="line">      // parentStyleSheet：在当前样式表是通过@import导入的情况下，这个属性是一个指向导入他的样式表的指针。</span><br><span class="line">      // title：ownerNode中title属性的值。</span><br><span class="line">      // type：表示样式表类型的字符串。</span><br><span class="line">      // cssRule：如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为null。</span><br><span class="line">      // deleteRule(index)：删除cssRules集合中指定的位置插入rule字符串。</span><br><span class="line">      // insertRule(rule, index)：向cssRules集合中指定的位置插入rule字符串。</span><br><span class="line"></span><br><span class="line">      // 1.CSS规则</span><br><span class="line"></span><br><span class="line">      // cssText：返回整条规则对应的文本。</span><br><span class="line">      // parentRule：如果当前规则是导入的规则，这个属性应用就是导入规则；否则，这个值为null。</span><br><span class="line">      // parentStyleSheet：当前规则所属的样式表。</span><br><span class="line">      // selectorText：返回当前规则的选择符文本。</span><br><span class="line">      // style：一个CSSStyleDeclaration对象，可以通过它设置或取得规则中特性的样式值。</span><br><span class="line">      // type: 表示规则类型的常量值。</span><br><span class="line"></span><br><span class="line">      // 2.创建规则</span><br><span class="line">      // insertRule()方法。这个方法接受两个参数：规则文本和表示在哪里插入规则的索引。</span><br><span class="line"></span><br><span class="line">      // 3.删除规则</span><br><span class="line">      // deleteRule()方法，这个方法接受一个参数：要删除的规则的位置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      // 元素大小</span><br><span class="line"></span><br><span class="line">      // 1.偏移量 - 包括元素在屏幕上占用的所有可见的空间。元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小（注意：不包括外边距）。有4个属性可以取得元素偏移量：</span><br><span class="line">      // offsetHeight：元素在垂直方向上占用的空间大小，以像素计。</span><br><span class="line">      // offsetWidth：元素在水平方向上占用的空间大小，以像素计。</span><br><span class="line">      // offsetLeft：元素左外边框至包含元素的左内边距之间的像素距离。</span><br><span class="line">      // offsetRight：元素上外边框至包含元素的上内边框之间的像素距离。</span><br><span class="line"></span><br><span class="line">      // 2.客户区大小 - 元素内容及其内边距所占据的空间大小。</span><br><span class="line">      // clientWidth：元素内容区宽度加上左右边距宽度。</span><br><span class="line">      // clientHeight：元素内容区高度加上上下内边距高度。</span><br><span class="line"></span><br><span class="line">      // 3.滚动大小 - 包含滚动内容的元素大小。</span><br><span class="line">      // scrollHeight：在没有滚动条的情况下，元素内容的总高度。</span><br><span class="line">      // scrollWidth：在没有滚动条的情况下，元素内容的总宽度。</span><br><span class="line">      // scrollLeft：被隐藏在内容区域左侧的像素数。通过设置这个属性可以改变元素的滚动位置。</span><br><span class="line">      // scrollTop: 被隐藏在内容区域上方的像素数。通过设置这个属性可以改变元素的滚动位置。</span><br><span class="line"></span><br><span class="line">      // 4.确定元素大小</span><br><span class="line">      // getBoundingClientRect()方法。这个方法返回一个矩形对象，包含4个属性：left、top、right和bottom。</span><br><span class="line"></span><br><span class="line">      // 遍历</span><br><span class="line">      // DOM2级遍历和范围模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker。这两个类型能够基于给定的起点对DOM结构执行深度优化的遍历操作。</span><br><span class="line"></span><br><span class="line">      // 检测浏览器对DOM2级遍历能力的支持情况</span><br><span class="line">      // var supportsTraversale = document.implementation.hasFocus(&quot;Traversal&quot;, &apos;2.0&apos;);</span><br><span class="line">      // var supportsNodeIterator = (typeof document.createNodeIterator === &quot;function&quot;);</span><br><span class="line">      // var supportaTreeWalker = (typeof document.createTreeWalker === &quot;function&quot;)</span><br><span class="line"></span><br><span class="line">      // createNodeIterator(root: Node, whatToShow?: unsigned long, filter?: NodeFilter)</span><br><span class="line">      // 这个方法接受下列4个参数：</span><br><span class="line"></span><br><span class="line">      // root：想要座位搜索起点的树中的节点。</span><br><span class="line">      // whatToShow：表示要访问哪些节点的数字代码。</span><br><span class="line">      // filter：是一个NodeFilter对象，或者一个表示应该接受还是拒绝谋众特定节点的函数。</span><br><span class="line">      // entityReferenceExpansion：布尔值，便是是否要扩展实体引用。这个参数在HTML页面中没有用，因为其中的实体引用不能扩展。</span><br><span class="line"></span><br><span class="line">      // whatToShow参数是一个位掩码，通过应用一个或多个过滤器（filter）来确定要访问哪些节点。这个参数与的值以常量形式在NodeFilter类型中定义，如下所示：</span><br><span class="line">      // NodeFilter.SHOW_All：显示所有类型的节点。</span><br><span class="line">      // NodeFilter.SHOW_ELEMENT：显示元素节点。</span><br><span class="line">      // NodeFilter.SHOW_ATTRIBUTE：显示特性节点。</span><br><span class="line">      // NodeFilter.SHOW_TEXT：显示文本节点。</span><br><span class="line">      // NodeFilter.SHOW_CDATA_SECTION：显示CDAT节点。对HTML页面没有用。</span><br><span class="line">      // NodeFilter.SHOW_ENTITY_REFERENCE：显示实体引用节点。对HTML页面没有用。</span><br><span class="line">      // NodeFilter.SHOW_ENTITYE：显示实体节点。对HTML页面没有用。</span><br><span class="line">      // NodeFilter.SHOW_PROCESSING_INSTRUCTION：显示处理指令节点。对HTML页面没有用。</span><br><span class="line">      // NodeFilter.SHOW_COMMENT：显示注释节点。</span><br><span class="line">      // NodeFilter.SHOW_DOCUMENT：显示文档节点。</span><br><span class="line">      // NodeFilter.SHOW_DOCUMENT_TYPE：显示文档类型的节点。</span><br><span class="line">      // NodeFilter.SHOW_DOCUMENT_FRAGMENT：显示文档片段的节点。对HTML页面没有用。</span><br><span class="line">      // NodeFilter.SHOW_NOTATION：显示符合节点。对HTML页面没有用。</span><br><span class="line"></span><br><span class="line">      // TreeWalker，是NodeIterator的一个更高级的版本。除了包括nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法。</span><br><span class="line"></span><br><span class="line">      // parentNode()：遍历当前节点的父节点。</span><br><span class="line">      // firstChild()：遍历当前节点的第一个子节点。</span><br><span class="line">      // lastChild()：遍历当前节点的最后一个子节点。</span><br><span class="line">      // nextSibling()：遍历当前节点的下一个同辈节点。</span><br><span class="line">      // previousSibling()：遍历当前节点的上一个同辈节点。</span><br><span class="line"></span><br><span class="line">      // 创建TreeWalker对象要使用document.createTreeWalker(root: Node, whatToShow?: unsigned long, filter?: NodeFilter)方法，这个方法接受4个参数与document.createNodeIterator(root: Node, whatToShow?: unsigned long, filter?: NodeFilter)方法相同：</span><br><span class="line">      // 作为遍历起点的根节点、要显示的节点类型、过滤器和一个表示是否扩展实体引用的布尔值。</span><br><span class="line"></span><br><span class="line">      // var div = document.getElementById(&apos;div1&apos;);</span><br><span class="line">      // var filter = function(node)&#123;</span><br><span class="line">      //   return node.tagName.toLowerCase() === &quot;li&quot; ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;</span><br><span class="line">      // &#125;;</span><br><span class="line"></span><br><span class="line">      // var walker = document.createTreeWalker(div, NodeFilter.SHOW_ELEMENT, filter, false);</span><br><span class="line"></span><br><span class="line">      // var node = iterator,nextNode();</span><br><span class="line">      // while(node !== null)&#123;</span><br><span class="line">      //   console.log(node.tagName);  // 输出标签名</span><br><span class="line">      //   node = iterator.nextNode();</span><br><span class="line">      // &#125;</span><br><span class="line"></span><br><span class="line">      // 范围，DOM2级遍历和范围模块定义了范围接口。</span><br><span class="line"></span><br><span class="line">      // DOM中的范围</span><br><span class="line">      // DOM2级在Document类型中定义了createRange()方法。每个范围由一个Range类型的实例来表示，这个实例拥有很多属性和方法：</span><br><span class="line">      // startContainer：包含范围起点的节点（即选区中第一个节点的父节点）</span><br><span class="line">      // startOffset：范围在startContainer中起点的偏移量。如果startContainer是文本节点、注释节点或CDATA节点，那么startOffset就是范围起点之前跳过的字符数量。否则startOffset就是范围中第一个子节点的索引。</span><br><span class="line">      // endContainer：包含范围重点的节点（即选区中最后一个节点的父节点）</span><br><span class="line">      // endOffset：范围在endContainer中终点的偏移量（与startOffset遵循相同的取值规则）。</span><br><span class="line">      // commonAncestorContainer：startContainer和endContainer共同的祖先节点在文档树中位置最深的那个。</span><br><span class="line">      // setStartBefore(refNode)：将范围的起点设置在refNode之前，因此refNode也就是范围选区中的第一个子节点。同事会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引。</span><br><span class="line">      // setStartAfter(refNode)：将范围的起点设置在refNode之后，因此refNode也就不再范围之内了，其下一个同辈节点才是范围选区中的第一个子节点。同时会将startContainer属性设置为refNode.parentNode，将startOffset属性设置为refNode在其父节点的childNodes集合中的索引加1.</span><br><span class="line">      // setEndBefore(refNode)：将范围的重点设置在refNode之前，因此refNode也就不再范围之内了，其上一个同辈节点才是范围选区中的最后一个子节点。同时会将endContainer属性设置为refNode.parentNode，将endOffset属性设置为refNode再其父节点的childNodes集合中的索引。</span><br><span class="line">      // setEndAfter(refNode)：将范围的重点设置在refNode之后，因此refNode也就是范围选区中的最后一个子节点。同时会将endCOntainer属性设置为refNode.parentNode，将endOffset属性设置为refNode在其父节点的childNode集合中的索引加1.</span><br><span class="line"></span><br><span class="line">      // 1.用DOM范围实现简单选择</span><br><span class="line">      </span><br><span class="line">      // &lt;!DOCTYPE html&gt;</span><br><span class="line">      // &lt;html&gt;</span><br><span class="line">      // &lt;head&gt;</span><br><span class="line">      //   &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">      //   &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">      //   &lt;title&gt;&lt;/title&gt;</span><br><span class="line">      //   &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;</span><br><span class="line">      // &lt;/head&gt;</span><br><span class="line">      // &lt;body&gt;</span><br><span class="line">      //   &lt;p id=&quot;p1&quot;&gt;</span><br><span class="line">      //     &lt;b&gt;Hello&lt;/b&gt; world!</span><br><span class="line">      //   &lt;/p&gt;</span><br><span class="line">      // &lt;/body&gt;</span><br><span class="line">      // &lt;/html&gt;</span><br><span class="line">      </span><br><span class="line">      // var range1 = document.createRange();</span><br><span class="line">      //     range2 = document.createRange();</span><br><span class="line">      //     p1 = document.getElementById(&apos;p1&apos;);</span><br><span class="line"></span><br><span class="line">      // range1.selectNode(p1);</span><br><span class="line">      // range2.selectNodeContents(p1);</span><br><span class="line"></span><br><span class="line">      // 2.用DOM范围实现复杂选择</span><br><span class="line">      // 要创建复杂的范围就得使用setStart()和setEnd()方法。这两个方位都接受两个参数：一个参展节点和一个偏移量。</span><br><span class="line"></span><br><span class="line">      // 3.操作DOM范围中的内容</span><br><span class="line">      // deleteContents()，这个方法能够从文档中删除范围所包含的内容。</span><br><span class="line">      // extractContents()，也会从文档中移出范围选区。会返回范围的文档片段。</span><br><span class="line">      // cloneContents()，创建范围对象的一个副本，然后在文档的其他地方插入该副本。返回范围中节点的副本。</span><br><span class="line"></span><br><span class="line">      // 4.插入DOM范围中的内容</span><br><span class="line">      // insertNode()可以向范围选区的开始处插入一个节点。</span><br><span class="line">      // surroundContents(newParent: Node)，环绕范围插入节点，这个方法接受一个参数，即环绕范围内容的节点。</span><br><span class="line"></span><br><span class="line">      // 5.折叠DOM范围</span><br><span class="line">      // collapse()方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠刀范围的哪一端。</span><br><span class="line"></span><br><span class="line">      // 6.比较DOM范围</span><br><span class="line">      // compareBoundaryPoints(how: unsigned short, sourceRange: Range) 方法来确定这些范围是否有公共的边界（起点或重点）。这个方法接受两个采纳数：表示比较方式的常量值和要比较的范围。</span><br><span class="line"></span><br><span class="line">      // 7.复制DOM范围</span><br><span class="line">      // cloneRange()</span><br><span class="line"></span><br><span class="line">      // 8.清理DOM范围</span><br><span class="line">      // 在使用完范围之后，最好是调用detach()方法，以便从创建范围的文档中分离出该范围。</span><br><span class="line"></span><br><span class="line">      // range1.detach();  // 从文档中分离</span><br><span class="line">      // range1 = null;  // 解除引用</span><br><span class="line"></span><br><span class="line">      // IE8及更早版本中的范围</span><br><span class="line">    &#125;)()</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript DOM扩展</title>
    <link href="https://liushuai97.github.io/2019/09/16/JavaScript-DOM%E6%89%A9%E5%B1%95/"/>
    <id>https://liushuai97.github.io/2019/09/16/JavaScript-DOM扩展/</id>
    <published>2019-09-16T09:29:38.000Z</published>
    <updated>2019-09-16T09:29:57.689Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;JavaScript DOM扩展&lt;/title&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; href=&quot;./assets/transitions.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; id=&quot;box&quot; name=&quot;box&quot; title=&quot;box&quot; lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;</span><br><span class="line">    &lt;!-- &lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">      &lt;li&gt;第一个节点&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;第二个节点&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;第三个节点&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;第四个节点&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;第五个节点&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt; --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    // 立即执行函数</span><br><span class="line">    (function () &#123;</span><br><span class="line">      // 严格模式</span><br><span class="line">      &quot;use strict&quot;;</span><br><span class="line">      // JavaScript单线程设计的初衷就是为了操作DOM元素</span><br><span class="line">      // Node类型</span><br><span class="line">      // if (someNode.nodeType === Node.ELEMENT_NODE) &#123;</span><br><span class="line">      //   // 在IE中无效</span><br><span class="line">      //   console.log(&quot;node is an element&quot;);</span><br><span class="line">      //   if (someNode.nodeType === 1) &#123;</span><br><span class="line">      //     // 适用所有浏览器</span><br><span class="line">      //     console.log(&quot;node is an element&quot;);</span><br><span class="line">      //   &#125;</span><br><span class="line">      // &#125;</span><br><span class="line">      // nodeName的值是元素的标签名  nodeValue的值始终是null</span><br><span class="line">      // if (someNode.nodeType === 1) &#123;</span><br><span class="line">      //   value = someNode.nodeName;</span><br><span class="line">      // &#125;</span><br><span class="line">      </span><br><span class="line">      // 节点关系   childNodes    firstNode lastNode parentNode nextSibling  perviousSlibling</span><br><span class="line">      // var firstChild = someNode.childNodes[0];</span><br><span class="line">      // var secondChild = someNode.childNodes.item[1];</span><br><span class="line">      // var count = someNode.childNodes.length;</span><br><span class="line"></span><br><span class="line">      // 操作节点  </span><br><span class="line">      // appendChild() 向childNodes列表的末尾添加一个节点</span><br><span class="line">      // insertBefore() 参数：要插入的节点，作为参照的节点。   被插入的节点会变成参照节点前的一个同胞节点previousSlibing，同时方法被返回。如果参照节点为null，则执行结果与appendChild()相同。</span><br><span class="line">      // replaceChild() 参数：要插入的节点，要替换的节点。</span><br><span class="line">      // removeChild()  参数：要移出的节点</span><br><span class="line">      // 其他方法： cloneNode()  用于创建调用这个方法的节点的一个完全相同的副本。</span><br><span class="line">      // var list = document.getElementById(&apos;list&apos;);</span><br><span class="line">      // var clist = list.cloneNode(true);</span><br><span class="line">      // console.log(clist.childNodes.length)</span><br><span class="line">      // var clonelist = list.cloneNode(false);</span><br><span class="line">      // console.log(clonelist.childNodes.length)</span><br><span class="line"></span><br><span class="line">      // document方法</span><br><span class="line">      // 对HTML的引用</span><br><span class="line">      var html = document.documentElement;</span><br><span class="line">      console.log(html === document.childNodes[0]);</span><br><span class="line">      console.log(html === document.firstChild);</span><br><span class="line">      // 对Body的引用</span><br><span class="line">      var body = document.body;</span><br><span class="line">      // 对&lt;!DOCTYPE&gt;的引用</span><br><span class="line">      var doctype = document.doctype;</span><br><span class="line">      // 设置文档标题</span><br><span class="line">      document.title = &apos;标题&apos;;</span><br><span class="line">      // 取得完整URL</span><br><span class="line">      console.log(document.URL);</span><br><span class="line">      // 取得域名</span><br><span class="line">      console.log(document.domain);</span><br><span class="line">      // 取得来源页面的URL</span><br><span class="line">      console.log(document.referrer);</span><br><span class="line">      // 查找元素</span><br><span class="line">      // document.getElementById(&apos;id&apos;)  通过元素ID获取节点。</span><br><span class="line">      var div = document.getElementById(&apos;box&apos;);</span><br><span class="line">      // document.getElementByName(&apos;name&apos;) 通过元素Name获取节点。</span><br><span class="line">      var box = document.getElementsByName(&apos;box&apos;);</span><br><span class="line">      // document.getElementByTabName(&apos;div&apos;) 通过元素标签获取节点。</span><br><span class="line">      var tagDiv = document.getElementsByTagName(&apos;div&apos;);</span><br><span class="line">      // htmlControl</span><br><span class="line">      console.log(tagDiv.length);</span><br><span class="line">      console.log(tagDiv.item(0).className);</span><br><span class="line">      // document.getElementByTagName(&apos;*&apos;) 返回所有注释的节点</span><br><span class="line">      console.log(document.getElementsByTagName(&apos;*&apos;));</span><br><span class="line">      // 特殊集合</span><br><span class="line">      // document.anchors  包含文档中所有带name特性的a元素</span><br><span class="line">      console.log(document.anchors);</span><br><span class="line">      // document.forms 包含所当中所有form元素</span><br><span class="line">      console.log(document.forms);</span><br><span class="line">      // document.images 包含文档中所有image元素</span><br><span class="line">      console.log(document.images);</span><br><span class="line">      // document.links 包含文档中所有带有href特性的a元素</span><br><span class="line">      console.log(document.links);</span><br><span class="line">      // Dom一致性检测  浏览器支持此给定名称及版本的功能，则返回true</span><br><span class="line">      var hasXmlDom = document.implementation.hasFeature(&apos;XML&apos;, &apos;1.0&apos;);</span><br><span class="line">      console.log(hasXmlDom);</span><br><span class="line">      // 文档写入</span><br><span class="line">      document.writeln(&apos;我是无敌的！&apos;); // 会在字符串末尾添加一个换行\n</span><br><span class="line">      document.write(&apos;我就是超级无敌宇宙赛亚人！&apos;); // 要写入输出流的文本</span><br><span class="line">      document.open()  // 打开网页的输出流</span><br><span class="line">      document.close() // 关闭网页的输出流</span><br><span class="line">      // element类型</span><br><span class="line">      var dbox = document.getElementById(&apos;box&apos;);</span><br><span class="line">      // 适用于任何文档</span><br><span class="line">      if(dbox.tagName.toLowerCase === &apos;div&apos;)&#123;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">      // html元素</span><br><span class="line">      console.log(dbox.id);</span><br><span class="line">      console.log(dbox.className);</span><br><span class="line">      console.log(dbox.title);</span><br><span class="line">      console.log(dbox.lang);</span><br><span class="line">      console.log(dbox.dir);</span><br><span class="line">      // 取得特性</span><br><span class="line">      console.log(dbox.getAttribute(&apos;id&apos;));</span><br><span class="line">      // 删除特性</span><br><span class="line">      console.log(dbox.removeAttribute(&apos;class&apos;))</span><br><span class="line">      // 设置特性</span><br><span class="line">      console.log(dbox.setAttribute(&apos;class&apos;,&apos;box&apos;));</span><br><span class="line">      // attributes 属性</span><br><span class="line">      // attributes.getNamedItem(name) 返回nodeName属性等于name的节点</span><br><span class="line">      // attributes.removeNamedItem(name) 从列表中移除nodeName属性等于name的节点</span><br><span class="line">      // attributes.setNamedItem(node) 向列表中添加节点，以节点的nodeName属性为索引</span><br><span class="line">      // attributes.item(pos) 返回位于数字pos位置出的节点</span><br><span class="line">      console.log(dbox.attributes.length);</span><br><span class="line">      // attributes.specified  默认值为false</span><br><span class="line">      console.log(dbox.attributes.specified);</span><br><span class="line">      // 创建元素</span><br><span class="line">      var div = document.createElement(&apos;div&apos;)</span><br><span class="line">      document.getElementById(&apos;box&apos;).appendChild(div);</span><br><span class="line">      // 元素的子节点</span><br><span class="line">      for(var i = 0; i &lt; document.childNodes.length; i++)&#123;</span><br><span class="line">      if(dbox.childNodes[i].nodeType === 1)&#123;</span><br><span class="line">      return true;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // Text类型</span><br><span class="line">      // appendData(text) 将text添加到节点的末尾</span><br><span class="line">      // deleteData(offset, count) 从offset指定位置开始删除count个字符</span><br><span class="line">      // instertData(offset, text) 在offset指定的位置插入text</span><br><span class="line">      // replaceData(offset, count, text) 用text替换从offset指定的位置开始到offset+count为止处的文本</span><br><span class="line">      // splitText(offset) 从offset指定的位置将当前文本节点分成两个文本节点</span><br><span class="line">      // substringData(offset, count) 提取从offset指定的位置开始到offset+count为止出的字符串</span><br><span class="line">      // length属性</span><br><span class="line"></span><br><span class="line">      // 创建文本节点</span><br><span class="line">      document.createTextNode(&apos;文本节点&apos;)</span><br><span class="line">      // 规范化文本节点</span><br><span class="line">      // normalize()</span><br><span class="line">      // 分割文本节点</span><br><span class="line">      // splitText(offset: unsigned long)</span><br><span class="line"></span><br><span class="line">      // Comment类型  CDATASection类型</span><br><span class="line">      // comment类型、CDATASection类型与text类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法。</span><br><span class="line"></span><br><span class="line">      // DocumentType类型</span><br><span class="line">      console.log(document.doctype)</span><br><span class="line">      // DocumentFragment类型</span><br><span class="line">      // document fragment 是一种轻量级文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源。</span><br><span class="line">      // 创建文档片段</span><br><span class="line">      document.createDocumentFragment()</span><br><span class="line"></span><br><span class="line">      // Attr类型</span><br><span class="line">      // Attr对象有三个属性：name, value, specified</span><br><span class="line"></span><br><span class="line">      // Dom操作技术</span><br><span class="line">      // 动态脚本</span><br><span class="line">      var js = document.createElement(&apos;script&apos;);</span><br><span class="line">      js.type = &apos;text/javascript&apos;;</span><br><span class="line">      document.body.appendChild(js);</span><br><span class="line"></span><br><span class="line">      // 动态样式</span><br><span class="line">function loadStyle(url)&#123;</span><br><span class="line">var link = document.createElement(&apos;link&apos;);</span><br><span class="line">link.rel = &apos;stylesheet&apos;;</span><br><span class="line">link.type = &apos;text/css&apos;;</span><br><span class="line">link.href = url;</span><br><span class="line">var head = document.getElementsByTagName(&apos;head&apos;)[0];</span><br><span class="line">head.appendChild(link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadStyle(&quot;style.css&quot;);</span><br><span class="line"></span><br><span class="line">// 操作表格</span><br><span class="line">// &lt;table&gt; 的属性和方法</span><br><span class="line">// caption 保存着对&lt;caption&gt;元素的指针</span><br><span class="line">// tBodies  是一个&lt;tbody&gt;元素的HTMLCollection</span><br><span class="line">// tFoot 保存着对&lt;tfoot&gt;元素的指针</span><br><span class="line">// tHead 保存着对&lt;thead&gt;元素的指针</span><br><span class="line">// rows 是一个表格所有行的HTMLCollection</span><br><span class="line">// createTHead() 创建&lt;thead&gt;元素，将其放到表格中，返回引用</span><br><span class="line">// createTFoot() 创建&lt;tfoot&gt;元素，将其放到表格中，返回引用</span><br><span class="line">// createCaption() 创建&lt;caption&gt;元素，将其放到表格中，返回引用</span><br><span class="line">// deleteTHead() 删除&lt;thead&gt;元素</span><br><span class="line">// deleteTFoot() 删除&lt;tfoot&gt;元素</span><br><span class="line">// deleteCaption() 删除&lt;caption&gt;元素</span><br><span class="line">// deleteRow(pos)  删除指定位置的行</span><br><span class="line">    // insertRow(pos) 向rows集合中指定位置插入一行</span><br><span class="line"></span><br><span class="line">    // &lt;tbody&gt; 的属性和方法</span><br><span class="line">    // rows 保存&lt;tbody&gt;元素中的HTMLCollection</span><br><span class="line">    // deleteRow(pos) 删除指定位置的行</span><br><span class="line">    // insertRow(pos) 向rows集合中指定位置插入一行</span><br><span class="line"></span><br><span class="line">    // &lt;tr&gt; 的属性和方法</span><br><span class="line">    // cells 保存着&lt;tr&gt;元素中单元格的HTMLCollection</span><br><span class="line">    // deleteCell(pos) 删除指定位置的单元格</span><br><span class="line">    // insertCell(pos) 向cells集合中的指定为会插入一个单元格，返回对新插入的单元格的引用</span><br><span class="line"></span><br><span class="line">    // 使用NodeList</span><br><span class="line"></span><br><span class="line">    // querySelector() 方法  接收一个CSS选择符，返回与该模式匹配的第一个元素，没有则返回null</span><br><span class="line">    var body = document.querySelector(&apos;body&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // querySelectorAll() 方法 接收一个CSS选择符，返回与该模式匹配的所有元素，没有则返回null</span><br><span class="line">    var stongs = document.querySelectorAll(&apos;p strong&apos;);</span><br><span class="line"></span><br><span class="line">    // matchesSelector() 方法 接收一个CSS选择符，如果调用元素与该选择符匹配，则返回true，否则，返回false.</span><br><span class="line">    matchesSelector(document.body, &quot;body.page1&quot;)</span><br><span class="line"></span><br><span class="line">    // 元素遍历</span><br><span class="line">    // childElementCount 返回子元素的个数</span><br><span class="line">    // firstElementChild 指向第一个子元素：firstChild的元素版</span><br><span class="line">    // lastElementChild 指向最后一个子元素：lastChild的元素版</span><br><span class="line">    // previousElementSibling  指向前一个同辈元素：previousSibling的元素版</span><br><span class="line">    // nextElementSibling 指向后一个同辈元素：nextSibling的元素版</span><br><span class="line"></span><br><span class="line">    // HTML</span><br><span class="line">    // 与类相关的扩充</span><br><span class="line">    // getElementsByClassName()方法 接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList</span><br><span class="line">    </span><br><span class="line">    // classList属性 这个classList属性是新集合类型DOMTokenList的实例</span><br><span class="line">    // add(value) 将给定的字符串值添加到列表中。如果值已经存在，就不添加了</span><br><span class="line">    // contains(value) 表示列表中是否存在给定的值，返回true/false</span><br><span class="line">    // remove(value) 从列表中删除给定的字符串</span><br><span class="line">    // toggle(value) 如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它</span><br><span class="line"></span><br><span class="line">    // 焦点管理</span><br><span class="line">    // document.activeElement 属性</span><br><span class="line">    // HTML5添加了辅助管理DOM焦点的功能。首先是document.activeElement属性。这个属性始终会引用DOM中当前获得焦点的元素</span><br><span class="line">    // document.hasFocus()方法  确定文档是否获得了焦点</span><br><span class="line"></span><br><span class="line">    // HTMLDocument的变化</span><br><span class="line">    // readyState属性值：loading，正在加载文档 | complete，已经加载完文档</span><br><span class="line">    // 兼容模式 compatMode的属性</span><br><span class="line">    if (document.compatMode === &quot;CSS1Compat&quot;) &#123;</span><br><span class="line">    console.log(&apos;Standards mode&apos;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    console.log(&apos;Quirks mode&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    // head属性 document.head</span><br><span class="line"></span><br><span class="line">    // 字符集属性</span><br><span class="line">    document.charset = &quot;UTF-8&quot;;</span><br><span class="line"></span><br><span class="line">    //自定义数据属性</span><br><span class="line">    // 设置值</span><br><span class="line">    // document.getElementById(&apos;box&apos;).dataset.appId = 123</span><br><span class="line">    // document.getElementById(&apos;box&apos;).dataset.myname = &quot;Michael&quot;</span><br><span class="line"></span><br><span class="line">    // if (document.getElementById(&apos;box&apos;).dataset.myname) &#123;</span><br><span class="line">    // console.log(document.getElementById(&apos;box&apos;).dataset.myname);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // 插入标记</span><br><span class="line">    // div.innerHTML = &quot;&lt;input type=\&quot;hidden\&quot;&gt;&lt;script&gt;alert(&apos;hi&apos;);&lt;\/script&gt;&quot;;</span><br><span class="line"></span><br><span class="line">    // outerHTML属性  </span><br><span class="line">    // 返回调用他的元素及所有子节点的HTML标签</span><br><span class="line">    // div.outerHTML = &quot;&lt;p&gt;This is a paragrph.&lt;/p&gt;&quot;</span><br><span class="line"></span><br><span class="line">    // insertAdjacentHTML()方法</span><br><span class="line">    // beforebegin 在当前元素之前插入一个紧邻的同辈元素</span><br><span class="line">    // element.insertAdjacentHTML(&quot;beforebegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);</span><br><span class="line">    // afterbegin 在当前元素之下插入一个新的子元素火灾第一个子元素之前再插入新的子元素</span><br><span class="line">    // element.insertAdjacentHTML(&quot;afterbegin&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);</span><br><span class="line">    // beforeend 在当前元素之下插入新的子元素或最后一个子元素之后再插入新的子元素</span><br><span class="line">    // element.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);</span><br><span class="line">    // afterend 在当前元素之后插入一个紧邻的同辈元素</span><br><span class="line">    // element.insertAdjacentHTML(&quot;afterend&quot;, &quot;&lt;p&gt;Hello world!&lt;/p&gt;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 内存和性能问题</span><br><span class="line">    // 在替换子节点可能会导致浏览器的内存占用问题。在使用innerHTML、outerHTML、insertAdjacentHTML方法时，最好手工删除要被替换的元素的所有回见处理程序和JavaScript对象属性。</span><br><span class="line"></span><br><span class="line">    // scrollIntoView()方法</span><br><span class="line">    // 可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在视口中。</span><br><span class="line">    // 传入true作为参数，或者不传入任何参数时，串口滚动之后会让调用元素的顶部与视口尽可能平齐</span><br><span class="line">    // 传入false作为参数，调用元素会尽可能全部出现在视口中，（可能的话，调用元素的底部会与视口顶部平齐。）不过顶部不一定平齐</span><br><span class="line"></span><br><span class="line">    // 让元素可见</span><br><span class="line">    // document.forms[0].scrollIntoView();</span><br><span class="line"></span><br><span class="line">    // 文档模式</span><br><span class="line">    // &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content = &apos;IE=IEVersion&apos;&gt;</span><br><span class="line">    // IEVersion：</span><br><span class="line">    // Edge：始终以最新的文档模式来渲染页面。忽略文档类型声明。</span><br><span class="line">    // EmulateIE9：如果有文档类型声明，则以IE9标准模式渲染页面，否则将文档模式设置为IE5。</span><br><span class="line">    // EmulateIE8：如果有文档类型声明，则以IE8标准模式渲染页面，否则将文档模式设置为IE5。</span><br><span class="line">    // EmulateIE7：如果有文档类型声明，则以IE7标准模式渲染页面，否则将文档模式设置为IE5。</span><br><span class="line">    // 9：强制以IE9标准模式渲染页面，忽略文档类型声明。</span><br><span class="line">    // 8：强制以IE8标准模式渲染页面，忽略文档类型声明。</span><br><span class="line">    // 7：强制以IE7标准模式渲染页面，忽略文档类型声明。</span><br><span class="line">    // 5：强制以IE5标准模式渲染页面，忽略文档类型声明。</span><br><span class="line"></span><br><span class="line">    // children属性 只包含元素中同样还是元素的子节点</span><br><span class="line">    // var childCount = element.children.length;</span><br><span class="line"></span><br><span class="line">    // contains()方法</span><br><span class="line">    // 调用contains()方法的应该是祖先节点，也就是搜索开始的节点，这个方法接收一个参数，即要检查的后代节点。返回值 true/false</span><br><span class="line">    // document.documentElement.contains(document.body);</span><br><span class="line"></span><br><span class="line">    // 插入文本</span><br><span class="line">    </span><br><span class="line">    // innerText 属性  可以操作元素中包含的所有文本内容，包括子文档树中的文本。</span><br><span class="line">    // div.innerText = &quot;Hello world!&quot;</span><br><span class="line"></span><br><span class="line">    // outerText 属性 读取文本内容</span><br><span class="line">    // console.log(div.outerText)</span><br><span class="line"></span><br><span class="line">    // 滚动</span><br><span class="line">    // scrollIntoViewIfNeeded() 只在当前元素在视口中不可见的情况下，才滚动浏览器窗口或容器元素，最终让它可见。</span><br><span class="line">    // scrollByLines() 将元素的内容滚动指定的行高</span><br><span class="line">    // scrollByPages() 将元素的内容滚动指定的页面高度，具体高度由元素的高度决定。</span><br><span class="line">    // document.body.scrollIntoViewIfNeeded(true)</span><br><span class="line">    // 将页面主体滚动5行</span><br><span class="line">    // document.body.scrollByLines(5)</span><br><span class="line">    // 将页面主体滚动1页</span><br><span class="line">    // document.body.scrollByPages(-1)</span><br><span class="line">    &#125;)();</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 数组</title>
    <link href="https://liushuai97.github.io/2019/09/16/JavaScript-%E6%95%B0%E7%BB%84/"/>
    <id>https://liushuai97.github.io/2019/09/16/JavaScript-数组/</id>
    <published>2019-09-16T01:57:08.000Z</published>
    <updated>2019-09-16T01:57:48.773Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">// 立即执行函数</span><br><span class="line">(function () &#123;</span><br><span class="line">  // 严格模式</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  var arr = [1, 3, 5, 3, 21, 5];</span><br><span class="line"></span><br><span class="line">  if (typeof (arr)) &#123;</span><br><span class="line">    console.log(&apos;此数据类型为对象&apos;);</span><br><span class="line">    // 检测数组  isArray返回 true or false</span><br><span class="line">    if (Array.isArray(arr)) &#123;</span><br><span class="line">      console.log(&apos;此对象为数组对象&apos;);</span><br><span class="line">      // 数组的转化</span><br><span class="line">      console.log(arr.toString());</span><br><span class="line"></span><br><span class="line">      var list = new Array();</span><br><span class="line"></span><br><span class="line">      // 栈方法：LIFO(后进先出)</span><br><span class="line">      list.push(&apos;张三&apos;, &apos;李四&apos;, &apos;王五&apos;);</span><br><span class="line">      console.log(list);</span><br><span class="line">      console.log(list.pop());</span><br><span class="line">      console.log(list);</span><br><span class="line"></span><br><span class="line">      // 队列方法：FIFO(先进先出)</span><br><span class="line">      list.unshift(&apos;陈六&apos;, &apos;赵七&apos;);</span><br><span class="line">      console.log(list);</span><br><span class="line">      console.log(list.shift());</span><br><span class="line">      console.log(list);</span><br><span class="line"></span><br><span class="line">      // 数组重排</span><br><span class="line">      list.reverse();</span><br><span class="line">      console.log(list);</span><br><span class="line">      // 升序排序</span><br><span class="line">      list.sort();</span><br><span class="line">      console.log(list);</span><br><span class="line"></span><br><span class="line">      // 操作方法</span><br><span class="line">      console.log(list.concat(&apos;钱八&apos;, [&apos;豆豆&apos;, &apos;豆花&apos;]));</span><br><span class="line">      console.log(list.slice(1, 4));</span><br><span class="line"></span><br><span class="line">      console.log(list);</span><br><span class="line">      // 删除</span><br><span class="line">      console.log(list.splice(0, 1));</span><br><span class="line">      console.log(list);</span><br><span class="line">      // 插入</span><br><span class="line">      console.log(list.splice(0, 0, &apos;花花&apos;, &apos;毛毛&apos;));</span><br><span class="line">      console.log(list);</span><br><span class="line">      // 替换</span><br><span class="line">      console.log(list.splice(2, 1, &apos;二狗子&apos;, &apos;铁头&apos;));</span><br><span class="line">      console.log(list);</span><br><span class="line"></span><br><span class="line">      // 位置方法</span><br><span class="line">      console.log(list.indexOf(&quot;二狗子&quot;));</span><br><span class="line">      console.log(list.lastIndexOf(&quot;铁头&quot;));</span><br><span class="line"></span><br><span class="line">      // 迭代方法</span><br><span class="line">      // every()  对数组中的每一项给定函数，若该函数都返回true，则返回true</span><br><span class="line">      console.log(list.every(function (item, index, arry) &#123;</span><br><span class="line">        return typeof (item) === &apos;string&apos;;</span><br><span class="line">      &#125;));</span><br><span class="line"></span><br><span class="line">      /**************************/</span><br><span class="line">      list.push(1, 4, 5, 7, 21, 100);</span><br><span class="line">      console.log(list);</span><br><span class="line">      /**************************/</span><br><span class="line"></span><br><span class="line">      // some()   对数组中的每一项给定函数，若该函数有一项返回true，则返回true</span><br><span class="line">      console.log(list.some(function (item, index, arry) &#123;</span><br><span class="line">        return typeof (item) === &apos;string&apos;;</span><br><span class="line">      &#125;));</span><br><span class="line"></span><br><span class="line">      // filter() 对数组中的每一项给定函数，返回该函数返回true的项组成新的数组</span><br><span class="line">      console.log(list.filter(function (item, index, arry) &#123;</span><br><span class="line">        return item === &apos;二狗子&apos;;</span><br><span class="line">      &#125;));</span><br><span class="line"></span><br><span class="line">      // forEach() 对数组中的每一项给定函数。这个方法没有返回值</span><br><span class="line">      console.log(list.forEach(function (item, index, arry) &#123;</span><br><span class="line">        console.log(item);</span><br><span class="line">      &#125;));</span><br><span class="line"></span><br><span class="line">      // map() 对数组中的每一项给定函数，返回每次函数调用的结果组成的数组</span><br><span class="line">      console.log(list.map(function (item, index, arry) &#123;</span><br><span class="line">        return item &gt; 0;</span><br><span class="line">      &#125;));</span><br><span class="line"></span><br><span class="line">      // 缩小方法</span><br><span class="line">      // reduce() 从第一项向后叠加</span><br><span class="line">      console.log(list.reduce(function (prev, cur, index, array) &#123;</span><br><span class="line">        return prev + cur;</span><br><span class="line">      &#125;))</span><br><span class="line"></span><br><span class="line">      // reduceRight 从最后一项向第一项叠加</span><br><span class="line">      console.log(list.reduceRight(function (prev, cur, index, array) &#123;</span><br><span class="line">        return prev + cur;</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // console.log(typeof(arr))</span><br><span class="line">    console.log(&apos;数据类型非数组&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 数据基本类型：null undefined number string object boolean</span><br><span class="line">  // 从这里我们可以看出typeof验证数据的返回类型：undefined、boolean、string、number、object、function</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES5 核心</title>
    <link href="https://liushuai97.github.io/2019/09/11/ES5-%E6%A0%B8%E5%BF%83/"/>
    <id>https://liushuai97.github.io/2019/09/11/ES5-核心/</id>
    <published>2019-09-11T07:22:54.000Z</published>
    <updated>2019-09-15T05:44:17.658Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>在 JavaScript 中, 作用域（scope，或译有效范围）就是变量和函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。在ES5中没有块级作用域的概念。</p><ul><li>全局作用域（Global Scope）：最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的。</li><li>局部作用域（Local Scope）：和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部。</li><li>如果局部作用域的“预解析空间”（AO-活动对象（Active object））没有找到，那么代码会从上一级的作用域寻找，上级作用域不能在下级作用域寻找。</li></ul><p>注意事项：</p><ol><li>需要注意的是，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！</li><li>只要函数内定义了一个局部变量，函数在解析的时候都会将这个变量“提前声明”</li></ol><h4 id="作用域链（Scope-Chain）"><a href="#作用域链（Scope-Chain）" class="headerlink" title="作用域链（Scope Chain）"></a>作用域链（Scope Chain）</h4><p>通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。当执行函数时，总是先从函数内部找寻局部变量；如果内部找不到（函数的局部作用域没有），则会向创建函数的作用域（声明函数的作用域）寻找，依次向上。</p><ul><li>执行环境（execution context）：JavaScript为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。</li></ul><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ol><li>可以读取自身函数外部的变量（沿着作用域链寻找）</li><li>让这些外部变量始终保存在内存中</li></ol><p>js函数内的变量值不是在编译的时候就确定的，而是等在运行时期再去寻找的。</p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ol><li>必须有外部的封闭函数，该函数至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改其他私有的状态。</li></ol><p>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p><h4 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h4><p>“谁调用指向谁”</p><p>this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象调用时，this等于那个对象。不过，匿名函数具有全局性，因此this对象同常指向window。</p><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><ol><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li><li>消除代码运行的一些不安全之处，保证代码运行的安全</li><li>为未来新版本的Javascript做好铺垫</li></ol><p>在使用严格模式的时候在全局或函数的第一条语句需定义为: ‘use strict’; 如果浏览器不支持, 只解析为一条简单的语句, 没有任何副作用</p><p>主要内容：</p><ol><li>必须用var声明变量（混杂模式中可以直接使用变量而不定义，但是这种做法会对后期造成很大的麻烦）</li><li>创建eval作用域</li><li>禁止this指向window</li><li>对象不能用重名的属性</li><li>函数不能有重名的形参</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;; //在全局或函数内第一行书写</span><br><span class="line">//1.变量必须使用var 定义 否则报错</span><br><span class="line">str=&quot;xxx&quot;;</span><br><span class="line">//2.函数内的this指向不再是window</span><br><span class="line">function Person(name,age) &#123;</span><br><span class="line">        console.log(this);//undefined</span><br><span class="line">        this.name=name;//相当于设置undefined.name =name 报错</span><br><span class="line">        this.age=age;</span><br><span class="line"> &#125;</span><br><span class="line">//3.让eval有自己的作用域</span><br><span class="line"> var str =123;</span><br><span class="line"> eval(&apos;var str=456;alert(str)&apos;);//456</span><br><span class="line"> alert(str);//123</span><br><span class="line">//4.对象不能用重名属性</span><br><span class="line">var obj =&#123;</span><br><span class="line">        username:&apos;kobe&apos;,</span><br><span class="line">        username:&apos;zs&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(obj);//运行时没有报错,不过编辑器内有提示 最好别这么写就是了</span><br></pre></td></tr></table></figure><h4 id="json对象"><a href="#json对象" class="headerlink" title="json对象"></a>json对象</h4><p>JSON.stringify(obj/arr)js对象（数组）转换为json对象（数组）<br>JSON.parse(json)json对象（数组）转换为js对象（数组）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;username:&quot;mike&quot;&#125;;</span><br><span class="line">obj=JSON.stringify(obj);</span><br><span class="line">console.log(typeof obj);</span><br><span class="line">//json对象和数组，不要说json字符串</span><br><span class="line">//json是一种传输数据的格式，还有xml。</span><br></pre></td></tr></table></figure><h4 id="object对象方法扩展"><a href="#object对象方法扩展" class="headerlink" title="object对象方法扩展"></a>object对象方法扩展</h4><p>ES5给Object扩展了好一些静态方法, 常用的2个:</p><ul><li>Object.create(prototype[, descriptors]) : 创建一个新的对象</li></ul><ol><li>以指定对象（prototype）为原型创建新的对象</li><li>指定新的属性, 并对属性进行描述<br>value : 指定值<br>writable : 标识当前属性值是否是可修改的, 默认为true<br>get : 用来得到当前属性值的回调函数<br>set : 用来监视当前属性值变化的回调函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;username:&quot;damu&quot;,age:30&#125;;</span><br><span class="line">var obj1=&#123;&#125;;</span><br><span class="line">obj1=Object.create(obj); //Object是obj1上一级的构造函数，调用他所具有的函数creat</span><br><span class="line">console.log(obj1); //也就是obj1可以继承obj的属性username和age</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;username:&quot;damu&quot;,age:30&#125;;</span><br><span class="line">var obj1=&#123;&#125;;</span><br><span class="line">obj1=Object.create(obj,&#123;</span><br><span class="line">sex:&#123;</span><br><span class="line">        value:&quot;男&quot;,</span><br><span class="line">        writable:true,//有一个writable属性：标识当前属性值是否是可以修改的，默认为false</span><br><span class="line">        configurable:true,//有一个属性configurable：标识当前属性是否可以被删除</span><br><span class="line">        enumerable:true  //有一个属性enumerable：标识当前属性是否能用for in枚举 默认为false</span><br><span class="line">&#125;</span><br><span class="line">&#125; //对当前扩展属性的描述</span><br><span class="line">&#125;); //使用create给obj1添加扩展属性</span><br><span class="line">console.log(obj1.sex);</span><br><span class="line">obj1.sex=&quot;女&quot;</span><br><span class="line">console.log(obj1.sex);</span><br><span class="line">delete obj1.sex;//规定不能直接删掉，有一个属性configurable：标识当前属性是否可以被删除，默认为false</span><br><span class="line">console.log(obj1.sex);</span><br><span class="line">for(var i in obj1)&#123;</span><br><span class="line">console.log(i)//for in 找不到obj1使用create扩展出来的属性</span><br><span class="line">//有一个属性enumerable：标识当前属性是否能用for in枚举 默认为false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object.defineProperties(object,descriptors)<br>作用：为指定object对象定义扩展多个属性<br>get：用来获取当前属性值的回调函数<br>set：修改当前属性值的触发的回调函数，并且实参即为修改后的值<br>存取器属性：setter，getter一个用来存值一个用来取值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">var obj2=&#123;firstName:&quot;kobe&quot;,lastName:&quot;bryant&quot;&#125;;</span><br><span class="line">Object.defineProperties(obj2,&#123;</span><br><span class="line">fullName:&#123;</span><br><span class="line">        get:function () &#123;//使用get来获取扩展属性的值</span><br><span class="line">        return this.firstName+&quot; &quot;+this.lastName//fullName想要设置的值</span><br><span class="line">        &#125;,</span><br><span class="line">        set:function (data) &#123;//监听扩展属性，当扩展属性发生变化时自动调用后会将变化的值作为实参注入到set函数。</span><br><span class="line">        console.log(&quot;set()&quot;,data);</span><br><span class="line">        var names=data.split(&quot; &quot;);</span><br><span class="line">        this.firstName=names[0];</span><br><span class="line">        this.lastName=names[1];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;//创建一个配置对象</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(obj2.fullName)</span><br><span class="line">obj2.fullName=&quot;haha heih&quot;;</span><br><span class="line">console.log(obj2.fullName)</span><br><span class="line">//get方法什么时候调用？ 获取扩展属性值的时候，get方法自动调用</span><br><span class="line"></span><br><span class="line">//对象本身的两个方法：</span><br><span class="line">//get propertyName()&#123;&#125;</span><br><span class="line">//set propertyName()&#123;&#125;</span><br><span class="line"></span><br><span class="line">var objj=&#123;</span><br><span class="line">age:15,</span><br><span class="line">tall:180,</span><br><span class="line">get all()&#123;</span><br><span class="line">        return this.age+&quot; &quot;+this.tall;</span><br><span class="line">&#125;,</span><br><span class="line">set all(data)&#123;</span><br><span class="line">        console.log(&quot;set()&quot;,data);</span><br><span class="line">        var names=data.split(&quot; &quot;);</span><br><span class="line">        this.age=names[0];</span><br><span class="line">        this.tall=names[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">console.log(objj);</span><br><span class="line">objj.all=&quot;13 189&quot;;</span><br><span class="line">console.log(objj);</span><br></pre></td></tr></table></figure><h4 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h4><ol><li>Array.prototype.indexOf(value):得到值在数组中的第一个下标,输入第一个3的下标</li><li>Array.prototype.lastIndexOf(value):得到值在数组中的最后一个下标</li><li>Array.prototype.forEach(function(item,index){}):遍历数组</li><li>Array.prototype.map(function(item,index){}):遍历数组返回一个新的数组，返回加工之后的值</li><li>Array.prototype.filter(function(item,index){}):遍历过滤出一个新的子数组，返回条件为true的值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr=[2,3,5,1,4,6,3];</span><br><span class="line">console.log(arr.indexOf(3));//输出第一个6的下标</span><br><span class="line">console.log(arr.lastIndexOf(3)); //输出最后一个6的下标</span><br><span class="line"></span><br><span class="line">arr.forEach(function(item,index)&#123;</span><br><span class="line">        console.log(item+&quot; &quot;+index)//输出所有元素的值和下标</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var arr1=arr.map(function(item,index)&#123;</span><br><span class="line">        return item+10;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr1);//根据arr产生一个新数组，要求每个元素比原来大10</span><br><span class="line"></span><br><span class="line">var arr2=arr.filter(function(item,index)&#123;</span><br><span class="line">        return item &gt; 4; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(arr2);//根据arr产生一个新数组，返回的每个元素都要大于4</span><br></pre></td></tr></table></figure><h4 id="bind-、call-、apply-的区别"><a href="#bind-、call-、apply-的区别" class="headerlink" title="bind()、call()、apply()的区别"></a>bind()、call()、apply()的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;username:&quot;kobe&quot;&#125;;</span><br><span class="line">function foo(data)&#123;</span><br><span class="line">        console.log(this,data)</span><br><span class="line">&#125;</span><br><span class="line">// foo();</span><br><span class="line">//自调用时this指向的是window，使this指向我们定义的obj</span><br><span class="line">foo.call(obj);</span><br><span class="line">foo.apply(obj);</span><br><span class="line">//call和apply在不传参的情况下使用方式是一样的</span><br><span class="line"></span><br><span class="line">//区别</span><br><span class="line">function foo(data)&#123;</span><br><span class="line">        console.log(this,data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.call(obj,33); //直接传入参数</span><br><span class="line">foo.apply(obj,[33]); //传入数据必须写在数组里</span><br><span class="line"></span><br><span class="line">//bind</span><br><span class="line"></span><br><span class="line">var bar=foo.bind(obj,33);//绑定完this有一个返回值，不会立即调用当前函数而是将函数返回,通常用来指定回调函数的this。用bar来接收返回的函数然后执行</span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">// 也可写成foo.bind(obj,33)()</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h4&gt;&lt;p&gt;在
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 代码约定</title>
    <link href="https://liushuai97.github.io/2019/09/11/JavaScript-%E4%BB%A3%E7%A0%81%E7%BA%A6%E5%AE%9A/"/>
    <id>https://liushuai97.github.io/2019/09/11/JavaScript-代码约定/</id>
    <published>2019-09-11T06:28:32.000Z</published>
    <updated>2019-09-11T07:17:38.655Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h4><ul><li>可理解性</li><li>直观性</li><li>可适应性</li><li>可扩展性</li><li>可调试性</li></ul><h4 id="代码约定"><a href="#代码约定" class="headerlink" title="代码约定"></a>代码约定</h4><ul><li><p>函数和方法：每个函数或方法都应该包含一个注释，描述其目的和用于完成任务所可能使用的算法。陈述实现的假设也非常重要，汝参数代表什么，函数是否有返回值（因为这个不能从函数定中推断出来）。</p></li><li><p>大段代码：用于完成单个任务的多行代码应该再前面放一个描述任务的注释。</p></li><li><p>复杂的算法：如果使用了一种独特的方式解决某个问题，则要在主时钟解释你是如何做的。这不仅仅可以帮助其他浏览你代码的人，也能在你自己查阅代码的时候帮助理解。</p></li><li><p>Hack：因为存在浏览器差异，JavaScript代码一般会包含一些Hack。不要假设其他人在看代码的时候能够理解Hack索要应付的浏览器问题，如果因为其他浏览器无法使用普通的方法，所以扭腰用一些不同的方法，那么请假这些信息放在注释中。这样可以减少出现这种情况的可能性：有人偶然看到你的hack,然后“修正”了它，最后重新引入了你本来修正了的错误。缩进和注释可以带来更可读的代码，未来则更容易维护。</p></li><li><p>变量名应该为名词如：car或person</p></li><li><p>函数名应该以动词开始，如getName()。返回布尔类型值得函数一般以is开头，如：isEnable（）。</p></li><li><p>变量和函数都应使用呵护逻辑的名字，不要担心长度。长度问题可以通过后处理和压缩来缓解。</p></li><li><p>变量类型透明</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 用于指定数据类型的匈牙利标记法</span><br><span class="line"></span><br><span class="line">var bFound;   // 布尔型</span><br><span class="line">var iCount;   // 整数</span><br><span class="line">var sName;    // 字符串</span><br><span class="line">var oPerson;  // 对象</span><br></pre></td></tr></table></figure><h4 id="松散耦合"><a href="#松散耦合" class="headerlink" title="松散耦合"></a>松散耦合</h4><ol><li>解耦HTML/JavaScript</li></ol><p>在Web上，HTML和JavaScript各自代表了解决方案中的不同层次：HTML是数据，JavaScript是行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用了&lt;script&gt;的紧密耦合 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  docment.write(&quot;hello world&quot;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用时间处理程序属性值的紧密耦合的HTML/JavaScript --&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; value=&quot;click me&quot; onclilck=&quot;doSomething()&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将HTML紧密耦合到JavaScript</span><br><span class="line">function insetMessage(msg)&#123;</span><br><span class="line">  var container = docment.getElementById(&quot;container&quot;);</span><br><span class="line">  container.innerHTML = &quot;&lt;div&gt;&lt;p&gt;hello world&lt;/p&gt;&lt;/div&gt;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>解耦CSS/JavaScript</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// CSS对JavaScript的紧密耦合</span><br><span class="line">element.style.color = &quot;red&quot;;</span><br><span class="line">element.style.backgroundColor = &quot;blue&quot;;</span><br><span class="line"></span><br><span class="line">// CSS对JavaScript的松散耦合</span><br><span class="line">element.className = &quot;edit&quot;</span><br><span class="line"></span><br><span class="line">//JavaScript对CSS的紧密耦合</span><br><span class="line">div&#123;</span><br><span class="line">  width: exprerssion(docment.body.offsetWidth - 10 + &quot;px&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>解耦应用逻辑/事件处理程序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function handleKeyPress(event)&#123;</span><br><span class="line">  event = EventUtil.getEvent(event);</span><br><span class="line">  if(event.keyCode == 13)&#123;</span><br><span class="line">    var target = EventUtil/getTarget(event);</span><br><span class="line">    var value = 5 * parseInt(target.value);</span><br><span class="line">    if(value &gt; 10)&#123;</span><br><span class="line">      docment.getElementById(&quot;error-msg&quot;).style.display = &quot;block&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尊重对象所有权"><a href="#尊重对象所有权" class="headerlink" title="尊重对象所有权"></a>尊重对象所有权</h4><ul><li><p>不要为实例或原型添加属性</p></li><li><p>不要为实例或原型添加方法</p></li><li><p>不要冲定义已存在的方法</p></li><li><p>创建包含所需功能的新对象，并用它与相关对象进行交互</p></li><li><p>创建自定义类型，继承需要进行修改的类型。然后可以为定义类型添加额外功能。</p></li></ul><ol><li>避免全局量</li><li>避免与null进行比较</li><li>使用常量</li></ol><p>重复值：任何在多出用到的值都应该抽取为一个常量。<br>用户界面字符串：任何用于显示给用户的字符串，都应该抽取出来以便国际化。<br>URLs：在Web应用中，资源位置很容易变更，所以推荐使用一个公共地方存放所有的URL。<br>任意可能会更改的值：每当你再拥戴字面量值得时候，你都要问一下自己这个值字啊未来是不是会变化。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ol><li>作用域</li></ol><ul><li>避免全局查找</li><li>避免with语句</li></ul><ol start="2"><li>选择正确方法</li></ol><ul><li>避免不必要的属性查找</li><li>优化循环：减值迭代、简化终止条件、简化循环体、使用后测试循环</li><li>展开循环</li></ul><ol start="3"><li>避免双重解释</li><li>性能的其他注意事项：原生方法比较快、switch语句比较快、位运算比较快</li></ol><h4 id="最小化语句数"><a href="#最小化语句数" class="headerlink" title="最小化语句数"></a>最小化语句数</h4><ol><li>多个变量声明</li><li>插入迭代值</li><li>使用数组和对象字面量</li></ol><h4 id="优化DOM交互"><a href="#优化DOM交互" class="headerlink" title="优化DOM交互"></a>优化DOM交互</h4><ol><li>最小化现场更新</li><li>使用innerHTML</li><li>使用事件代理</li><li>注意HTMLCollection</li></ol><h4 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h4><ul><li>知识产权问题：若果吧带有完整注释的代码放到线上，那别人就跟容易知道你的以图，对它再利用，并且可能找到安全漏洞。</li><li>文件大小：书写代码要保证容易阅读，才能更好地维护，但是这对于性能是不利的。浏览器不能从额外的空白字符或者是冗长的函数名和变量名中获得什么好处。</li><li>代码组织：组织代码要考虑到可维护性并不一定是传送给浏览器的最好方式。</li></ul><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul><li>eval()的使用</li><li>未声明变量的使用</li><li>遗漏的分号</li><li>不恰当的换行</li><li>错误的逗号使用</li><li>语句周围遗漏的括号</li><li>switch分支语句中遗漏的break</li><li>重复声明的变量</li><li>with的使用</li><li>错误使用的等号（替代了双等号或三等号）</li><li>无法到达的代码</li></ul><h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><ol><li>文件压缩</li></ol><ul><li>删除额外的空白（包括换行）</li><li>删除所有注释</li><li>缩短变量名</li></ul><ol start="2"><li>HTTP压缩</li></ol><p>不过现在基本都是用ESlint语法检测工具、webpack压缩打包了</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;可维护性&quot;&gt;&lt;a href=&quot;#可维护性&quot; class=&quot;headerlink&quot; title=&quot;可维护性&quot;&gt;&lt;/a&gt;可维护性&lt;/h4&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 离线与存储</title>
    <link href="https://liushuai97.github.io/2019/09/10/JavaScript-%E7%A6%BB%E7%BA%BF%E4%B8%8E%E5%AD%98%E5%82%A8/"/>
    <id>https://liushuai97.github.io/2019/09/10/JavaScript-离线与存储/</id>
    <published>2019-09-10T07:48:27.000Z</published>
    <updated>2019-09-11T06:25:22.596Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a>离线检测</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// navigator.online属性</span><br><span class="line">if (navigator.online)&#123;</span><br><span class="line">  // 正常工作</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 执行离线状态时的任务</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// online offline事件</span><br><span class="line">EventUtil.addHandler(window, &quot;online&quot;, function()&#123;</span><br><span class="line">  alert(&quot;Online&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">EventUtil.addHandler(window, &quot;offline&quot;, function()&#123;</span><br><span class="line">  alert(&quot;Offline&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h4><p>applicationCache对象，status属性：</p><ul><li>0：无缓存，即没有与页面相关的应用缓存；</li><li>1：闲置，即应用缓存未得到更新；</li><li>2：检查中，即正在下载描述文件并检查更新；</li><li>3：下载中，即应用缓存正在下载描述文件中指定的资源；</li><li>4：更新完成，即应用缓存已经更新了资源，而且所有资源都已下载完毕，可以通过swapCache()来使用了；</li><li>5：废弃：即应用缓存的描述文件已经不存在，因此页面无法在访问应用缓存；</li></ul><p>事件：</p><ul><li>checking：在浏览器为应用缓存查找更新时触发；</li><li>error：在检查更新或下载资源期间发生错误时触发；</li><li>noupdate：在检查妙手文件发现文件无变化时触发；</li><li>downloading：在开始下载应用缓存资源时触发；</li><li>progress：在文件下载应用缓存的过程中持续不断地触发；</li><li>updateready：在页面新的应用缓存下载完毕并且可以通过swapCache()使用时触发；</li><li>cached: 在应用缓存完整可用时触发</li></ul><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>HTTP Cookie，通常直接叫做Cookie，最初是在客户端用于存储回话信息的。该标准要求服务器对任意HTTP请求发送Set-Cookie HTTP头座位响应的一部分，其中包含回话信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-TYpe: text/html</span><br><span class="line">Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com</span><br><span class="line">Other-header: other-header-value</span><br></pre></td></tr></table></figure><ol><li>限制</li></ol><p>cookie在性质上是绑定在特定的域名下的。当设定一个cookie后，再给创建它的域名发送请求时，都会包含这个cookie。</p><ol start="2"><li>cookie的构成</li></ol><p>名称/值/域/路径/失效时间/安全标志</p><ol start="3"><li>子cookie</li></ol><p>绕开浏览器的单域名下的cookie数量限制，子cookie是存放在单个cookie中的更小段数据。也就是cookie值来存储多个键值对。</p><p><code>name=name1=value1 &amp; name2=value2 &amp; name3=value3 &amp; name4=value4 &amp; name5=value5</code></p><p>子cookie一般也以查询字符串的格式进行格式化。然后这些值可以使用单个cookie进行存储和访问，而非每个键值对使用不同的cookie存储。</p><h4 id="IE用户数据"><a href="#IE用户数据" class="headerlink" title="IE用户数据"></a>IE用户数据</h4><p>在IE5.0中，微软通过一个自定义行为引入了持久化用户数据的概念。永辉数据允许每个文档最多128kb数据，每个域名最多1MB数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var dataStor = document.getElementById(&quot;dataStore&quot;);</span><br><span class="line">dataStore.setAttribute(&quot;name&quot;, &quot;张三&quot;);</span><br><span class="line">dateStore.setAttribute(&quot;book&quot;, &quot;书名&quot;);</span><br><span class="line">dataStore.save(&quot;BookInfo&quot;);</span><br><span class="line">dataStore.load(&quot;BookInfo&quot;);</span><br><span class="line"></span><br><span class="line">dataStore.getAttribute(&quot;name&quot;);</span><br></pre></td></tr></table></figure><h4 id="Web存储机制"><a href="#Web存储机制" class="headerlink" title="Web存储机制"></a>Web存储机制</h4><p>Web Storage 最早是在web超文本应用技术工作组(WHAT-WG)的Web应用1.0规范中描述的。这个规范最初的工作最终成为了HTML5的一部分。主要目标有两个：</p><ul><li>提供一种在cookie之外存储回话数据的途径；</li><li>提供一种存储大量可以跨回话存在的数据的机制。</li></ul><p>最初的Web Storage规范包含了两种对象的定义：sessionStorage和globalStorage。这两个对象在支持的浏览器中是以windows对象属性的形式存在的。</p><ol><li>Storage类型</li></ol><p>clear(): 删除所有值<br>getItem(name): 根据指定的名字那么获取对象的值<br>key(index): 获得index位置处的值得名字<br>removeItem(name): 喊出有那么指定名值对<br>setItem(name,value):为指定的名值对设置一个对应的值。</p><ol start="2"><li>sessionStorage</li></ol><p>seeionStorage对象存储特定于某个回话的数据，也就是该数据只保持浏览器关闭。这个对象就像回话cookie，也会在浏览器关闭后消失。</p><ol start="3"><li>globalStorage对象</li></ol><p>具备同源策略限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 保存数据</span><br><span class="line">globalStorage[&quot;wrox.com&quot;].name = &quot;张三&quot;;</span><br><span class="line">// 获取数据</span><br><span class="line">var name = globalStorage[&quot;wrox.com&quot;].name;</span><br></pre></td></tr></table></figure><ol start="4"><li>localStorage对象</li></ol><p>localStorage对象在修订过的HTML5规范中作为持久保存客户端数据的方案取代了globalStorage。与globalStorage不同，不能给localStorage指定任何访问规则，规则事先就设定好了。要访问一个localStorage对象，页面必须来自同一个域名(子域名无效)，使用同一种协议，在同一个端口上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用方法存储数据</span><br><span class="line">localStorage.setItem(&quot;name&quot;,&quot;张安&quot;);</span><br><span class="line">// 使用属性存储数据</span><br><span class="line">localStorage.book = &quot;book&quot;;</span><br><span class="line">// 使用方法读取数据</span><br><span class="line">var name = localStorage.getItem(&quot;name&quot;);</span><br><span class="line">// 使用属性读取数据</span><br><span class="line">var book = localStorage.book;</span><br></pre></td></tr></table></figure><p>存储在localStorage中的数据和存储globalStorage中的数据一样，都遵循相同的规则：数据保留到通过JavaScript删除或者用户清楚浏览器缓存。</p><ol start="5"><li>Storage事件</li></ol><ul><li>domain: 发生变化的存储空间域名；</li><li>key:设备或删除的域名;</li><li>newValue：如果是设置值，则是更新，如果是删除，则是null。</li><li>oldValue: 键被更改之前的值</li></ul><ol start="6"><li>限制</li></ol><p>大多数桌面浏览器设置每个来源5MB的限制。Chrome和Safari对每个来源的限制是2.5MB。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;离线检测&quot;&gt;&lt;a href=&quot;#离线检测&quot; class=&quot;headerlink&quot; title=&quot;离线检测&quot;&gt;&lt;/a&gt;离线检测&lt;/h4&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 跨域技术</title>
    <link href="https://liushuai97.github.io/2019/09/10/JavaScript-%E8%B7%A8%E5%9F%9F%E6%8A%80%E6%9C%AF/"/>
    <id>https://liushuai97.github.io/2019/09/10/JavaScript-跨域技术/</id>
    <published>2019-09-10T02:53:38.000Z</published>
    <updated>2019-09-10T07:47:54.986Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><p>在CORS出现之前，要实现跨域Ajax通信颇费一些周折。开发人员想出了一些办法，利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求。虽然CORS技术已经无处不在，但开发人员自己发明的这些技术仍然被广泛使用，毕竟这样不需要修改服务器端代码。</p><h4 id="图像Ping"><a href="#图像Ping" class="headerlink" title="图像Ping"></a>图像Ping</h4><p><code>&lt;img&gt;</code>标签，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。可以动态的创建图像，使用他们的onload和onerror事件处理程序来确定是否接受到了响应。</p><p>动态创建图像经常用于图像Ping。图像Ping是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或204响应。通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.onload = img.onerror = function()&#123;</span><br><span class="line">  alert(&quot;Done!&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = &quot;url&quot;;</span><br></pre></td></tr></table></figure><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP是JSON with padding（填充式JSON或参数JSON）的简写，是应用JSON的一种新方法，在后来的Web服务中非常流行。JSONP看起来与JSON差不多，只不过是被包含在函数调用中的JSON，就像下面这样。</p><p><code>callback({&quot;name&quot;:&quot;张飒&quot;});</code></p><p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的JSON数据。</p><p><code>http://freegeoip.net/json/?callback=handleResponse</code></p><p>这个URL是在请求一个JSONP地理定位服务。通过查询字符串来指定JSONP服务的回调参数是很常见的。JSONP是通过动态<code>&lt;script&gt;</code>元素来使用的，使用时可以为src属性指定一个跨域RUL。这里的<code>&lt;script&gt;</code>元素与<code>&lt;img&gt;</code>元素类似，都有能力不受限制地从其他域加载资源。因为JSONP是有效的JavaScript代码，所以在请求完成后，即在JSONP响应加载到页面中以后，就会立即执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function handleResponse(response)&#123;</span><br><span class="line">  alert(&quot;You&apos;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var script = document.createElement(&quot;script&quot;);</span><br><span class="line">script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;</span><br><span class="line">document.body.insertBefore(script,document.body.firstChild);</span><br></pre></td></tr></table></figure><p>优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过，JSONP也有两点不足。</p><p>首先，JSONP是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究。因此在使用不是你自己运维的Web服务时，一定得保证它安全可靠。</p><p>其次，要确定JSONP请求是否失败并不容易。虽然HTML5给<code>&lt;script&gt;</code>元素新增了一个onerror事件处理程序，但目前还没有得到任何浏览器支持。为此，开发人员不得不使用计时器检测指定时间内是否接收到了响应。但就算这样也不能尽如人意，毕竟不是每个用户上网的速度和宽带都一样。</p><h4 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h4><p>Comet是Alex Russell发明的一个词，指的是一种更高级的Ajax技术（经常也有人称为”服务器推送”）。Ajax是一种从页面向服务器请求数据的技术，而Comet则是一种服务器向页面推送数据的技术。Comet能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。</p><h4 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h4><p>轮询（Polling）是一种CPU决策如何提供周边设备服务的方式，又称“程控输入输出”（Programmed I/O）。轮询法的概念是：由CPU定时发出询问，依序询问每一个周边设备是否需要其服务，有即给予服务，服务结束后再问下一个周边，接着不断周而复始。</p><p>有两种实现Comet方式：</p><ol><li>长轮询和流。长轮询是传统轮询（也成为短轮询）的一个翻版，即浏览器定时向服务器发送请求，看有没有更新的数据。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  $i = 0;</span><br><span class="line">  while(true)&#123;</span><br><span class="line">    // 输出一些数据，然后立即刷新输出缓存</span><br><span class="line">    echo &quot;number is $i&quot;;</span><br><span class="line">    flush();</span><br><span class="line"></span><br><span class="line">    // 等几秒钟</span><br><span class="line">    sleep(10);</span><br><span class="line"></span><br><span class="line">    $i++;</span><br><span class="line">  &#125;</span><br><span class="line">php&gt;</span><br></pre></td></tr></table></figure></li></ol><p>随着不断从服务器接收数据，readyState的值会周期性的变为3.当readyState值变为3时，responseText属性中就会保存接收到的所有数据。此时，就需要比较此前接收到的数据，决定从什么位置开始取得最新的数据。使用XHR对象实现HTTP流的典型代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function  createStreamingClient(url, progress, finished)&#123;</span><br><span class="line">  var xhr = new XMLHttpRequest(),</span><br><span class="line">      received = 0;</span><br><span class="line">  </span><br><span class="line">  xhr.open(&quot;get&quot;,url,true);</span><br><span class="line">  xhr.onreadystatechange = function()&#123;</span><br><span class="line">    var result;</span><br><span class="line"></span><br><span class="line">    if(xhr.readyState === 3)&#123;</span><br><span class="line">      // 知趣的最新数据并调整计算器</span><br><span class="line">      result = xhr.responseText.substring(received)</span><br><span class="line">      recelived += result.length;</span><br><span class="line"></span><br><span class="line">      // 调用progress回调函数</span><br><span class="line">      progress(result);</span><br><span class="line">    &#125; else if （xhr.readyState） &#123;</span><br><span class="line">      finished(xhr, responseText)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;；</span><br><span class="line">  xhr.send(null);</span><br><span class="line">  return xhr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var client = createStreamingClient(&quot;streaming.php&quot;, function(data)&#123;</span><br><span class="line">    alert(&quot;Received:&quot; + data);</span><br><span class="line">  &#125;,function(data)&#123;</span><br><span class="line">    alert(&quot;Done!&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个createStreamingClient()函数接收三个参数：</p><ol><li>要连接的URL;</li><li>在接收到数据时调用的函数以及关闭连接时调用的函数。</li><li>有时候，当连接关闭时，很可能还需要重新建立，所以关注链接什么时候关闭还是有必须要的。</li></ol><p>只要readystatechange事件发生，而且readyState值为3，就对responseText进行分割以取得最新数据。这里的received变量用于记录已经处理了多少个字符，每次readyState值为3时都递增。然后通过progress回调函数来处理传入的新数据。而当readyState值为4时，则执行finished回调函数，传入响应返回的全部内容。</p><h4 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h4><p>SSE（Server-Sent Events,服务器发送事件）是围绕只读Comet交互推出的API或者模式。SSE API用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的MIME类型必须是text/event-stream，而且是浏览器中的JavaScript API能解析格式输出。SSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接。有了这么简单实用的API，再实现Comet就容易多了。</p><p>HTTP流。它在页面整个生命周期内只使用一个HTTP连接，具体使用方法即页面向浏览器发送一个请求，而服务器保持tcp连接打开，然后不断向浏览器发送数据。</p><ol><li>SSE API</li></ol><p>SSE的javaScript API与其他传递消息的JavaScript API很相似。要预订新的事件流，首先要创建一个新的EventSource对象，并传进一个入口点：</p><p>var source = new EventSource(“myevents.php”);</p><p>注意，传入的URL必须与创建对象的页面同源（相同的URL模式、域及端口）。EventSource的实例有一个readyState属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭了连接。</p><p>另外，还有一下三个事件。</p><ul><li>open: 在建立连接时触发。</li><li>message: 在从服务器接收到新事件时触发。</li><li>error: 在无法简历连接时触发。</li></ul><p>就一般的用法而言，onmessage事件处理程序也没有什么特别的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source.onmessage = function(event)&#123;</span><br><span class="line">  var data = event.data;</span><br><span class="line">  // 处理数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务器发回的数据以字符串形式保存在event.data中。</p><p>默认情况下，EventSource对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味着SSE适合长轮询和HTTP流。如果想强制立即断开连接并且不再重新连接，可以调用close()方法。</p><p>source.close();</p><ol start="2"><li>事件流</li></ol><p>所谓服务器事件会通过一个持久的HTTP响应发送，这个响应的MIME类型为 text/event-stream。响应的格式是纯文本，最简单的情况是每个数据项都带有前缀data:，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: foo</span><br><span class="line">data: bar</span><br><span class="line"></span><br><span class="line">data: foo</span><br><span class="line">data: bar</span><br></pre></td></tr></table></figure><p>对以上响应而言，事件流中的第一个message事件返回的event.data值为”foo”，第二个message事件返回的event.data值为”bar”,第三个message事件返回的event.data值为”foo\nbar”（注意中间的换行符）。对于多个连续的以data:开头的数据行，将作为多段数据解析，每个值之间以一个换行符分隔。只有包含data:的数据行后面有空行时，才会触发message事件，因此在服务器上生成事件流时不能忘了多添加这一行。</p><p>通过id:前缀可以给特定的事件指定一个关联的ID，这个ID行位于data:行前面或后面皆可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data: foo</span><br><span class="line">id: 1</span><br></pre></td></tr></table></figure><p>设置了ID后，EventSource对象会跟踪上一次触发的事件。如果连接断开，回想服务器发送一个包含名为Last-Event-ID的特殊HTTP头部请求，以便服务器知道下一次该触发哪个事件。在多次连接得事件流中，这种机制可以确保浏览器以正确的顺序收到连接得数据段。</p><h4 id="Web-Sockets"><a href="#Web-Sockets" class="headerlink" title="Web Sockets"></a>Web Sockets</h4><p>要说是令人津津乐道的新浏览器API，就得数Web Sockets了。Web Sockets的目标是在一个单独的持久连接上提供全双工、双向通信。在JavaScript中创建了Web Socket之后，会有一个HTTP请求发送到浏览器已发起连接。在取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为Web Socket协议。也就是说，使用标准的HTTP服务器无法实现Web Sockets,只有支持这种协议的专门服务器才能正常工作。</p><p>由于WebSockets使用了自定义的协议，所以URL模式也略有不同。未加密的连接不再是http://,而是ws://；加密的链接也是不是https://,而是wss://。在使用Web SocketURL时。必须带着这个模式，因为将来还有可能支持其他模式。</p><p>使用自定义协议而非HTTP协议的好处是，能够在客户端和服务端之间发送非常少量的数据，而不必担心HTTP那样字节集的开销。由于传递的数据包很小，因此WebSockets非常适合移动应用。毕竟对移动应用而言，带宽和网络延迟都是关键问题。使用自定义协议的缺点在于，制定协议的时间比制定JavaScriptAPI的时间还要常。Web Sockets曾几度搁浅，就因为不断有人发现这个新协议存在一致性和安全性问题。</p><ol><li>Web Sockets API</li></ol><p>要创建WebSocket,先实例一个WebSocket对象并传入要连接得URL；</p><p><code>var socket = new WebSocket(&quot;URL&quot;);</code></p><p>WebSocket.OPENING(0): 正在建立连接。<br>WebSocket.OPEN(1): 已经建立连接。<br>WebSocket.CLOSING(2): 正在关闭连接。<br>WebSocket.CLOSE(3): 已经关闭连接。</p><p>关闭WebSocket连接，可以在任何时候调用close()方法： socket.close();</p><ol start="2"><li>发送和接收数据</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var message = &#123;</span><br><span class="line">  time: new Date(),</span><br><span class="line">  text: &quot;Hello world!&quot;,</span><br><span class="line">  clientId: &quot;54564646&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.send(JSON.stringify(message));</span><br></pre></td></tr></table></figure><p>接下来，服务器要读取其中的数据，就要解析接收道德JSON字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socket.onmessage = function(event)&#123;</span><br><span class="line">  var data = event.data;</span><br><span class="line">  // 处理数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与通过send()发送到服务器的数据一样，event.data中返回的数据也是字符串。如果你想得到其他格式的数据，必须手工解析这些数据。</p><ol start="3"><li>其他事件</li></ol><p>WebScoket对象有其他三个事件，在连接生命周期的不同阶段触发。</p><ul><li>open: 在成功建立连接时触发。</li><li>error: 在发生错误时触发，连接不能持续。</li><li>close: 在连接关闭时触发。</li></ul><p>WebScoket 对象不支持DOM2级时间侦听器，因此必须使用DOM0级语法分别定义每个事件处理程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);</span><br><span class="line"></span><br><span class="line">socket.onopen = function () &#123;</span><br><span class="line">  alert(&quot;Connection established.&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onerror = function () &#123;</span><br><span class="line">  alert(&quot;Connection error.&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onclose = function (event) &#123;</span><br><span class="line">  alert(&quot;Connection closed.&quot;);</span><br><span class="line">  console.log(&quot;Was clean ? &quot; + event.wasClean + &quot;Code = &quot; + event.code + &quot; Reason= &quot; + event.reason);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="SSE-与-Web-Sockets"><a href="#SSE-与-Web-Sockets" class="headerlink" title="SSE 与 Web Sockets"></a>SSE 与 Web Sockets</h4><p>面对某个具体的用力，在考虑是使用SSE还是使用WebSockets时，可以考虑如下几个因素。首先，你是否有自由度简历和维护WebSockets服务器？其次，到底需不需要双向通信。</p><h4 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h4><ul><li>要求以SSL连接来访问可以通过XHR请求的资源。</li><li>要求每一次请求都要附带经过响应算法计算得到的验证码。</li></ul><p>建议采用上面两种办法。</p><ul><li>要求发送POST而不是GET请求</li><li>检查来源URL以确定是否可信</li><li>基于cookie信息进行验证</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在CORS出现之前，要实现跨域Ajax通信颇费一些周折。开发人员想出了一些办法，利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Ajax</title>
    <link href="https://liushuai97.github.io/2019/09/09/JavaScript-Ajax/"/>
    <id>https://liushuai97.github.io/2019/09/09/JavaScript-Ajax/</id>
    <published>2019-09-09T06:05:35.000Z</published>
    <updated>2019-09-09T09:42:16.326Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h4><ol><li>XHR的用法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 请求类型，请求地址，是否异步</span><br><span class="line">xhr.open(&quot;get&quot;,&quot;http://www.baidu/com&quot;, false)</span><br><span class="line"></span><br><span class="line">// 作为请求主体发送的数据</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure><ul><li>XHR对象的属性：</li></ul><ol><li>responseText: 作为相应主体被返回的文本。</li><li>responseXML: 如果相应的内容类型是”text/html”或”application/xml”，这个属性中将保存喊着响应数据的XML DOM文档。</li><li>status: 响应HTTP状态。</li><li>statusText：HTTP状态的说明。</li><li>readyState：该属性表示请求/响应过程的当前活动阶段。（0未初始化，1启动，2发送，3接收，4完成）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = functuin () &#123;</span><br><span class="line">  if (xhr.readState === 4) &#123;</span><br><span class="line">    if( (xhr &gt;= 200 &amp;&amp; xhr.status &lt;300) || xhr.status === 304) &#123;</span><br><span class="line">      alert(xhr.responseText);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      alert(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);</span><br><span class="line">xhr.send(null);</span><br><span class="line"></span><br><span class="line">在接收响应之前还可以调用abort()方法来取消异步请求。</span><br></pre></td></tr></table></figure><ol start="2"><li>HTTP头部信息</li></ol><p>默认情况下，在发送XHR请求的同时，还会发送下列头部的信息：</p><ul><li>Accept：浏览器能够处理的内容类型。</li><li>Accept-Charset：浏览器能够显示的字符集。</li><li>Accept-Encoding：浏览器能够处理的压缩编码。</li><li>Accept-Language：浏览器当前设置的语言。</li><li>Connection：浏览器与服务器之间连接的类型。</li><li>Cookie：当前页设置的任何Cookie。</li><li>Host：发出请求的页面所在的域。</li><li>Referer：发布请求的页面的URL。</li><li>User-Agent：浏览器的用户代理字符串。</li></ul><p>使用setRequestHeader()方法可以设置自定义的请求头部。这个方法接受两个参数：头部字段的名称和头部字段的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">  if(xhr.readyState === 4) &#123;</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123;</span><br><span class="line">      alert(xhr.responsetext)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      alert(&quot;Request was unsuccessful:&quot; + xhr.status)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(&quot;get&quot;,&quot;url&quot;,true);</span><br><span class="line">xhr.setRequestHeader(&quot;MyHeader&quot;,&quot;Myvalue&quot;);</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure><p>使用getErsponseHeader()方法并栓如头部字段名称，可以取得相应的响应头部信息。<br>使用getAllResponseHeaders()方法则可以取得一个包含所有头部信息的长字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myHeader = xhr.getResponseHeader(&quot;MyHeader&quot;);</span><br><span class="line">var allHeader = xhr.getAllResponseHeaders();</span><br></pre></td></tr></table></figure><ol start="3"><li>Get请求</li></ol><p>GET是最常见的请求类型，最常用于服务器查询某些信息。必要时，可以将查询字符串参数追加到URL的末尾，一遍将信息发送给服务器。对于XHR而言，位于传入open()方法的URL末尾的查询字符串必须经过正确的编码才行。</p><p>使用GET请求经常会发生一个错误，就是查询字符串的格式有问题。查询字符串中每个参数的名称和值都必须使用encodeURIComponent()进行解码，然后才能放到URL的末尾。</p><p><code>xhr.open(&#39;get&#39;,&#39;a.html?name=value&amp;name1=value1&#39;,true)</code></p><p>addURLParam()函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 要添加参数的URL  参数名称  参数值</span><br><span class="line">function addURLParam(url, name, value)&#123;</span><br><span class="line">  url += (url.indexOf(&quot;?&quot;) === -1 ? &quot;?&quot; : &quot;&amp;&quot;);</span><br><span class="line">  url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);</span><br><span class="line">  return url;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">url = addURLParam(url, &quot;book&quot;, &quot;张三&quot;);</span><br><span class="line"></span><br><span class="line">// 初始化请求</span><br><span class="line">xhr.open(&quot;get&quot;, url, false);</span><br></pre></td></tr></table></figure><ol start="4"><li>POST请求</li></ol><p>通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主题提交，而GET请求传统上不是这样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function submitData()&#123;</span><br><span class="line">  var xhr = createXHR();</span><br><span class="line">  xhr.onreadystatechange  = function()&#123;</span><br><span class="line">    if(xhr.readyState === 4) &#123;</span><br><span class="line">      if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123;</span><br><span class="line">        alert(xhr.responsetext)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        alert(&quot;Request was unsuccessful:&quot; + xhr.status)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.open(&quot;post&quot;, &quot;example.php&quot;, true)</span><br><span class="line">  xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;)</span><br><span class="line">  var form = document.getElementById(&quot;user-info&quot;)</span><br><span class="line">  xhr.send(serialize(form))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="XMLHttpRequest-2级"><a href="#XMLHttpRequest-2级" class="headerlink" title="XMLHttpRequest 2级"></a>XMLHttpRequest 2级</h4><ol><li>FormData</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">  if(xhr.readyState === 4) &#123;</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123;</span><br><span class="line">      alert(xhr.responsetext)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      alert(&quot;Request was unsuccessful:&quot; + xhr.status)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(&quot;post&quot;,&quot;url&quot;,true);</span><br><span class="line">var form = document.getElementById(&quot;user-info&quot;)</span><br><span class="line">xhr.send(new FormData(form))</span><br></pre></td></tr></table></figure><ol start="2"><li>超时设定</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">  if(xhr.readyState === 4) &#123;</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123;</span><br><span class="line">      alert(xhr.responsetext)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      alert(&quot;Request was unsuccessful:&quot; + xhr.status)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(&quot;get&quot;,&quot;url&quot;,true);</span><br><span class="line">xhr.timeout = 1000;</span><br><span class="line">xhr.ontimeout = function () &#123;</span><br><span class="line">  alert(&quot;Request did not return is a second.&quot;);</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure><ol start="3"><li>overrideMimeType()方法</li></ol><p>通过调用overrideMimeType()方法，可以保证把响应当做XML而非纯文本来处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line">xhr.open(&quot;get&quot;,&quot;url&quot;,true);</span><br><span class="line">xhr.overrideMimeType(&quot;text/xml&quot;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure><ol start="4"><li>进度事件</li></ol><ul><li>loadstart：在接收到响应数据的第一个字节是触发。</li><li>progress：在接收响应期间持续不断地触发。</li><li>error：在请求发生错误时触发。</li><li>abort：在因为调用abort()方法而终止连接时触发。</li><li>load：在接收到完整响应数据时触发。</li><li>loadend：在通信完成或者触发error、abort或load事件后触发。</li></ul><p>load事件，只要浏览器接收到服务器响应，不管其状态如何，都会触发load事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line">xhr.onload = function () &#123;</span><br><span class="line">  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123;</span><br><span class="line">    alert(xhr.responsetext)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    alert(&quot;Request was unsuccessful:&quot; + xhr.status)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(&quot;get&quot;,&quot;altevents.php&quot;,true)</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure><p>progress事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line"></span><br><span class="line">xhr.onload = function () &#123;</span><br><span class="line">  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &gt;300) || xhr.status === 304) &#123;</span><br><span class="line">    alert(xhr.responsetext)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    alert(&quot;Request was unsuccessful:&quot; + xhr.status)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.onprogress = function(event)&#123;</span><br><span class="line">  var divStatus = document.getElementById(&quot;status&quot;);</span><br><span class="line">  if(event.lengthComputable)&#123;</span><br><span class="line">    divStatus.innerHTML = &quot;Received&quot; + event.position + &quot;of&quot; + event.totalSize + &quot;bytes&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.open(&quot;get&quot;,&quot;altevents.php&quot;,true)</span><br><span class="line">xhr.send(null)</span><br></pre></td></tr></table></figure><h4 id="跨源资源共享"><a href="#跨源资源共享" class="headerlink" title="跨源资源共享"></a>跨源资源共享</h4><p>CORS(Cross-Origin Resource Sharing, 跨源资源共享)，是W3C的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或相应是应该成功，还是应该失败。</p><ul><li>IE对CORS的实现</li></ul><p>微软在IE8中引入了XDR(XDomainRequest)类型。这个对象与XHR类似，但能实现安全可靠的跨域通信。XDR对象的安全机制部分实现了W3C的CORS规范。以下是XDR与XHR的一些不同之处。</p><ol><li>cookie不会随请求发送，也不会随响应返回。</li><li>智能设置请求头部信息中的Content-Type字段。</li><li>不能访问响应头部信息。</li><li>只支持GET和POST请求。</li></ol><p>这些变化使CSRF(Cross-Site Request Forgery,跨站点请求伪造)和XSS(Cross-Site Scripting,跨站点脚本)的问题得到了缓解。</p><p>被请求的资源可以根据它认为合适的任意数据（用户代理，来源页面等）来决定是否设置Access-Control-Allow-Origin头部。作为请求的一部分，Origin头部的值表示请求的来源域，以便远程 资源明确地识别XDR请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var xdr = new XDomainRequest();</span><br><span class="line">xdr.onload = function()&#123;</span><br><span class="line">  alert(xdr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">xdr.onerror = function()&#123;</span><br><span class="line">  alert(&quot;An error occurred.&quot;)</span><br><span class="line">&#125;;</span><br><span class="line">xdr.timeout = 1000;</span><br><span class="line">xdr.ontimeout = function()&#123;</span><br><span class="line">  alert(&quot;Request took too long.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// GET请求</span><br><span class="line">xdr.open(&quot;get&quot;,&quot;url&quot;);</span><br><span class="line">xdr.send(null);</span><br><span class="line"></span><br><span class="line">// POST请求</span><br><span class="line">xdr.open(&quot;post&quot;,&quot;url&quot;);</span><br><span class="line">xdr.contentType = &quot;application/x-www-form-urencoded&quot;;</span><br><span class="line">xdr.send(&quot;name=value&amp;name2=value2&quot;);</span><br></pre></td></tr></table></figure><p>跨域XHR对象也有一些限制，但是为了安全这些限制是必需的。</p><ul><li>不能使用setRequestHeader()设置自定义头部。</li><li>不能发送和接收cookie。</li><li>调用getAllResponseHeaders()方法总会返回空字符串。</li></ul><h4 id="Preflighted-Reqeusts"><a href="#Preflighted-Reqeusts" class="headerlink" title="Preflighted Reqeusts"></a>Preflighted Reqeusts</h4><p>透明服务器验证机制支持开发人员使用自定义头部、GET或POST之外的方法，以及不同类型的主体内容。</p><ul><li>Origin：与简单的请求相同。</li><li>Access-Control-Request-Method：请求自身使用的方法。</li><li>Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Origin: url</span><br><span class="line">Access-Control-Request-Method: POST</span><br><span class="line">Access-Control-Request-Headers: NCZ</span><br></pre></td></tr></table></figure><p>发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在响应中发送如下头部与浏览器进行沟通。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: url</span><br><span class="line">Access-Control-Allow-Method: POST,GET</span><br><span class="line">Access-Control-Allow-Headers: NCZ</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure><p>Preflight请求结束后，结果将按照响应中指定的时间缓存起来。</p><h4 id="带凭据的请求"><a href="#带凭据的请求" class="headerlink" title="带凭据的请求"></a>带凭据的请求</h4><p>默认情况下，跨源请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。如果服务器接收带凭据的请求，会用下面的HTTP头部来响应。</p><p>Access-Control-Allow-Credentials: true</p><h4 id="跨浏览器的CORS"><a href="#跨浏览器的CORS" class="headerlink" title="跨浏览器的CORS"></a>跨浏览器的CORS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function createCORSRequest(method,url)&#123;</span><br><span class="line">  var xhr = new XMLHttpRequest();</span><br><span class="line">  if(&quot;withCredentials&quot; in xhr)&#123;</span><br><span class="line">    xhr.open(method,url,true);</span><br><span class="line">  &#125; </span><br><span class="line">  if(typeof XDomainRequest != &quot;undefined&quot;)&#123;</span><br><span class="line">    vxhr = new XDomainRequest();</span><br><span class="line">    xhr.open(method, url);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    xhr = null;</span><br><span class="line">  &#125;</span><br><span class="line">  return xhr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var request = createCORSRequest(&quot;get&quot;,url);</span><br><span class="line">if(request)&#123;</span><br><span class="line">  request.onload = function () &#123;</span><br><span class="line">    // 对request.responseText进行处理</span><br><span class="line">  &#125;</span><br><span class="line">  request.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XMLHttpRequest对象与XDomainRequest对象共同的属性/方法如下：</p><ul><li>abort(): 用于停止正在进行的请求。</li><li>onerror: 用于替代onreadystatechange检测错误。</li><li>onload: 用于替代onreadystatechange检测成功。</li><li>responseText: 用于取得响应内容。</li><li>send(): 用于发送请求。</li></ul><p>以上成员都包含在createCORSRequest()函数返回的对象中。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;XMLHttpRequest对象&quot;&gt;&lt;a href=&quot;#XMLHttpRequest对象&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript JSON</title>
    <link href="https://liushuai97.github.io/2019/09/09/JavaScript-JSON/"/>
    <id>https://liushuai97.github.io/2019/09/09/JavaScript-JSON/</id>
    <published>2019-09-09T05:09:38.000Z</published>
    <updated>2019-09-09T06:04:38.775Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --><h4 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h4><p>JSON语言可以表示一下三种类型的值：</p><ol><li>简单值，使用与JavaScript相同的语法，可以在JSON中表示字符串，数值，布尔值，和null，但JSON不支持JavaScript中的特殊值undefined;</li><li>对象：对象作为一种复杂数据类型，表示是一组有序的键值对。而每个键值对中的值可以是简单之，也可以是复杂数据类型的值；</li><li>数组：数组也是一种复杂数据类型，表示一组有序的值得列表。可以通过数值索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。</li></ol><h4 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h4><p>最简单的JSON数据形式就是简单值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">&quot;Hello world&quot;</span><br><span class="line">true</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>JavaScript字符串与JSON字符串的最大区别在于，JSON字符串必须使用双引号(单引号会导致语法错误)。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>JSON中的对象与JavaScript字面量稍微有一些不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">  name: &quot;张飒&quot;,</span><br><span class="line">  age: 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON表示上述对象方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;age&quot;: 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>JSON中的第二种复杂数据类型是数组。JSON数组采用的就是Javascript中数组字面量形式。</p><p><code>var value = [25, 10, &quot;张三&quot;]</code></p><p>JSON中，可以采用同样语法表示同一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;:&quot;张三&quot;,</span><br><span class="line">    &quot;age&quot;: 18</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;:&quot;李四&quot;,</span><br><span class="line">    &quot;age&quot;: 18</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc.getElementsByTagName(&quot;book&quot;)[2].getAttribute(&quot;title&quot;)</span><br></pre></td></tr></table></figure><h4 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">  title: &quot;张三&quot;,</span><br><span class="line">  authors: [</span><br><span class="line">    &quot;李四&quot;</span><br><span class="line">  ],</span><br><span class="line">  edition: 3,</span><br><span class="line">  year: 2019,</span><br><span class="line">&#125;;</span><br><span class="line">var jsonText = JSON.stringfy(book);</span><br><span class="line"></span><br><span class="line">// stringfy对象序列化为一个JSON字符串</span><br><span class="line"></span><br><span class="line">var bookCopy = JSON.parse(jsonText)</span><br><span class="line"></span><br><span class="line">// 如果传给JSON.parse()的字符串不是有效的JSON，该方法会抛出错误</span><br></pre></td></tr></table></figure><h4 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h4><ol><li>过滤结果</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">  &quot;title&quot;: &quot;标题&quot;,</span><br><span class="line">  &quot;authors&quot;: [</span><br><span class="line">    &quot;作者君&quot;</span><br><span class="line">  ],</span><br><span class="line">  edition: 1,</span><br><span class="line">  year: 2019</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var jsonText = JSON.stringfy(book,[&quot;title&quot;,&quot;edition&quot;]);</span><br></pre></td></tr></table></figure><p>JSON.stringfy()的第二个参数是一个数组，其中包含两个字符串：”title” “edition”。这两个属性与将要序列化的对象中的属性是对应的，因此在返回的结果字符中，就只会包含着两个属性：</p><p><code>{&quot;title&quot;: &quot;标题&quot;, &quot;edition&quot;: 1}</code></p><p>如果第二个参数是函数，行为会稍有不同。传入的函数接收两个参数，属性和属性值。根据属性可以知道应该如何处理要序列化的对象中的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var jsonText = JSON.stringify(book, function(key, value)&#123;</span><br><span class="line">  switch(key)&#123;</span><br><span class="line">    case &quot;authors&quot;:</span><br><span class="line">      return value.join(&quot;,&quot;)</span><br><span class="line">    case &quot;year&quot;:</span><br><span class="line">      return 2000;</span><br><span class="line">    case &quot;edition&quot;:</span><br><span class="line">      return undefined;</span><br><span class="line">    default:</span><br><span class="line">      return value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>字符串缩进</li></ol><p>JSON.stringify()方法的第三个参数用于控制结果中的缩进和空白符。如果这个参数是一个数值，那它表示的每个级别缩进的空格数。</p><p><code>var jsonText = JSON.stringify(book, null, 4);</code></p><p>console.log(jsonText)返回结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;title&quot;: &quot;张三&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>toJSON()方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">  &quot;title&quot;: &quot;标题&quot;</span><br><span class="line">  toJSON: function () &#123;</span><br><span class="line">    return this.title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var jsonText = JSON.stringify(book);</span><br></pre></td></tr></table></figure><h4 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h4><p>JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对上调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var bookCopy = JSON.parse(jsonText, function (key, value)&#123;</span><br><span class="line">  if(key === &quot;releaseDate&quot;)&#123;</span><br><span class="line">    return new Date(value);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(bookCopy.releaseDate.getFullYear());</span><br></pre></td></tr></table></figure><p>ECMAScript 5定义了一个原生的JSON对象，可以用来将对象序列化为JSON字符串或者将JSON数据解析为JavaScript对象。JSON.stringify()和JSON.parse()方法分别用来实现上述两项功能。这两个方法都有一些选项，通过他们可以改变过滤的方式，或者改变序列化的过程。</p><h4 id="JSON对象转化"><a href="#JSON对象转化" class="headerlink" title="JSON对象转化"></a>JSON对象转化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">//json字符串、json对象、数组 三者之间的转换</span><br><span class="line">let jsonStr = &apos;[</span><br><span class="line">  &#123;&quot;id&quot;:&quot;01&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;01&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;011&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;01&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;03&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;,</span><br><span class="line">  &#123;&quot;id&quot;:&quot;04&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, </span><br><span class="line">  &#123;&quot;id&quot;:&quot;05&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;, </span><br><span class="line">  &#123;&quot;id&quot;:&quot;06&quot;,&quot;open&quot;:false,&quot;pId&quot;:&quot;0&quot;,&quot;name&quot;:&quot;A部门&quot;&#125;</span><br><span class="line">]&apos;;</span><br><span class="line"></span><br><span class="line">let jsonObj = $.parseJSON(jsonStr);</span><br><span class="line">//json字符串转化成json对象(jq方法)</span><br><span class="line"></span><br><span class="line">//let jsonObj =  JSON.parse(jsonStr)</span><br><span class="line">//json字符串转化成json对象（原生方法）</span><br><span class="line"></span><br><span class="line">let jsonStr1 = JSON.stringify(jsonObj)</span><br><span class="line">//json对象转化成json字符串</span><br><span class="line"></span><br><span class="line">//console.log(jsonStr1+&quot;jsonStr1&quot;)</span><br><span class="line"></span><br><span class="line">//json对象转化成json数组对象</span><br><span class="line">let arr1=[];</span><br><span class="line">for(let i in jsonObj)&#123;</span><br><span class="line">    //let o=&#123;&#125;;</span><br><span class="line">    //o[i]=jsonObj[i];</span><br><span class="line">    arr1.push(jsonObj[i]);            </span><br><span class="line">&#125;</span><br><span class="line">//console.log(arr1);</span><br><span class="line">//console.log(typeof(arr));</span><br><span class="line"></span><br><span class="line">let jsonStr11 = JSON.stringify(arr1)</span><br><span class="line">//json数组转化成json字符串</span><br><span class="line">//console.log(jsonStr11);</span><br><span class="line"></span><br><span class="line">let jsonArr = [];</span><br><span class="line">for(let i in jsonObj)&#123;</span><br><span class="line">        jsonArr[i] = jsonObj[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//console.log(jsonArr);</span><br><span class="line">//console.log(typeof(jsonArr));</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//将对象转化为数组</span><br><span class="line">let obj=&#123;&apos;未完成&apos;:5,&apos;已完成&apos;:8,&apos;待确认&apos;:4,&apos;已取消&apos;:6&#125;;</span><br><span class="line"></span><br><span class="line">let arr = [];</span><br><span class="line"></span><br><span class="line">for (let i in obj) &#123;</span><br><span class="line"></span><br><span class="line">  //arr.push(obj[i]); //属性</span><br><span class="line">  //arr.push(obj[i]); //值</span><br><span class="line"></span><br><span class="line">  let o=&#123;&#125;;</span><br><span class="line">  o[i]=obj[i];</span><br><span class="line">  arr.push(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function objToArray(array) &#123;</span><br><span class="line">    let arr = []; </span><br><span class="line">    for (let i in array) &#123;</span><br><span class="line">        let o=&#123;&#125;;</span><br><span class="line">        o[i]=array[i];</span><br><span class="line">        arr.push(o); </span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arr);</span><br><span class="line">    //return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// console.log(arr)</span><br><span class="line">objToArray(obj);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Sep 24 2019 19:50:51 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;JSON语法&quot;&gt;&lt;a href=&quot;#JSON语法&quot; class=&quot;headerlink&quot; title=&quot;JSON语法&quot;&gt;&lt;/a&gt;JSO
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
