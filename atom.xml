<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随笔</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liushuai97.github.io/"/>
  <updated>2019-10-02T05:18:10.613Z</updated>
  <id>https://liushuai97.github.io/</id>
  
  <author>
    <name>前端菜鸟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Browser对象 Location对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/10/02/Browser%E5%AF%B9%E8%B1%A1-Location%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/10/02/Browser对象-Location对象属性与方法/</id>
    <published>2019-10-02T05:11:51.000Z</published>
    <updated>2019-10-02T05:18:10.613Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --><p>location是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上，location对象是很特别的一个对象，因为它既是window对象的属性，也是document对象的属性；换句话说，window.location和document.location引用的是同一个对象。</p><p>location对象的用处不只表现在它保存着当前文档的信息，还表现在它将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。</p><h4 id="location对象属性"><a href="#location对象属性" class="headerlink" title="location对象属性"></a>location对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">hash</td><td>设置会返回从#号开始的URL（锚）。</td></tr><tr><td align="center">host</td><td>设置或返回主机名和当前URL的端口号。</td></tr><tr><td align="center">hostname</td><td>设置或返回当前URL的主机名。</td></tr><tr><td align="center">href</td><td>设置或返回完整的URL。</td></tr><tr><td align="center">pathname</td><td>设置或返回当前URL的路径部分。</td></tr><tr><td align="center">port</td><td>设置或返回当前URL的端口号。</td></tr><tr><td align="center">protocol</td><td>设置或返回当前URL的协议。</td></tr><tr><td align="center">search</td><td>设置或返回从问号（?）开始的URL（查询部分）。</td></tr></tbody></table><h4 id="location对象方法"><a href="#location对象方法" class="headerlink" title="location对象方法"></a>location对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">assign()</td><td>加载新的文档</td></tr><tr><td align="center">reload()</td><td>重新加载当前文档</td></tr><tr><td align="center">replace()</td><td>用新的文档替换当前文档。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;location是最有用的BOM对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上，location对象是很特别的
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Browser对象 History对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/10/02/Browser%E5%AF%B9%E8%B1%A1-History%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/10/02/Browser对象-History对象属性与方法/</id>
    <published>2019-10-02T05:05:54.000Z</published>
    <updated>2019-10-02T05:11:13.001Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --><p>History对象，History对象包含用户（在浏览器窗口中）访问过的URL。</p><p>History对象是window对象的一部分，可通过window.history属性对其进行访问。</p><p>注释：没有应用History对象的公开标准，不过所有浏览器都支持该对象。</p><p>History对象保存着用户上网的历史记录，从窗口被打开的那一刻算起。因为history是window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自己的history对象与特定的window对象关联。处于安全方面的考虑，开发人员无法得知用户浏览过的URL。不过借由用户访问过的页面立碑，同样可以在不知道实际URL的情况下实现后退和前进。</p><h4 id="History对象属性"><a href="#History对象属性" class="headerlink" title="History对象属性"></a>History对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">length</td><td>返回浏览器历史列表中URL数量。</td></tr></tbody></table><h4 id="History对象方法"><a href="#History对象方法" class="headerlink" title="History对象方法"></a>History对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">back()</td><td>加载history列表中的前一个URL。</td></tr><tr><td align="center">forward()</td><td>加载history列表中的下一个URL。</td></tr><tr><td align="center">go()</td><td>加载history列表中的某个具体页面。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;History对象，History对象包含用户（在浏览器窗口中）访问过的URL。&lt;/p&gt;&lt;p&gt;History对象是window对象的一部分，可通
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Browser对象 Screen对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/10/02/Browser%E5%AF%B9%E8%B1%A1-Screen%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/10/02/Browser对象-Screen对象属性与方法/</id>
    <published>2019-10-02T04:57:38.000Z</published>
    <updated>2019-10-02T05:05:14.611Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --><p>JavaScript中有几个对象在变成汇总用处不大，而screen对象就是其中之一。screen对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。每个浏览器中的screen对象都包含各不相同的属性。</p><p>Screen对象</p><p>Screen对象包含有关客户端显示屏幕的信息。<br>注释：没有应用于screen对象的公开标准，不过所有浏览器都支持该对象。</p><h4 id="Screen对象属性"><a href="#Screen对象属性" class="headerlink" title="Screen对象属性"></a>Screen对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">availHeight</td><td>返回显示屏幕的高度（除windows任务栏之外）。</td></tr><tr><td align="center">availWidth</td><td>返回显示屏幕的宽度（除windows任务栏之外）。</td></tr><tr><td align="center">bufferDepth</td><td>设置或返回调色板的比特深度。</td></tr><tr><td align="center">colorDepth</td><td>返回目标设备或缓冲器上的调色板的比特深度。</td></tr><tr><td align="center">deviceXDPI</td><td>返回显示屏幕的每英寸水平点数。</td></tr><tr><td align="center">deviceYDPI</td><td>返回显示屏幕的每英寸垂直点数。</td></tr><tr><td align="center">fontSmoothingEnabled</td><td>返回用户是否在显示控制面板中启用字体平滑。</td></tr><tr><td align="center">height</td><td>返回显示屏幕的高度。</td></tr><tr><td align="center">logicalXDPI</td><td>返回显示屏幕每英寸的水平方向的常规点数。</td></tr><tr><td align="center">logicalYDPI</td><td>返回显示屏幕每英寸的垂直方向的常规点数。</td></tr><tr><td align="center">pixelDepth</td><td>返回显示屏幕的颜色分辨率（比特每像素）。</td></tr><tr><td align="center">updateInterval()</td><td>设置或返回屏幕的刷新率。</td></tr><tr><td align="center">width</td><td>返回显示器屏幕的宽度。</td></tr></tbody></table><p>Screen对象描述，每个window对象的screen属性都引用一个screen对象。screen对象中存放着显示浏览器屏幕的信息。JavaScript程序将利用这些信息来优化他们的输出，已达到用户的显示要求。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;JavaScript中有几个对象在变成汇总用处不大，而screen对象就是其中之一。screen对象基本上只用来表明客户端的能力，其中包括浏览器
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Browser对象 Navigator对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/10/02/Browser%E5%AF%B9%E8%B1%A1-Navigator%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/10/02/Browser对象-Navigator对象属性与方法/</id>
    <published>2019-10-02T02:36:10.000Z</published>
    <updated>2019-10-02T02:59:36.194Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --><p>navigator对象，navigator对象包含有关浏览器的信息。</p><p>注释：没有应用于navigator对象的公开标准，不过所有浏览器都支持该对象。</p><p>Navigator对象集合，<code>plugins[]</code>,返回对文档中所有嵌入式对象的引用。该集合是一个Plugin对象的数组，其中的元素代表浏览器已经安装的插件。Plug-in对象提供的是有关插件的信息，其中包括它所支持的MIME类型的列表。虽然<code>plugins[]</code>数组是有IE4定义的，但是在IE4中它却总是空的，因为IE4不支持插件和Plugin对象。</p><h4 id="Navigator对象属性"><a href="#Navigator对象属性" class="headerlink" title="Navigator对象属性"></a>Navigator对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">appCodeName</td><td>返回浏览器的代码名。</td></tr><tr><td align="center">appMinorVersion</td><td>返回浏览器的次级版本。</td></tr><tr><td align="center">appName</td><td>返回浏览器的名称。</td></tr><tr><td align="center">appVersion</td><td>返回浏览器的平台和版本信息。</td></tr><tr><td align="center">browserLanguage</td><td>返回当前浏览器的语言。</td></tr><tr><td align="center">cookieEnabled</td><td>返回指明浏览器中是否启用cookie的布尔值。</td></tr><tr><td align="center">cpuClass</td><td>返回浏览器系统的CPU等级。</td></tr><tr><td align="center">onLine</td><td>返回指明系统是否处于脱机模式的布尔值。</td></tr><tr><td align="center">platform</td><td>返回运行浏览器的操作系统平台。</td></tr><tr><td align="center">systemLanguage</td><td>返回OS使用的默认语言。</td></tr><tr><td align="center">userAgent</td><td>返回由客户机发送服务器的user-agent头部的值。</td></tr><tr><td align="center">userLanguage</td><td>返回OS的自然语言设置。</td></tr></tbody></table><p>Naviagtor对象方法<br>方法|描述<br>:-:|-<br>javaEnabled()|规定浏览器是否启用Java。<br>tainEnabled()|规定浏览器是否启动数据污点(data tainting)。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;navigator对象，navigator对象包含有关浏览器的信息。&lt;/p&gt;&lt;p&gt;注释：没有应用于navigator对象的公开标准，不过所有浏览
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Browser对象 Window对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/10/02/Browser%E5%AF%B9%E8%B1%A1-Window%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/10/02/Browser对象-Window对象属性与方法/</id>
    <published>2019-10-02T01:51:10.000Z</published>
    <updated>2019-10-02T02:34:51.148Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --><p>window对象，BOM的核心对象是window。它表示浏览器的一个实例。在浏览器总，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象。</p><p>window对象表示浏览器中打开的窗口。如果问到包含框架（frame或iframe标签），浏览器会为HTML文档创建一个window对象，并未每个框架创建一个额外的window对象。</p><p>window对象集合，<code>frames[]</code>,返回窗口中所有命名的框架。该集合是window对象的数组，每个window对象在窗口中含有一个框架或<code>&lt;iframe&gt;&lt;/iframe&gt;</code>。属性<code>frames.length</code>存在数组<code>frames[]</code>中含有的元素个数。</p><h4 id="window对象属性"><a href="#window对象属性" class="headerlink" title="window对象属性"></a>window对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">closed</td><td>返回窗口是否已被关闭。</td></tr><tr><td align="center">defaultStatus</td><td>设置或返回窗口状态栏中的默认文本。</td></tr><tr><td align="center">document</td><td>对Document对象的只读引用。</td></tr><tr><td align="center">history</td><td>对History对象的只读引用。</td></tr><tr><td align="center">innerheight</td><td>返回窗口的文档显示区的高度。</td></tr><tr><td align="center">innerwidth</td><td>返回窗口的文档显示区的宽度。</td></tr><tr><td align="center">length</td><td>设置或返回窗口中的框架数量。</td></tr><tr><td align="center">location</td><td>用于窗口或框架的Location对象。</td></tr><tr><td align="center">name</td><td>设置或返回窗口的名称。</td></tr><tr><td align="center">Naviagtor</td><td>对Navigator对象的只读引用。</td></tr><tr><td align="center">opener</td><td>返回对创建此窗口的窗口的引用。</td></tr><tr><td align="center">outerheight</td><td>返回窗口的外部高度。</td></tr><tr><td align="center">outerwidth</td><td>返回窗口的外部宽度。</td></tr><tr><td align="center">pageXOffset</td><td>设置或返回当前页面相对于窗口显示区左上角的X位置。</td></tr><tr><td align="center">pageYOffset</td><td>设置或返回当前页面相对于窗口显示区左上角的Y位置。</td></tr><tr><td align="center">parent</td><td>返回父窗口。</td></tr><tr><td align="center">Screen</td><td>对Screen对象的只读引用。</td></tr><tr><td align="center">self</td><td>返回对当前窗口的引用。等价于window属性。</td></tr><tr><td align="center">status</td><td>返回窗口状态栏的文本。</td></tr><tr><td align="center">top</td><td>返回最顶层的先辈窗口。</td></tr><tr><td align="center">window</td><td>window属性等价于self属性，它包含了对窗口自身的引用。</td></tr><tr><td align="center">screenLeft</td><td>只读整数。声明了窗口的左上角在屏幕上的x坐标和y坐标。IE、Safari和Opera支持screenLeft和screenRight，而FireFox和Safari支持screenX和screenY.</td></tr></tbody></table><h4 id="window对象方法"><a href="#window对象方法" class="headerlink" title="window对象方法"></a>window对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">alert()</td><td>显示带有一段消息和一个确认按钮的警告框。</td></tr><tr><td align="center">blur()</td><td>把键盘焦点从顶层窗口移开。</td></tr><tr><td align="center">clearInterval()</td><td>取消由setInterval()设置的timeout。</td></tr><tr><td align="center">clearTimeout()</td><td>取消由setTimeout()方法设置的timeout。</td></tr><tr><td align="center">close()</td><td>关闭浏览器窗口。</td></tr><tr><td align="center">confirm()</td><td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td></tr><tr><td align="center">createPopup()</td><td>创建一个pop-up窗口。</td></tr><tr><td align="center">focus()</td><td>把键盘焦点给与一个窗口。</td></tr><tr><td align="center">moveBy()</td><td>可相对窗口的当前坐标把它移动指定的像素。</td></tr><tr><td align="center">moveTo()</td><td>把窗口的左上角移动到一个指定的坐标。</td></tr><tr><td align="center">open()</td><td>打开一个新的浏览器窗口或查找一个已命名的窗口。</td></tr><tr><td align="center">print()</td><td>打印当前窗口的内容。</td></tr><tr><td align="center">prompt()</td><td>显示课题是用户输入的对话框。</td></tr><tr><td align="center">resizeBy()</td><td>按照指定的像素调整窗口的大小。</td></tr><tr><td align="center">resizeTo()</td><td>把窗口的大小调整到指定的宽度和高度。</td></tr><tr><td align="center">scrollBy()</td><td>按照指定的像素值来滚动内容。</td></tr><tr><td align="center">scrollTo()</td><td>把内容滚动到指定的坐标。</td></tr><tr><td align="center">setInterval()</td><td>按照指定的周期（以毫秒计）来调用函数或计算表达式。</td></tr><tr><td align="center">setTimeout()</td><td>在指定的毫秒数后调用函数或计算表达式。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;window对象，BOM的核心对象是window。它表示浏览器的一个实例。在浏览器总，window对象有双重角色，它既是通过JavaScript
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Events事件句柄</title>
    <link href="https://liushuai97.github.io/2019/09/30/JavaScript-Events%E4%BA%8B%E4%BB%B6%E5%8F%A5%E6%9F%84/"/>
    <id>https://liushuai97.github.io/2019/09/30/JavaScript-Events事件句柄/</id>
    <published>2019-09-30T08:22:42.000Z</published>
    <updated>2019-09-30T08:24:41.632Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><p>事件通常与函数配合使用，这样就可以通过发生的事件来驱动函数执行。</p><h4 id="事件句柄"><a href="#事件句柄" class="headerlink" title="事件句柄"></a>事件句柄</h4><p>HTML 4.0 的新特性之一是有能力使 HTML 事件触发浏览器中的动作（action），比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，这些属性可插入 HTML 标签来定义事件动作。</p><table><thead><tr><th align="center">属性</th><th>当以下情况发生时，出现此事件</th></tr></thead><tbody><tr><td align="center">onabort</td><td>图像加载被中断</td></tr><tr><td align="center">onblur</td><td>元素失去焦点</td></tr><tr><td align="center">onchange</td><td>用户改变域的内容</td></tr><tr><td align="center">onclick</td><td>鼠标点击某个对象</td></tr><tr><td align="center">ondblclick</td><td>鼠标双击某个对象</td></tr><tr><td align="center">onerror</td><td>当加载文档或图像时发生某个错误</td></tr><tr><td align="center">onfocus</td><td>元素获得焦点</td></tr><tr><td align="center">onkeydown</td><td>某个键盘的键被按下</td></tr><tr><td align="center">onkeypress</td><td>某个键盘的键被按下或按住</td></tr><tr><td align="center">onkeyup</td><td>某个键盘的键被松开</td></tr><tr><td align="center">onload</td><td>某个页面或图像被完成加载</td></tr><tr><td align="center">onmousedown</td><td>某个鼠标按键被按下</td></tr><tr><td align="center">onmousemove</td><td>鼠标被移动</td></tr><tr><td align="center">onmouseout</td><td>鼠标从某元素移开</td></tr><tr><td align="center">onmouseover</td><td>鼠标被移到某元素之上</td></tr><tr><td align="center">onmouseup</td><td>某个鼠标按键被松开</td></tr><tr><td align="center">onreset</td><td>重置按钮被点击</td></tr><tr><td align="center">onresize</td><td>窗口或框架被调整尺寸</td></tr><tr><td align="center">onselect</td><td>文本被选定</td></tr><tr><td align="center">onsubmit</td><td>提交按钮被点击</td></tr><tr><td align="center">onunload</td><td>用户退出页面</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;事件通常与函数配合使用，这样就可以通过发生的事件来驱动函数执行。&lt;/p&gt;&lt;h4 id=&quot;事件句柄&quot;&gt;&lt;a href=&quot;#事件句柄&quot; class=
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Functions全局对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/30/JavaScript-Functions%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/30/JavaScript-Functions全局对象属性与方法/</id>
    <published>2019-09-30T08:00:21.000Z</published>
    <updated>2019-09-30T08:17:15.728Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><p>全局对象是预定义的对象，作为JavaScript的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。全局对象不是任何对象的属性，所以它没有名称。</p><p>在顶层JavaScript代码中，可以用关键字this引用全局对象。但通常不必用这种方式引用全局对象，因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p><p>全局对象是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象。</p><p>Function类型，说起来ECMAScript中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p><p>JavaScript 全局对象，全局属性和函数可用于所有内建的 JavaScript 对象。</p><h4 id="顶层属性（全局属性）"><a href="#顶层属性（全局属性）" class="headerlink" title="顶层属性（全局属性）"></a>顶层属性（全局属性）</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">Infinity</td><td>代表正的无穷大的数值。</td></tr><tr><td align="center">java</td><td>代表 java.* 包层级的一个 JavaPackage。</td></tr><tr><td align="center">NaN</td><td>指示某个值是不是数字值。</td></tr><tr><td align="center">Packages</td><td>根 JavaPackage 对象。</td></tr><tr><td align="center">undefined</td><td>指示未定义的值。</td></tr></tbody></table><h4 id="顶层函数（全局函数）"><a href="#顶层函数（全局函数）" class="headerlink" title="顶层函数（全局函数）"></a>顶层函数（全局函数）</h4><table><thead><tr><th align="center">函数</th><th>描述</th></tr></thead><tbody><tr><td align="center">decodeURI()</td><td>解码某个编码的 URI。</td></tr><tr><td align="center">decodeURIComponent()</td><td>解码一个编码的 URI 组件。</td></tr><tr><td align="center">encodeURI()</td><td>把字符串编码为 URI。</td></tr><tr><td align="center">encodeURIComponent()</td><td>把字符串编码为 URI 组件。</td></tr><tr><td align="center">escape()</td><td>对字符串进行编码。</td></tr><tr><td align="center">eval()</td><td>计算 JavaScript 字符串，并把它作为脚本代码来执行。</td></tr><tr><td align="center">getClass()</td><td>返回一个 JavaObject 的 JavaClass。</td></tr><tr><td align="center">isFinite()</td><td>检查某个值是否为有穷大的数。</td></tr><tr><td align="center">isNaN()</td><td>检查某个值是否是数字。</td></tr><tr><td align="center">Number()</td><td>把对象的值转换为数字。</td></tr><tr><td align="center">parseFloat()</td><td>解析一个字符串并返回一个浮点数。</td></tr><tr><td align="center">parseInt()</td><td>解析一个字符串并返回一个整数。</td></tr><tr><td align="center">String()</td><td>把对象的值转换为字符串。</td></tr><tr><td align="center">unescape()</td><td>对由 escape() 编码的字符串进行解码。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;全局对象是预定义的对象，作为JavaScript的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。全
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript RegExp对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/30/JavaScript-RegExp%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/30/JavaScript-RegExp对象属性与方法/</id>
    <published>2019-09-30T06:23:51.000Z</published>
    <updated>2019-09-30T06:40:39.069Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><p>ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。</p><p><code>var expression = /pattern/flags;</code></p><p>其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定类、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。</p><p>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；<br>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；<br>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</p><p>因此，一个正则表达式就是一个模式与上述3个标志的组合体。不同组合产生不同结果，如下面的例子所示。</p><p>RegExp 对象，正则表达式是描述字符模式的对象。</p><p>正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。</p><p>方括号，方括号用于查找某个范围内的字符：</p><table><thead><tr><th align="center">表达式</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>[abc]</code></td><td>查找方括号之间的任何字符。</td></tr><tr><td align="center"><code>[^abc]</code></td><td>查找任何不在方括号之间的字符。</td></tr><tr><td align="center"><code>[0-9]</code></td><td>查找任何从 0 至 9 的数字。</td></tr><tr><td align="center"><code>[a-z]</code></td><td>查找任何从小写 a 到小写 z 的字符。</td></tr><tr><td align="center"><code>[A-Z]</code></td><td>查找任何从大写 A 到大写 Z 的字符。</td></tr><tr><td align="center"><code>[A-z]</code></td><td>查找任何从大写 A 到小写 z 的字符。</td></tr><tr><td align="center"><code>[adgk]</code></td><td>查找给定集合内的任何字符。</td></tr><tr><td align="center"><code>[^adgk]</code></td><td>查找给定集合外的任何字符。</td></tr><tr><td align="center">`(red</td><td>blue</td></tr></tbody></table><p>元字符，元字符（Metacharacter）是拥有特殊含义的字符：</p><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>.</code></td><td>查找单个字符，除了换行和行结束符。</td></tr><tr><td align="center"><code>\w</code></td><td>查找单词字符。</td></tr><tr><td align="center"><code>\W</code></td><td>查找非单词字符。</td></tr><tr><td align="center"><code>\d</code></td><td>查找数字。</td></tr><tr><td align="center"><code>\D</code></td><td>查找非数字字符。</td></tr><tr><td align="center"><code>\s</code></td><td>查找空白字符。</td></tr><tr><td align="center"><code>\S</code></td><td>查找非空白字符。</td></tr><tr><td align="center"><code>\b</code></td><td>匹配单词边界。</td></tr><tr><td align="center"><code>\B</code></td><td>匹配非单词边界。</td></tr><tr><td align="center"><code>\0</code></td><td>查找 NUL 字符。</td></tr><tr><td align="center"><code>\n</code></td><td>查找换行符。</td></tr><tr><td align="center"><code>\f</code></td><td>查找换页符。</td></tr><tr><td align="center"><code>\r</code></td><td>查找回车符。</td></tr><tr><td align="center"><code>\t</code></td><td>查找制表符。</td></tr><tr><td align="center"><code>\v</code></td><td>查找垂直制表符。</td></tr><tr><td align="center"><code>\xxx</code></td><td>查找以八进制数 xxx 规定的字符。</td></tr><tr><td align="center"><code>\xdd</code></td><td>查找以十六进制数 dd 规定的字符。</td></tr><tr><td align="center"><code>\uxxxx</code></td><td>查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><p>量词</p><table><thead><tr><th align="center">量词</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>n+</code></td><td>匹配任何包含至少一个 n 的字符串。</td></tr><tr><td align="center"><code>n*</code></td><td>匹配任何包含零个或多个 n 的字符串。</td></tr><tr><td align="center"><code>n?</code></td><td>匹配任何包含零个或一个 n 的字符串。</td></tr><tr><td align="center"><code>n{X}</code></td><td>匹配包含 X 个 n 的序列的字符串。</td></tr><tr><td align="center"><code>n{X,Y}</code></td><td>匹配包含 X 至 Y 个 n 的序列的字符串。</td></tr><tr><td align="center"><code>n{X,}</code></td><td>匹配包含至少 X 个 n 的序列的字符串。</td></tr><tr><td align="center"><code>n$</code></td><td>匹配任何结尾为 n 的字符串。</td></tr><tr><td align="center"><code>^n</code></td><td>匹配任何开头为 n 的字符串。</td></tr><tr><td align="center"><code>?=n</code></td><td>匹配任何其后紧接指定字符串 n 的字符串。</td></tr><tr><td align="center"><code>?!n</code></td><td>匹配任何其后没有紧接指定字符串 n 的字符串。</td></tr></tbody></table><h4 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">compile</td><td>编译正则表达式。</td></tr><tr><td align="center">exec</td><td>检索字符串中指定的值。返回找到的值，并确定其位置。</td></tr><tr><td align="center">test</td><td>检索字符串中指定的值。返回 true 或 false。</td></tr></tbody></table><ul><li>支持正则表达式的 String 对象的方法</li></ul><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">search</td><td>检索与正则表达式相匹配的值。</td></tr><tr><td align="center">match</td><td>找到一个或多个正则表达式的匹配。</td></tr><tr><td align="center">replace</td><td>替换与正则表达式匹配的子串。</td></tr><tr><td align="center">split</td><td>把字符串分割为字符串数组。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。&lt;/p&gt;&lt;p&gt;&lt;code&gt;var
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript String对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/30/JavaScript-String%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/30/JavaScript-String对象属性与方法/</id>
    <published>2019-09-30T01:13:25.000Z</published>
    <updated>2019-09-30T06:33:27.008Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><p>String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，因此下面两种字符串的写法都是有效的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var firstName = &quot;Nicholas&quot;;</span><br><span class="line">var lastName = &apos;Zakas&apos;;</span><br></pre></td></tr></table></figure><p>字符字面量，String数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。</p><table><thead><tr><th align="center">字面量</th><th>含义</th></tr></thead><tbody><tr><td align="center"><code>\n</code></td><td>换行</td></tr><tr><td align="center"><code>\t</code></td><td>制表</td></tr><tr><td align="center"><code>\b</code></td><td>空格</td></tr><tr><td align="center"><code>\r</code></td><td>回车</td></tr><tr><td align="center"><code>\f</code></td><td>换页符</td></tr><tr><td align="center"><code>\\</code></td><td>斜杆</td></tr><tr><td align="center"><code>\&#39;</code></td><td>单引号（’）,在用单引号表示的字符串中使用。</td></tr><tr><td align="center"><code>\&quot;</code></td><td>双引号（”）,在用双引号表示的字符串中使用。</td></tr><tr><td align="center"><code>\xnn</code></td><td>以十六进制代码nn表示的一个字符（其中n为0~F）。例如，\x41表示”A”</td></tr><tr><td align="center"><code>\unnnn</code></td><td>以十六进制代码nnnn表示的一个Unicode字符（其中n为0~F）。例如，\u03a3表示希腊字符Σ</td></tr></tbody></table><p>String 对象<br>String 对象用于处理文本（字符串）。</p><p>String 对象创建方法： new String().</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var txt = new String(&quot;string&quot;);</span><br><span class="line">或者更简单方式：</span><br><span class="line">var txt = &quot;string&quot;;</span><br></pre></td></tr></table></figure><h4 id="String-对象属性"><a href="#String-对象属性" class="headerlink" title="String 对象属性"></a>String 对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">constructor</td><td>对创建该对象的函数的引用</td></tr><tr><td align="center">length</td><td>字符串的长度</td></tr><tr><td align="center">prototype</td><td>允许您向对象添加属性和方法</td></tr></tbody></table><h4 id="String-对象方法"><a href="#String-对象方法" class="headerlink" title="String 对象方法"></a>String 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">charAt()</td><td>返回在指定位置的字符。</td></tr><tr><td align="center">charCodeAt()</td><td>返回在指定的位置的字符的 Unicode 编码。</td></tr><tr><td align="center">concat()</td><td>连接两个或更多字符串，并返回新的字符串。</td></tr><tr><td align="center">fromCharCode()</td><td>将 Unicode 编码转为字符。</td></tr><tr><td align="center">indexOf()</td><td>返回某个指定的字符串值在字符串中首次出现的位置。</td></tr><tr><td align="center">lastIndexOf()</td><td>从后向前搜索字符串。</td></tr><tr><td align="center">match()</td><td>查找找到一个或多个正则表达式的匹配。</td></tr><tr><td align="center">replace()</td><td>在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串。</td></tr><tr><td align="center">search()</td><td>查找与正则表达式相匹配的值。</td></tr><tr><td align="center">slice()</td><td>提取字符串的片断，并在新的字符串中返回被提取的部分。</td></tr><tr><td align="center">split()</td><td>把字符串分割为字符串数组。</td></tr><tr><td align="center">substr()</td><td>从起始索引号提取字符串中指定数目的字符。</td></tr><tr><td align="center">substring()</td><td>提取字符串中两个指定的索引号之间的字符。</td></tr><tr><td align="center">toLowerCase()</td><td>把字符串转换为小写。</td></tr><tr><td align="center">toUpperCase()</td><td>把字符串转换为大写。</td></tr><tr><td align="center">trim()</td><td>去除字符串两边的空白</td></tr><tr><td align="center">valueOf()</td><td>返回某个字符串对象的原始值。</td></tr></tbody></table><h4 id="String-HTML-包装方法"><a href="#String-HTML-包装方法" class="headerlink" title="String HTML 包装方法"></a>String HTML 包装方法</h4><p>HTML 包装方法返回加入了适当HTML标签的字符串。</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">anchor()</td><td>创建 HTML 锚。</td></tr><tr><td align="center">big()</td><td>用大号字体显示字符串。</td></tr><tr><td align="center">blink()</td><td>显示闪动字符串。</td></tr><tr><td align="center">bold()</td><td>使用粗体显示字符串。</td></tr><tr><td align="center">fixed()</td><td>以打字机文本显示字符串。</td></tr><tr><td align="center">fontcolor()</td><td>使用指定的颜色来显示字符串。</td></tr><tr><td align="center">fontsize()</td><td>使用指定的尺寸来显示字符串。</td></tr><tr><td align="center">italics()</td><td>使用斜体显示字符串。</td></tr><tr><td align="center">link()</td><td>将字符串显示为链接。</td></tr><tr><td align="center">small()</td><td>使用小字号来显示字符串。</td></tr><tr><td align="center">strike()</td><td>用于显示加删除线的字符串。</td></tr><tr><td align="center">sub()</td><td>把字符串显示为下标。</td></tr><tr><td align="center">sup()</td><td>把字符串显示为上标。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，因此下面两种字符
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Number对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/28/JavaScript-Number%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/28/JavaScript-Number对象属性与方法/</id>
    <published>2019-09-28T01:32:02.000Z</published>
    <updated>2019-09-28T01:55:56.788Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><p>Number是数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递响应的数值。</p><p><code>var numberObject = new Number(value);</code></p><p>注意：如果一个采纳数值不能转换为一个数字将返回NaN（非数字值）。</p><p>Number对象，Number对象是原始数值的包装对象。</p><h4 id="Number对象属性"><a href="#Number对象属性" class="headerlink" title="Number对象属性"></a>Number对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">constructor</td><td>返回对创建此对象的 Number 函数的引用。</td></tr><tr><td align="center">MAX_VALUE</td><td>可表示的最大的数。</td></tr><tr><td align="center">MIN_VALUE</td><td>可表示的最小的数。</td></tr><tr><td align="center">NEGATIVE_INFINITY</td><td>负无穷大，溢出时返回该值。</td></tr><tr><td align="center">NaN</td><td>非数字值。</td></tr><tr><td align="center">POSITIVE_INFINITY</td><td>正无穷大，溢出时返回该值。</td></tr><tr><td align="center">prototype</td><td>允许您有能力向对象添加属性和方法。</td></tr></tbody></table><h4 id="Number对象方法"><a href="#Number对象方法" class="headerlink" title="Number对象方法"></a>Number对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">toExponential(x)</td><td>把对象的值转换为指数计数法。</td></tr><tr><td align="center">toFixed(x)</td><td>把数字转换为字符串，结果的小数点后有指定位数的数字。</td></tr><tr><td align="center">toPrecision(x)</td><td>把数字格式化为指定的长度。</td></tr><tr><td align="center">toString()</td><td>把数字转换为字符串，使用指定的基数。</td></tr><tr><td align="center">valueOf()</td><td>返回一个 Number 对象的基本数字值。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var numberObject = new Number(10)</span><br><span class="line"></span><br><span class="line">console.log(&quot;toExponential(x) Number对象方法：&quot; + numberObject.toExponential(1));</span><br><span class="line"></span><br><span class="line">numberObject = 12.54</span><br><span class="line"></span><br><span class="line">console.log(&quot;toFixed() Number对象方法：&quot; + numberObject.toFixed(0));</span><br><span class="line"></span><br><span class="line">console.log(&quot;toPrecision() Number对象方法：&quot; + numberObject.toPrecision(3));</span><br><span class="line"></span><br><span class="line">console.log(&quot;toString() Number对象方法：&quot; + numberObject.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;valueOf() Number对象方法：&quot; + numberObject.valueOf());</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Number是数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递响应的数值。&lt;/p&gt;&lt;p&gt;&lt;code&gt;va
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Math对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/28/JavaScript-Math%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/28/JavaScript-Math对象属性与方法/</id>
    <published>2019-09-27T23:58:00.000Z</published>
    <updated>2019-09-28T01:26:30.781Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><p>ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。与我们再JavaScript直接编写的计算功能相比，Math对象提供的计算功能执行起来要快很多。Math对象还提供了辅助完成这些计算的属性和方法。</p><p>Math 对象</p><p>Math对象用于执行数学任务。<br>Math对象并不像Date和String那样是对象的类，因此没有构造函数Math()。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = Math.PI; // 返回圆周率</span><br><span class="line">var y = Math.sprt(16); //返回16的平方根</span><br></pre></td></tr></table></figure><h4 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h4><p>Math对象包含的属性大都是数学计算中可能会用到的一些特殊值。</p><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">E</td><td>返回算术常量 e，即自然对数的底数（约等于2.718）。</td></tr><tr><td align="center">LN2</td><td>返回 2 的自然对数（约等于0.693）。</td></tr><tr><td align="center">LN10</td><td>返回 10 的自然对数（约等于2.302）。</td></tr><tr><td align="center">LOG2E</td><td>返回以 2 为底的 e 的对数（约等于 1.414）。</td></tr><tr><td align="center">LOG10E</td><td>返回以 10 为底的 e 的对数（约等于0.434）。</td></tr><tr><td align="center">PI</td><td>返回圆周率（约等于3.14159）。</td></tr><tr><td align="center">SQRT1_2</td><td>返回返回 2 的平方根的倒数（约等于 0.707）。</td></tr><tr><td align="center">SQRT2</td><td>返回 2 的平方根（约等于 1.414）。</td></tr></tbody></table><h4 id="Math-对象方法"><a href="#Math-对象方法" class="headerlink" title="Math 对象方法"></a>Math 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">abs(x)</td><td>返回 x 的绝对值。</td></tr><tr><td align="center">acos(x)</td><td>返回 x 的反余弦值。</td></tr><tr><td align="center">asin(x)</td><td>返回 x 的反正弦值。</td></tr><tr><td align="center">atan(x)</td><td>以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td></tr><tr><td align="center">atan2(y,x)</td><td>返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。</td></tr><tr><td align="center">ceil(x)</td><td>对数进行上舍入。</td></tr><tr><td align="center">cos(x)</td><td>返回数的余弦。</td></tr><tr><td align="center">exp(x)</td><td>返回 Ex 的指数。</td></tr><tr><td align="center">floor(x)</td><td>对 x 进行下舍入。</td></tr><tr><td align="center">log(x)</td><td>返回数的自然对数（底为e）。</td></tr><tr><td align="center">max(x,y,z,…,n)</td><td>返回 x,y,z,…,n 中的最高值。</td></tr><tr><td align="center">min(x,y,z,…,n)</td><td>返回 x,y,z,…,n中的最低值。</td></tr><tr><td align="center">pow(x,y)</td><td>返回 x 的 y 次幂。</td></tr><tr><td align="center">random()</td><td>返回 0 ~ 1 之间的随机数。</td></tr><tr><td align="center">round(x)</td><td>把数四舍五入为最接近的整数。</td></tr><tr><td align="center">sin(x)</td><td>返回数的正弦。</td></tr><tr><td align="center">sqrt(x)</td><td>返回数的平方根。</td></tr><tr><td align="center">tan(x)</td><td>返回角的正切。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;abs() Math对象方法：&quot; + Math.abs(-444));</span><br><span class="line"></span><br><span class="line">console.log(&quot;acos() Math对象方法：&quot; + Math.acos(0.5));</span><br><span class="line"></span><br><span class="line">console.log(&quot;asin() Math对象方法：&quot; + Math.asin(0.5));</span><br><span class="line"></span><br><span class="line">console.log(&quot;atan() Math对象方法：&quot; + Math.atan(1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;atan2() Math对象方法：&quot; + Math.atan2(1, 1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;cos() Math对象方法：&quot; + Math.cos(0.5));</span><br><span class="line"></span><br><span class="line">console.log(&quot;sin() Math对象方法：&quot; + Math.sin(0.5));</span><br><span class="line"></span><br><span class="line">console.log(&quot;tan() Math对象方法：&quot; + Math.tan(2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;ceil() Math对象方法：&quot; + Math.ceil(1.1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;floor() Math对象方法：&quot; + Math.floor(2.1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;round(x) Math对象方法：&quot; + Math.round(6.5));</span><br><span class="line"></span><br><span class="line">console.log(&quot;exp(x) Math对象方法：&quot; + Math.exp(2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;log(x) Math对象方法：&quot; + Math.log(2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;sqrt(x) Math对象方法：&quot; + Math.sqrt(4));</span><br><span class="line"></span><br><span class="line">console.log(&quot;pow(x,y) Math对象方法：&quot; + Math.pow(1,2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;max(x,y) Math对象方法：&quot; + Math.max(1,2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;min(x,y) Math对象方法：&quot; + Math.min(1,2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;random() Math对象方法：&quot; + Math.random());</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。与我们再JavaScript直接编写的计算功能相比，Math对象提
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Date对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/27/JavaScript-Date%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/27/JavaScript-Date对象属性与方法/</id>
    <published>2019-09-27T07:12:06.000Z</published>
    <updated>2019-09-27T08:22:10.316Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><p>ECMAScript在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC时间1970年1月1日午夜起至该日期止的毫秒数）。</p><p>Date 对象，Date 对象用于处理日期和时间。</p><p>创建 Date 对象的语法：</p><p><code>var myDate=new Date()</code></p><p>注释：Date 对象会自动把当前日期和时间保存为其初始值。</p><h4 id="Date-对象属性"><a href="#Date-对象属性" class="headerlink" title="Date 对象属性"></a>Date 对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">constructor</td><td>返回对创建此对象的 Date 函数的引用。</td></tr><tr><td align="center">prototype</td><td>使您有能力向对象添加属性和方法。</td></tr></tbody></table><h4 id="Date-对象方法"><a href="#Date-对象方法" class="headerlink" title="Date 对象方法"></a>Date 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">Date()</td><td>返回当日的日期和时间。</td></tr><tr><td align="center">getDate()</td><td>从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td></tr><tr><td align="center">getDay()</td><td>从 Date 对象返回一周中的某一天 (0 ~ 6)。</td></tr><tr><td align="center">getMonth()</td><td>从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td align="center">getFullYear()</td><td>从 Date 对象以四位数字返回年份。</td></tr><tr><td align="center">getYear()</td><td>请使用 getFullYear() 方法代替。</td></tr><tr><td align="center">getHours()</td><td>返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td align="center">getMinutes()</td><td>返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td align="center">getSeconds()</td><td>返回 Date 对象的秒数 (0 ~ 59)。</td></tr><tr><td align="center">getMilliseconds()</td><td>返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td align="center">getTime()</td><td>返回 1970 年 1 月 1 日至今的毫秒数。</td></tr><tr><td align="center">getTimezoneOffset()</td><td>返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td></tr><tr><td align="center">getUTCDate()</td><td>根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td></tr><tr><td align="center">getUTCDay()</td><td>根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td></tr><tr><td align="center">getUTCMonth()</td><td>根据世界时从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td align="center">getUTCFullYear()</td><td>根据世界时从 Date 对象返回四位数的年份。</td></tr><tr><td align="center">getUTCHours()</td><td>根据世界时返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td align="center">getUTCMinutes()</td><td>根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td align="center">getUTCSeconds()</td><td>根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td></tr><tr><td align="center">getUTCMilliseconds()</td><td>根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td align="center">parse()</td><td>返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td></tr><tr><td align="center">setDate()</td><td>设置 Date 对象中月的某一天 (1 ~ 31)。</td></tr><tr><td align="center">setMonth()</td><td>设置 Date 对象中月份 (0 ~ 11)。</td></tr><tr><td align="center">setFullYear()</td><td>设置 Date 对象中的年份（四位数字）。</td></tr><tr><td align="center">setYear()</td><td>请使用 setFullYear() 方法代替。</td></tr><tr><td align="center">setHours()</td><td>设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td align="center">setMinutes()</td><td>设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td align="center">setSeconds()</td><td>设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td align="center">setMilliseconds()</td><td>设置 Date 对象中的毫秒 (0 ~ 999)。</td></tr><tr><td align="center">setTime()</td><td>以毫秒设置 Date 对象。</td></tr><tr><td align="center">setUTCDate()</td><td>根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td></tr><tr><td align="center">setUTCMonth()</td><td>根据世界时设置 Date 对象中的月份 (0 ~ 11)。</td></tr><tr><td align="center">setUTCFullYear()</td><td>根据世界时设置 Date 对象中的年份（四位数字）。</td></tr><tr><td align="center">setUTCHours()</td><td>根据世界时设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td align="center">setUTCMinutes()</td><td>根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td align="center">setUTCSeconds()</td><td>根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td align="center">setUTCMilliseconds()</td><td>根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</td></tr><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">toString()</td><td>把 Date 对象转换为字符串。</td></tr><tr><td align="center">toTimeString()</td><td>把 Date 对象的时间部分转换为字符串。</td></tr><tr><td align="center">toDateString()</td><td>把 Date 对象的日期部分转换为字符串。</td></tr><tr><td align="center">toGMTString()</td><td>请使用 toUTCString() 方法代替。</td></tr><tr><td align="center">toUTCString()</td><td>根据世界时，把 Date 对象转换为字符串。</td></tr><tr><td align="center">toLocaleString()</td><td>根据本地时间格式，把 Date 对象转换为字符串。</td></tr><tr><td align="center">toLocaleTimeString()</td><td>根据本地时间格式，把 Date 对象的时间部分转换为字符串。</td></tr><tr><td align="center">toLocaleDateString()</td><td>根据本地时间格式，把 Date 对象的日期部分转换为字符串。</td></tr><tr><td align="center">UTC()</td><td>根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</td></tr><tr><td align="center">valueOf()</td><td>返回 Date 对象的原始值。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line"></span><br><span class="line">console.log(&quot;Date() Date对象方法：&quot; + date);</span><br><span class="line"></span><br><span class="line">console.log(&quot;getDate() Date对象方法：&quot; + date.getDate());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getDay() Date对象方法：&quot; + date.getDay());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getMonth() Date对象方法：&quot; + (date.getMonth() + 1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;getFullYear() Date对象方法：&quot; + date.getFullYear());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getHours() Date对象方法：&quot; + date.getHours());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getMinutes() Date对象方法：&quot; + date.getMinutes());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getSeconds() Date对象方法：&quot; + date.getSeconds());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getMilliseconds() Date对象方法：&quot; + date.getMilliseconds());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getTimezoneOffset() Date对象方法：&quot; + date.getTimezoneOffset());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCDate() Date对象方法：&quot; + date.getUTCDate());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCDay() Date对象方法：&quot; + date.getUTCDay());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCMonth() Date对象方法：&quot; + (date.getUTCMonth() + 1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCFullYear() Date对象方法：&quot; + date.getUTCFullYear());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCHours() Date对象方法：&quot; + date.getUTCHours());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCMinutes() Date对象方法：&quot; + date.getUTCMinutes());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCSeconds() Date对象方法：&quot; + date.getUTCSeconds());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCMilliseconds() Date对象方法：&quot; + date.getUTCMilliseconds());</span><br><span class="line"></span><br><span class="line">console.log(&quot;setDate() Date对象方法：&quot; + date.setDate(15));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setMonth() Date对象方法：&quot; + date.setMonth(2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setFullYear() Date对象方法：&quot; + date.setFullYear(2017));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setHours() Date对象方法：&quot; + date.setHours(12));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setMinutes() Date对象方法：&quot; + date.setMinutes(45));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setSeconds() Date对象方法：&quot; + date.setSeconds(50));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setMilliseconds() Date对象方法：&quot; + date.setMilliseconds(999));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCDate() Date对象方法：&quot; + date.setUTCDate(22));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCMonth() Date对象方法：&quot; + date.setUTCMonth(3));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCFullYear() Date对象方法：&quot; + date.setUTCFullYear(2015));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCHours() Date对象方法：&quot; + date.setUTCHours(0));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCMinutes() Date对象方法：&quot; + date.setUTCMinutes(59));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCSeconds() Date对象方法：&quot; + date.setUTCSeconds(59));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCMilliseconds() Date对象方法：&quot; + date.setUTCMilliseconds(999));</span><br><span class="line"></span><br><span class="line">console.log(date)</span><br><span class="line"></span><br><span class="line">// console.log(&quot;toSource() Date对象方法：&quot; + date.toSource());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toString() Date对象方法：&quot; + typeof(date.toString()) + &quot; &quot; + date.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toTimeString() Date对象方法：&quot; + date.toTimeString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toDateString() Date对象方法：&quot; + date.toDateString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toGMTString() Date对象方法：&quot; + date.toGMTString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toUTCString() Date对象方法：&quot; + date.toUTCString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toLocaleString() Date对象方法：&quot; + date.toLocaleString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toLocaleTimeString() Date对象方法：&quot; + date.toLocaleTimeString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toLocaleDateString() Date对象方法：&quot; + date.toLocaleDateString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;UTC() Date对象方法：&quot; + Date.UTC(2014,12,1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;valueOf() Date对象方法：&quot; + date.valueOf());</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;ECMAScript在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Boolean对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/27/JavaScript-Boolean%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/27/JavaScript-Boolean对象属性与方法/</id>
    <published>2019-09-27T07:08:21.000Z</published>
    <updated>2019-09-27T07:10:23.173Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --><p>Boolean 对象，Boolean 对象表示两个值：”true” 或 “false”。</p><p>创建 Boolean 对象的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Boolean(value);//构造函数</span><br><span class="line">Boolean(value);//转换函数</span><br></pre></td></tr></table></figure><p>参数</p><p>参数 value 由布尔对象存放的值或者要转换成布尔值的值。</p><p>返回值</p><p>当作为一个构造函数（带有运算符 new）调用时，Boolean() 将把它的参数转换成一个布尔值，并且返回一个包含该值的 Boolean 对象。</p><p>如果作为一个函数（不带有运算符 new）调用时，Boolean() 只将把它的参数转换成一个原始的布尔值，并且返回这个值。</p><p>注释：如果省略 value 参数，或者设置为 0、-0、null、””、false、undefined 或 NaN，则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 “false”）。</p><h4 id="Boolean-对象属性"><a href="#Boolean-对象属性" class="headerlink" title="Boolean 对象属性"></a>Boolean 对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">constructor</td><td>返回对创建此对象的 Boolean 函数的引用</td></tr><tr><td align="center">prototype</td><td>使您有能力向对象添加属性和方法。</td></tr></tbody></table><h4 id="Boolean-对象方法"><a href="#Boolean-对象方法" class="headerlink" title="Boolean 对象方法"></a>Boolean 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">toString()</td><td>把逻辑值转换为字符串，并返回结果。</td></tr><tr><td align="center">valueOf()</td><td>返回 Boolean 对象的原始值。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Boolean 对象，Boolean 对象表示两个值：”true” 或 “false”。&lt;/p&gt;&lt;p&gt;创建 Boolean 对象的语法：&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Array对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/27/JavaScript-Array%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/27/JavaScript-Array对象属性与方法/</id>
    <published>2019-09-27T06:40:43.000Z</published>
    <updated>2019-09-27T06:40:52.861Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --><p>除了Object之外，Array类型恐怕是ECMAScrip中最常用的类型了。而且，ECMAScript中的数组与其他多数语言中的数组有着很大的区别。虽然ECMAScript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，EMCAScript数组的每一项可以保存任何类型的数据。也就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象，以此类推。而且，ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。</p><p>JavaScript 本地对象和内置对象。</p><p>Array 对象，Array 对象用于在单个的变量中存储多个值。</p><p>创建Array对象的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Array();</span><br><span class="line">new Array(size);</span><br><span class="line">new Array(element0,element1m,...,elementn);</span><br></pre></td></tr></table></figure><p>参数</p><p>参数size是期望数组元素个数。返回的数组，length字段将被设为size的值。<br>参数element…,elementn是参数列表。当使用这些参数来调用构造函数Array()时，新创建的数组的元素就会被初始化为这些值。它的length字段也会被设置为参数的个数。</p><p>返回值</p><p>返回新创建并被初始化了的数组。<br>如果调用构造函数Array()时没有使用参数，那么返回的数组为空，length字段未0。<br>当调用构造函数时只传递给它一个数字参数，该构造函数将返回具有指定个数、元素为undefined的数组。<br>当其他参数调用Array()时，该构造函数将用参数指定的值初始化数组。<br>当把构造函数作为函数调用，不使用 new 运算符时，它的行为与使用 new 运算符调用它时的行为完全一样。</p><h4 id="Array-对象属性"><a href="#Array-对象属性" class="headerlink" title="Array 对象属性"></a>Array 对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">constructor</td><td>返回对创建此对象的数组函数的引用。</td></tr><tr><td align="center">length</td><td>设置或返回数组中元素的数目。</td></tr><tr><td align="center">prototype</td><td>使您有能力向对象添加属性和方法。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var obj = new Array();</span><br><span class="line"></span><br><span class="line">obj = [&quot;ab&quot;,2,3,5,6,7,8,9,10];</span><br><span class="line"></span><br><span class="line">console.log(&quot;new Array() 创建数组：&quot;+obj);</span><br><span class="line"></span><br><span class="line">var type = Array.isArray(obj);</span><br><span class="line"></span><br><span class="line">console.log(&quot;Array.isArray(obj) 检测数组类型：&quot; + type);</span><br><span class="line"></span><br><span class="line">console.log(&quot;constructor 数组属性：&quot;+obj.constructor);</span><br><span class="line"></span><br><span class="line">console.log(&quot;length 数组属性：&quot; + obj.length);</span><br><span class="line"></span><br><span class="line">Array.prototype.name = 10</span><br><span class="line"></span><br><span class="line">Array.prototype.changed = function () &#123;</span><br><span class="line">    for(var i = 0; i &lt; this.length; i++ )&#123;</span><br><span class="line">        var tp = typeof(this[i]);</span><br><span class="line">        if(tp === &quot;string&quot;)&#123;</span><br><span class="line">            this[i] = this[i].toUpperCase();</span><br><span class="line">        &#125;</span><br><span class="line">        if(tp === &quot;number&quot;)&#123;</span><br><span class="line">            this[i] = this[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            this[i] = this[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.changed();</span><br><span class="line">console.log(&quot;prototype 数组属性：&quot; + obj.name + &quot;|&quot; + obj);</span><br></pre></td></tr></table></figure><h3 id="Array对象方法"><a href="#Array对象方法" class="headerlink" title="Array对象方法"></a>Array对象方法</h3><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">concat()</td><td>连接两个或更多的数组，不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</td></tr><tr><td align="center">join()</td><td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td></tr><tr><td align="center">pop()</td><td>删除并返回数组的最后一个元素。</td></tr><tr><td align="center">push()</td><td>向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="center">reverse()</td><td>颠倒数组中元素的顺序。</td></tr><tr><td align="center">shift()</td><td>删除并返回数组的第一个元素。</td></tr><tr><td align="center">slice()</td><td>从某个已有的数组返回选定的元素。</td></tr><tr><td align="center">sort()</td><td>对数组的元素进行排序。</td></tr><tr><td align="center">splice()</td><td>删除元素，并向数组添加新元素。</td></tr><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">toString()</td><td>把数组转换为字符串，并返回结果。</td></tr><tr><td align="center">toLocaleString()</td><td>把数组转换为本地数组，并返回结果。</td></tr><tr><td align="center">unshift()</td><td>向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="center">valueOf()</td><td>返回数组对象的原始值。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var a = Array(&quot;张三&quot;, &quot;李四&quot;);</span><br><span class="line"></span><br><span class="line">var b = new Array(&quot;王五&quot;, &quot;陈六&quot;);</span><br><span class="line"></span><br><span class="line">var c = a.concat(b)</span><br><span class="line"></span><br><span class="line">console.log(&quot;concat() 数组方法：原始值——&quot; + a + &quot;|返回值——&quot; + c);</span><br><span class="line"></span><br><span class="line">console.log(&quot;join() 数组方法：&quot; + c.join(&apos;|&apos;));</span><br><span class="line"></span><br><span class="line">console.log(&quot;pop() 数组方法：&quot; + c.pop() + &quot;|删除后的值——&quot; + c);</span><br><span class="line"></span><br><span class="line">console.log(&quot;push() 数组方法：&quot; + c.push(&quot;赵七&quot;) + &quot;|追加后的值——&quot; + c);</span><br><span class="line"></span><br><span class="line">console.log(&quot;reverse() 数组方法：&quot; + c.reverse());</span><br><span class="line"></span><br><span class="line">console.log(&quot;shift() 数组方法：&quot; + c.shift() + &quot;|删除后的值——&quot; + c);</span><br><span class="line"></span><br><span class="line">console.log(&quot;slice() 数组方法：&quot; + c.slice(-2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;sort() 数组方法：&quot; + c.sort());</span><br><span class="line"></span><br><span class="line">console.log(&quot;splice() 数组方法：&quot; + c.splice(2,1,&quot;替换&quot;) + &quot;|删除后的值——&quot; + c);</span><br><span class="line"></span><br><span class="line">// 只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。</span><br><span class="line">// console.log(&quot;toSource() 数组方法：&quot; + c.toSource());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toString() 数组方法：&quot; + typeof(c.toString()) + &quot; | &quot; + typeof(c));</span><br><span class="line"></span><br><span class="line">console.log(&quot;toLocaleString() 数组方法：&quot; + typeof(c.toLocaleString()) + &quot; | &quot; + typeof(c));</span><br><span class="line"></span><br><span class="line">console.log(&quot;unshift() 数组方法：&quot; + c.unshift(&quot;开头&quot;,&quot;添加&quot;) + &quot;添加后的值——&quot; + c);</span><br><span class="line"></span><br><span class="line">console.log(&quot;valueOf() 数组方法：&quot; + c.valueOf());</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:08 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;除了Object之外，Array类型恐怕是ECMAScrip中最常用的类型了。而且，ECMAScript中的数组与其他多数语言中的数组有着很大的
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 继承</title>
    <link href="https://liushuai97.github.io/2019/09/25/JavaScript-%E7%BB%A7%E6%89%BF/"/>
    <id>https://liushuai97.github.io/2019/09/25/JavaScript-继承/</id>
    <published>2019-09-25T02:18:24.000Z</published>
    <updated>2019-09-25T02:53:36.911Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>在 js 中, 方法定义在原型对象中, 而属性定义在实例对象中,调用方法的时候, 实例对象本身是没有该成员的, 但是依旧可以调用该方法, 好像这个方法就是该实例对象的一样. 因此, 我们称该实例对象继承自原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var Person=&#123;</span><br><span class="line">  sayHello:function()&#123;</span><br><span class="line">    console.log(&apos;我是&apos;+this.name+&apos;今年&apos;+this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//student构造函数</span><br><span class="line">function Student(name,age)&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里把Person对象赋值到Student构造函数的原型对象上，这样Student构造函数的实例就可以运用Person对象的方法</span><br><span class="line">Student.prototype=Person;</span><br><span class="line"></span><br><span class="line">//根据Student构造函数创建一个实例对象s1.</span><br><span class="line">var s1=new Student(&apos;lilei&apos;,18);</span><br><span class="line"></span><br><span class="line">s1.sayHello();</span><br></pre></td></tr></table></figure><h4 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h4><p>就是将一个对象中的成员加到另一个对象中（通过自定义 extend 方法完成继承）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var obj2= &#123;</span><br><span class="line">  name:&apos;lilei&apos;,</span><br><span class="line">  sayHello:function()&#123;</span><br><span class="line">      console.log(&apos;我是&apos;+this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj3= &#123;</span><br><span class="line">  age:18,</span><br><span class="line">  sayHello1:function()&#123;</span><br><span class="line">    console.log(&apos;我是&apos;+this.name+&apos;今年&apos;+this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1=&#123;</span><br><span class="line">  extend:function(obj)&#123;</span><br><span class="line"></span><br><span class="line">    //arguments为函数中默认的对象，里面存储着所有的函数传入参数。</span><br><span class="line">    for(var i=0; i&lt; arguments.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">      for(var k in arguments[i])&#123;</span><br><span class="line">          this[k]=arguments[i][k];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//将obj2和obj3混入到obj1中</span><br><span class="line">obj1.extend(obj2,obj3);</span><br><span class="line"></span><br><span class="line">obj1.sayHello();</span><br><span class="line"></span><br><span class="line">obj1.sayHello1();</span><br></pre></td></tr></table></figure><h4 id="混合式继承"><a href="#混合式继承" class="headerlink" title="混合式继承"></a>混合式继承</h4><p>将多个对象的各个功能混合在一起，就是通过混入的方式，加到构造函数的原型（prototype）上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var Person=&#123;</span><br><span class="line">    sayHello:function()&#123;</span><br><span class="line">      console.log(&apos;我是&apos;+this.name+&apos;今年&apos;+this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Student(name,age)&#123;//student构造函数</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.extend=function(obj)&#123;</span><br><span class="line">  for(var k in obj)&#123;</span><br><span class="line">    this[k]=obj[k];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据Student构造函数创建一个实例对象s1.</span><br><span class="line">var s1=new Student(&apos;lilei&apos;,18);</span><br><span class="line"></span><br><span class="line">// 根据Student构造函数创建一个实例对象s2.</span><br><span class="line">var s2=new Student(&apos;lllli&apos;,18);</span><br><span class="line"></span><br><span class="line">// 这样就是Student构造函数继承了Person对象。所有Student构造函数创建的实例都要Pserson对象的方法</span><br><span class="line">Student.prototype.extend(Person);</span><br><span class="line"></span><br><span class="line">// 这样就是Student构造函数的实例s1继承了Person对象。其他Student构造函数创建的实例都没有Pserson对象的方法</span><br><span class="line">// s1.extend(Person);</span><br><span class="line"></span><br><span class="line">s1.sayHello();</span><br><span class="line">s2.sayHello();</span><br></pre></td></tr></table></figure><ul><li>关于继承 ES5 中给我们内置了一个快速的方法：Object.create(对象)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">  name:&apos;lilei&apos;,</span><br><span class="line">  age:16,</span><br><span class="line">  sayHello:function()&#123;</span><br><span class="line">    console.log(&apos;我是&apos;+this.name+&apos;今年&apos;+this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ES5中内置的Object.create()方法可以让我们快速的继承</span><br><span class="line">var obj=Object.create(o);</span><br><span class="line"></span><br><span class="line">obj.sayHello();</span><br></pre></td></tr></table></figure><h4 id="上下文调用实现继承"><a href="#上下文调用实现继承" class="headerlink" title="上下文调用实现继承"></a>上下文调用实现继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var Person=&#123;</span><br><span class="line">  sayHello:function()&#123;</span><br><span class="line">    console.log(&apos;我是&apos;+this.name+&apos;今年&apos;+this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Student(name,age)&#123;//student构造函数</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//根据Student构造函数创建一个实例对象s1.</span><br><span class="line">var s1=new Student(&apos;lilei&apos;,18);</span><br><span class="line"></span><br><span class="line">//根据Student构造函数创建一个实例对象s2.</span><br><span class="line">var s2=new Student(&apos;lllli&apos;,18);</span><br><span class="line"></span><br><span class="line">Person.sayHello.call(s2)；</span><br></pre></td></tr></table></figure><h4 id="ES6-的继承"><a href="#ES6-的继承" class="headerlink" title="ES6 的继承"></a>ES6 的继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// es6继承</span><br><span class="line">class Animal &#123;</span><br><span class="line"></span><br><span class="line">  //构造函数，里面写上对象的属性</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    this.name = props.name || &apos;Unknown&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //方法写在后面</span><br><span class="line">  eat() &#123;</span><br><span class="line">    //父类共有的方法</span><br><span class="line">    console.log(this.name + &quot; will eat pests.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//class继承</span><br><span class="line">class Bird extends Animal &#123;</span><br><span class="line"></span><br><span class="line">  //构造函数</span><br><span class="line">  //props是继承过来的属性，myAttribute是自己的属性</span><br><span class="line">  constructor(props,myAttribute) &#123;</span><br><span class="line">    //调用实现父类的构造函数</span><br><span class="line">    //相当于获得父类的this指向</span><br><span class="line">    super(props)</span><br><span class="line"></span><br><span class="line">    //父类的属性，也可写在父类中</span><br><span class="line">    this.type = props.type || &quot;Unknown&quot;;</span><br><span class="line"></span><br><span class="line">    //自己的私有属性</span><br><span class="line">    this.attr = myAttribute;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //自己私有的方法</span><br><span class="line">  fly() &#123;</span><br><span class="line">    console.log(this.name + &quot; are friendly to people.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //自己私有的方法</span><br><span class="line">  myattr() &#123;</span><br><span class="line">    console.log(this.type+&apos;---&apos;+this.attr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过new实例化</span><br><span class="line">var myBird = new Bird(&#123;</span><br><span class="line">  name: &apos;小燕子&apos;,</span><br><span class="line"></span><br><span class="line">  //卵生动物</span><br><span class="line">  type: &apos;Egg animal&apos;</span><br><span class="line">&#125;,&apos;Bird class&apos;)</span><br><span class="line"></span><br><span class="line">myBird.eat()</span><br><span class="line">myBird.fly()</span><br><span class="line">myBird.myattr()</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;原型式继承&quot;&gt;&lt;a href=&quot;#原型式继承&quot; class=&quot;headerlink&quot; title=&quot;原型式继承&quot;&gt;&lt;/a&gt;原型式继承&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript异步代码优化</title>
    <link href="https://liushuai97.github.io/2019/09/25/JavaScript%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>https://liushuai97.github.io/2019/09/25/JavaScript异步代码优化/</id>
    <published>2019-09-25T01:19:27.000Z</published>
    <updated>2019-09-25T02:49:27.386Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">传递函数作为回调</span><br><span class="line">function(ag1,ag2...,callback) &#123;</span><br><span class="line">　 // 业务逻辑代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callback 顾名思义便是回调，但并不是将回调内容放在异步方法里，而是放到外部的回调函数中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.mytest = function(str, callback) &#123;</span><br><span class="line">    printStr(str) ;</span><br><span class="line">    var res = test_callback();</span><br><span class="line">    callback(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function printStr(str) &#123;</span><br><span class="line">    alert(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test_callback() &#123;</span><br><span class="line">    return &quot;回调测试&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此我们看似异步的代码变成了同步的写法，避免了层层嵌套的写法，看上去也流畅了很多。同时使用 callback 也是异步编程最基础和核心的一种解决思路。</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>基于 callback，Promise 目前也被广泛运用，其是异步编程的一种解决方案，比传统的回调函数解决方案更合理和强大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise(test).then(function (result) &#123;</span><br><span class="line">  console.log(&apos;成功：&apos; + result);</span><br><span class="line">&#125;).catch(function (reason) &#123;</span><br><span class="line">  console.log(&apos;失败：&apos; + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然如果要等待多个异步请求完成执行某些操作，可以使用 Promise.all 方法，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let p = Promise.all([p1, p2, p3]); // 其中p1、p2、p3都是Promise实例</span><br><span class="line">p.then(result =&gt; console.log(result));</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">p1.then(p2).then(p3).catch(handleError); // 其中p1、p2、p3都是Promise实例</span><br></pre></td></tr></table></figure><p>当然 Promise 也有其相应的缺点，比如下一个 then 回调只能获取上一个 then 返回的数据，不能跨层获取，同时大量的 then 回调也会使代码不容易维护。</p><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p>generator 跟函数很像，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;</span><br><span class="line">    yield x + 1;</span><br><span class="line">    yield x + 2;</span><br><span class="line">    return x + 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。</span><br></pre></td></tr></table></figure><p>要编写一个产生斐波那契数列的函数，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* fib(max) &#123;</span><br><span class="line">  var</span><br><span class="line">    t,</span><br><span class="line">    a = 0,</span><br><span class="line">    b = 1,</span><br><span class="line">    n = 0;</span><br><span class="line">  while (n &lt; max) &#123;</span><br><span class="line">    yield a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">    n ++;</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用 generator 对象有两个方法</li></ul><ol><li>不断地调用 generator 对象的 next()方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var f = fib(5);</span><br><span class="line">f.next(); // &#123;value: 0, done: false&#125;</span><br><span class="line">f.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">f.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">f.next(); // &#123;value: 2, done: false&#125;</span><br><span class="line">f.next(); // &#123;value: 3, done: false&#125;</span><br><span class="line">f.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p>next()方法会执行 generator 的代码，然后，每次遇到 yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的 value 就是 yield 的返回值，done 表示这个 generator 是否已经执行结束了。如果 done 为 true，则 value 就是 return 的返回值。</p><ol start="2"><li>直接用 for … of 循环迭代 generator 对象，这种方式不需要我们自己判断 done：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var x of fib(10)) &#123;</span><br><span class="line">  console.log(x); // 依次输出0, 1, 1, 2, 3, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>缺点：Generator 函数的缺点在于，我们每一次执行 yield 语句都需要手动进行 next，不是很方便。</li><li>优点：把异步回调代码变成“同步”代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  r1 = yield ajax(&apos;http://url-1&apos;, data1);</span><br><span class="line">  r2 = yield ajax(&apos;http://url-2&apos;, data2);</span><br><span class="line">  r3 = yield ajax(&apos;http://url-3&apos;, data3);</span><br><span class="line">  success(r3);</span><br><span class="line">&#125;</span><br><span class="line">catch (err) &#123;</span><br><span class="line">  handle(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="async-and-await"><a href="#async-and-await" class="headerlink" title="async and await"></a>async and await</h4><p>ES7 还提供了更加方便的 async 函数和 await 命令，其实 async 是 Generator 函数的语法糖，不同点在于其内置了执行器，也就是说 async 函数自带执行器。</p><ul><li>async 的用法</li></ul><p>它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为 async 就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function timeout() &#123;</span><br><span class="line">　return &apos;hello world&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// async 函数返回的是一个promise 对象，如果要获取到promise 返回值，我们应该用then 方法。</span><br><span class="line"></span><br><span class="line">timeout().then(result =&gt; &#123;</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;虽然在后面，但是我先执行&apos;);</span><br></pre></td></tr></table></figure><ul><li>await 关键字</li></ul><p>顾名思义， await 就是异步等待，它等待的是一个 Promise，因此 await 后面应该写一个 Promise 对象，如果不是 Promise 对象，那么会被转成一个立即 resolve 的 Promise。注意 await 关键字只能放到 async 函数里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">async function sayHi_async(name) &#123;</span><br><span class="line">  try&#123;</span><br><span class="line"></span><br><span class="line">    const sayHi_1 = await sayHi(name)</span><br><span class="line">    console.log(`你好， $&#123;sayHi_1&#125;`)</span><br><span class="line"></span><br><span class="line">    const sayHi_2 = await sayHi(&apos;李四&apos;)</span><br><span class="line">    console.log(`你好， $&#123;sayHi_2&#125;`)</span><br><span class="line"></span><br><span class="line">    const sayHi_3 = await sayHi(&apos;王二麻子&apos;)</span><br><span class="line">    console.log(`你好， $&#123;sayHi_3&#125;`)</span><br><span class="line"></span><br><span class="line">  &#125; catch (err)&#123;</span><br><span class="line">    </span><br><span class="line">    console.log(err)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行</span><br><span class="line">sayHi_async(&apos;张三&apos;)</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">console.log(&quot;你好， 张三&quot;)</span><br><span class="line">console.log(&quot;你好， 李四&quot;)</span><br><span class="line">console.log(&quot;你好， 王二麻子&quot;)</span><br></pre></td></tr></table></figure><p>async函数调用不会造成代码的阻塞，但是await会引起async函数内部代码的阻塞。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;callback&quot;&gt;&lt;a href=&quot;#callback&quot; class=&quot;headerlink&quot; title=&quot;callback&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题10</title>
    <link href="https://liushuai97.github.io/2019/09/25/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9810/"/>
    <id>https://liushuai97.github.io/2019/09/25/JavaScript-自测题10/</id>
    <published>2019-09-25T00:59:55.000Z</published>
    <updated>2019-09-25T02:48:55.457Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><ol><li><p>arguments对象和Function是分不开的。</p></li><li><p>因为arguments这个对象不能显式创建。</p></li><li><p>arguments对象只有函数开始时才可用。</p></li></ol><p>arguments<a href>0</a>的意思，和arguments.0()的意思差不多（当然这么写是不允许的），你更可以这么理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arguments = &#123;</span><br><span class="line">    0: fn, //也就是 functon() &#123;alert(this.length)&#125; </span><br><span class="line">    1: 第二个参数, //没有 </span><br><span class="line">    2: 第三个参数, //没有</span><br><span class="line">    ..., </span><br><span class="line">    length: 1 //只有一个参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var length = 10;</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">  console.log(this.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  length:5,</span><br><span class="line">  method:function(fn)&#123;</span><br><span class="line">      fn();</span><br><span class="line">      arguments[0]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.method(fn,1);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">第一个 fn  this指向window   输出10</span><br><span class="line">第二个 arguments[0]() 可以理解为arguments.0() [只是方便理解] ，</span><br><span class="line">            即argument对象调用fn函数，所以this指向arguments对象</span><br><span class="line">arguments = &#123;</span><br><span class="line">  0:fn,    //function fn()&#123;console.log(this.length);&#125;</span><br><span class="line">  1:第二个参数 1，</span><br><span class="line">  length:2</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li>延伸</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var len = 10;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  len:6,</span><br><span class="line">  method:function()&#123;</span><br><span class="line">      console.log(this.len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  len:5,</span><br><span class="line">  method:function(fn)&#123;</span><br><span class="line">      fn();</span><br><span class="line">      arguments[0](); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj2.method(obj1.method,obj2.method);  // 10 undefined</span><br><span class="line">/*</span><br><span class="line">第一个 fn  this指向window   输出10</span><br><span class="line">第二个 arguments[0]()    this指向arguments</span><br><span class="line">arguments = &#123;</span><br><span class="line">  0:obj1.method,   //function()&#123;console.log(this.len);&#125;</span><br><span class="line">  1:obj2.method,</span><br><span class="line">  length:2</span><br><span class="line">&#125;</span><br><span class="line">arguments没有len属性，所以为undefined</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;arguments&quot;&gt;&lt;a href=&quot;#arguments&quot; class=&quot;headerlink&quot; title=&quot;arguments
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题9</title>
    <link href="https://liushuai97.github.io/2019/09/25/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%989/"/>
    <id>https://liushuai97.github.io/2019/09/25/JavaScript-自测题9/</id>
    <published>2019-09-25T00:10:28.000Z</published>
    <updated>2019-09-25T02:48:51.762Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><h4 id="typeof返回值范围："><a href="#typeof返回值范围：" class="headerlink" title="typeof返回值范围："></a>typeof返回值范围：</h4><p>typeof返回值对应</p><table><thead><tr><th align="center">类型</th><th>结果</th></tr></thead><tbody><tr><td align="center">String</td><td>“string”</td></tr><tr><td align="center">Number</td><td>“number”</td></tr><tr><td align="center">Boolean</td><td>“boolean”</td></tr><tr><td align="center">Undefined</td><td>“undefined”</td></tr><tr><td align="center">Null</td><td>“object”</td></tr><tr><td align="center">Object</td><td>“object”</td></tr><tr><td align="center">function函数对象</td><td>“function”</td></tr><tr><td align="center">Symbol(ES6新增)</td><td>“symbol”</td></tr><tr><td align="center">宿主对象(由JS环境提供)</td><td>Implementation-dependent</td></tr></tbody></table><h4 id="typeof的不足之处"><a href="#typeof的不足之处" class="headerlink" title="typeof的不足之处"></a>typeof的不足之处</h4><ol><li>不能区分对象、数组、正则，对它们操作都返回”object”；（正则特殊一点后面说）</li><li>Safar5,Chrome7之前的版本对正则对象返回 ‘function’</li><li>在IE6,7和8中，大多数的宿主对象是对象，而不是函数；如：typeof alert; //object</li><li>而在非ID浏览器或则IE9以上（包含IE9），typeof alert; //function</li></ol><h4 id="特殊中的特殊"><a href="#特殊中的特殊" class="headerlink" title="特殊中的特殊"></a>特殊中的特殊</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeof 1/0; //NaN（这个NaN不是字符串类型，是数值类型）</span><br><span class="line">typeof typeof 1/0; //NaN（这个NaN不是字符串类型，是数值类型）</span><br><span class="line">typeof(1/0); //&quot;number&quot;</span><br><span class="line">typeof typeof(1/0); //&quot;string&quot;</span><br><span class="line">typeof(typeof 1/0); //&quot;number&quot;</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// Numbers</span><br><span class="line">typeof 37 === &apos;number&apos;;</span><br><span class="line">typeof 3.14 === &apos;number&apos;;</span><br><span class="line">typeof Math.LN2 === &apos;number&apos;;</span><br><span class="line">typeof Infinity === &apos;number&apos;;</span><br><span class="line">typeof NaN === &apos;number&apos;; // 尽管NaN是&quot;Not-A-Number&quot;的缩写</span><br><span class="line">typeof Number(1) === &apos;number&apos;; // 但不要使用这种形式!</span><br><span class="line"></span><br><span class="line">// Strings</span><br><span class="line">typeof &quot;&quot; === &apos;string&apos;;</span><br><span class="line">typeof &quot;bla&quot; === &apos;string&apos;;</span><br><span class="line">typeof (typeof 1) === &apos;string&apos;; // typeof总是返回一个字符串</span><br><span class="line">typeof String(&quot;abc&quot;) === &apos;string&apos;; // 但不要使用这种形式!</span><br><span class="line"></span><br><span class="line">// Booleans</span><br><span class="line">typeof true === &apos;boolean&apos;;</span><br><span class="line">typeof false === &apos;boolean&apos;;</span><br><span class="line">typeof Boolean(true) === &apos;boolean&apos;; // 但不要使用这种形式!</span><br><span class="line"></span><br><span class="line">// Symbols</span><br><span class="line">typeof Symbol() === &apos;symbol&apos;;</span><br><span class="line">typeof Symbol(&apos;foo&apos;) === &apos;symbol&apos;;</span><br><span class="line">typeof Symbol.iterator === &apos;symbol&apos;;</span><br><span class="line"></span><br><span class="line">// Undefined</span><br><span class="line">typeof undefined === &apos;undefined&apos;;</span><br><span class="line">typeof declaredButUndefinedVariable === &apos;undefined&apos;;</span><br><span class="line">typeof undeclaredVariable === &apos;undefined&apos;; </span><br><span class="line"></span><br><span class="line">// Objects</span><br><span class="line">typeof &#123;a:1&#125; === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">// 使用Array.isArray 或者 Object.prototype.toString.call</span><br><span class="line">// 区分数组,普通对象</span><br><span class="line">typeof [1, 2, 4] === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">typeof new Date() === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">// 下面的容易令人迷惑，不要使用！</span><br><span class="line">typeof new Boolean(true) === &apos;object&apos;;</span><br><span class="line">typeof new Number(1) ==== &apos;object&apos;;</span><br><span class="line">typeof new String(&quot;abc&quot;) === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">// 函数</span><br><span class="line">typeof function()&#123;&#125; === &apos;function&apos;;</span><br><span class="line">typeof Math.sin === &apos;function&apos;;</span><br><span class="line"></span><br><span class="line">//NaN</span><br><span class="line">typeof 1/0 === &apos;NaN&apos;;</span><br></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ol><li>this的值通常是由当前函数的执行环境所决定；</li><li>在全局作用域，this指向全局对象 (window对象)；</li><li>当使用new关键字声明，this指向新建对象；</li><li>我们可以使用call(), bind(), apply()来设置this；</li><li>箭头函数不会绑定this。</li></ol><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var test = function test() &#123;</span><br><span class="line">    /* body... */</span><br><span class="line">    test = 1;</span><br><span class="line">    console.log(typeof test)   //function</span><br><span class="line">&#125;;</span><br><span class="line">test();</span><br><span class="line">test = 1;</span><br><span class="line">console.log(typeof test);  // number</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;typeof返回值范围：&quot;&gt;&lt;a href=&quot;#typeof返回值范围：&quot; class=&quot;headerlink&quot; title=&quot;typ
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题8</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%988/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题8/</id>
    <published>2019-09-23T09:30:52.000Z</published>
    <updated>2019-09-25T02:48:48.027Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><h4 id="JavaScript-正则表达式"><a href="#JavaScript-正则表达式" class="headerlink" title="JavaScript 正则表达式"></a>JavaScript 正则表达式</h4><ul><li>语法</li></ul><p>/正则表达式主体/修饰符(可选)</p><ul><li>使用字符串方法</li></ul><p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p><ol><li><p>search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p></li><li><p>replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p></li></ol><h4 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h4><ul><li>修饰符可以在全局搜索中不区分大小写:</li></ul><table><thead><tr><th align="center">修饰符</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>执行对大小写不敏感的匹配。</td></tr><tr><td align="center">g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td align="center">m</td><td>执行多行匹配。</td></tr></tbody></table><h4 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h4><ul><li>方括号用于查找某个范围内的字符：</li></ul><table><thead><tr><th align="center">表达式</th><th>描述</th></tr></thead><tbody><tr><td align="center">[abc]</td><td>查找方括号之间的任何字符。</td></tr><tr><td align="center">[0-9]</td><td>查找任何从 0 至 9 的数字。</td></tr><tr><td align="center">(x</td><td>y)</td></tr></tbody></table><ul><li>元字符是拥有特殊含义的字符：</li></ul><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center">\d</td><td>查找数字。</td></tr><tr><td align="center">\s</td><td>查找空白字符。</td></tr><tr><td align="center">\b</td><td>匹配单词边界。</td></tr><tr><td align="center">\uxxxx</td><td>查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><ul><li>量词:</li></ul><table><thead><tr><th align="center">量词</th><th>描述</th></tr></thead><tbody><tr><td align="center">n+</td><td>匹配任何包含至少一个 n 的字符串。</td></tr><tr><td align="center">n*</td><td>匹配任何包含零个或多个 n 的字符串。</td></tr><tr><td align="center">n?</td><td>匹配任何包含零个或一个 n 的字符串。</td></tr></tbody></table><h4 id="使用-RegExp-对象"><a href="#使用-RegExp-对象" class="headerlink" title="使用 RegExp 对象"></a>使用 RegExp 对象</h4><p>在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。</p><h4 id="使用-test"><a href="#使用-test" class="headerlink" title="使用 test()"></a>使用 test()</h4><p>test() 方法是一个正则表达式方法。</p><p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p><h4 id="使用-exec"><a href="#使用-exec" class="headerlink" title="使用 exec()"></a>使用 exec()</h4><p>exec() 方法是一个正则表达式方法。</p><p>exec() 方法用于检索字符串中的正则表达式的匹配。</p><p>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p><ul><li><p>RegExp.prototype.exec()和RegExp.prototype.test一样，在设置了g修饰符之后，每次执行都会设置lastIndex，从而影响下一次匹配的结果。</p></li><li><p>在一个包含g修饰符的正则上使用RegExp.prototype.test()函数</p></li></ul><p>如果正则表达式被设置了g修饰符，RegExp.prototype.test()函数会在每一次调用后设置正则表达式的lastIndex值。在其后调用的test()会从这个lastIndex索引位置开始匹配（RegExp.prototype.exec()函数也遵循同样的规则）。如果前后传入不同的字符串作为参数，RegExp.prototype.test()的结果就是没有意义的。</p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var regex = /foo/g;</span><br><span class="line"></span><br><span class="line">// regex.lastIndex = 0</span><br><span class="line">regex.test(&apos;foo&apos;); // true</span><br><span class="line"></span><br><span class="line">// regex.lastIndex = 3</span><br><span class="line">regex.test(&apos;foo&apos;); // false</span><br><span class="line"></span><br><span class="line">// regex.lastIndex = 0</span><br><span class="line">regex.test(&apos;barfoo&apos;) // true</span><br><span class="line"></span><br><span class="line">// regex.lastIndex = 6</span><br><span class="line">regex.test(&apos;foobar&apos;) //false</span><br></pre></td></tr></table></figure><p>利用这种机制，下面的代码建立了一个函数，用来查找在一个字符串中一共有多少单词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function countWords (sText) &#123;</span><br><span class="line">  for (var rWord = /\w+/g, nCount = 0; rWord.test(sText); nCount++);</span><br><span class="line">  return nCount;</span><br><span class="line">&#125;</span><br><span class="line">console.log(countWords(&quot;What a beautiful day!&quot;)); // 4</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;JavaScript-正则表达式&quot;&gt;&lt;a href=&quot;#JavaScript-正则表达式&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题7</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%987/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题7/</id>
    <published>2019-09-23T08:56:17.000Z</published>
    <updated>2019-09-25T02:48:42.546Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --><h4 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h4><p>String 对象方法</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">anchor()</td><td>创建 HTML 锚。</td></tr><tr><td align="center">big()</td><td>用大号字体显示字符串。</td></tr><tr><td align="center">blink()</td><td>显示闪动字符串。</td></tr><tr><td align="center">bold()</td><td>使用粗体显示字符串。</td></tr><tr><td align="center">charAt()</td><td>返回在指定位置的字符。</td></tr><tr><td align="center">charCodeAt()</td><td>返回在指定的位置的字符的 Unicode 编码。</td></tr><tr><td align="center">concat()</td><td>连接字符串。</td></tr><tr><td align="center">fixed()</td><td>以打字机文本显示字符串。</td></tr><tr><td align="center">fontcolor()</td><td>使用指定的颜色来显示字符串。</td></tr><tr><td align="center">fontsize()</td><td>使用指定的尺寸来显示字符串。</td></tr><tr><td align="center">fromCharCode()</td><td>从字符编码创建一个字符串。</td></tr><tr><td align="center">indexOf()</td><td>检索字符串。</td></tr><tr><td align="center">italics()</td><td>使用斜体显示字符串。</td></tr><tr><td align="center">lastIndexOf()</td><td>从后向前搜索字符串。</td></tr><tr><td align="center">link()</td><td>将字符串显示为链接。</td></tr><tr><td align="center">localeCompare()</td><td>用本地特定的顺序来比较两个字符串。</td></tr><tr><td align="center">match()</td><td>找到一个或多个正则表达式的匹配。</td></tr><tr><td align="center">replace()</td><td>替换与正则表达式匹配的子串。</td></tr><tr><td align="center">search()</td><td>检索与正则表达式相匹配的值。</td></tr><tr><td align="center">slice()</td><td>提取字符串的片断，并在新的字符串中返回被提取的部分。</td></tr><tr><td align="center">small()</td><td>使用小字号来显示字符串。</td></tr><tr><td align="center">split()</td><td>把字符串分割为字符串数组。</td></tr><tr><td align="center">strike()</td><td>使用删除线来显示字符串。</td></tr><tr><td align="center">sub()</td><td>把字符串显示为下标。</td></tr><tr><td align="center">substr()</td><td>从起始索引号提取字符串中指定数目的字符。</td></tr><tr><td align="center">substring()</td><td>提取字符串中两个指定的索引号之间的字符。</td></tr><tr><td align="center">sup()</td><td>把字符串显示为上标。</td></tr><tr><td align="center">toLocaleLowerCase()</td><td>把字符串转换为小写。</td></tr><tr><td align="center">toLocaleUpperCase()</td><td>把字符串转换为大写。</td></tr><tr><td align="center">toLowerCase()</td><td>把字符串转换为小写。</td></tr><tr><td align="center">toUpperCase()</td><td>把字符串转换为大写。</td></tr><tr><td align="center">toSource()</td><td>代表对象的源代码。</td></tr><tr><td align="center">toString()</td><td>返回字符串。</td></tr><tr><td align="center">valueOf()</td><td>返回某个字符串对象的原始值。</td></tr></tbody></table><h4 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h4><p>Array 对象方法</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">concat()</td><td>连接两个或更多的数组，并返回结果。</td></tr><tr><td align="center">join()</td><td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td></tr><tr><td align="center">pop()</td><td>删除并返回数组的最后一个元素</td></tr><tr><td align="center">push()</td><td>向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="center">reverse()</td><td>颠倒数组中元素的顺序。</td></tr><tr><td align="center">shift()</td><td>删除并返回数组的第一个元素</td></tr><tr><td align="center">slice()</td><td>从某个已有的数组返回选定的元素</td></tr><tr><td align="center">sort()</td><td>对数组的元素进行排序</td></tr><tr><td align="center">splice()</td><td>删除元素，并向数组添加新元素。</td></tr><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">toString()</td><td>把数组转换为字符串，并返回结果。</td></tr><tr><td align="center">toLocaleString()</td><td>把数组转换为本地数组，并返回结果。</td></tr><tr><td align="center">unshift()</td><td>向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="center">valueOf()</td><td>返回数组对象的原始值</td></tr></tbody></table><h4 id="常用数组-字符串方法与遍历"><a href="#常用数组-字符串方法与遍历" class="headerlink" title="常用数组/字符串方法与遍历"></a>常用数组/字符串方法与遍历</h4><p>javascript有很多遍历的方法，for、for in、for of（ES6）、forEach、map、filter、every、some、Jquery的each等等。</p><ol><li>for 循环</li></ol><p>for循环语句，最基础的遍历，以数组的下标为索引，对数组元素进行遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrFor(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      for (var k = 0; k &lt; arr.length; k++) &#123;</span><br><span class="line">          ret += arr[k];</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array for 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array for 报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for 循环不是函数，不存在返回值。</li></ul><ol start="2"><li>for in</li></ol><p>for in循环不仅可以遍历数组，还可以遍历对象，但for in存在一些陷阱，比如它会在遍历完元素之后，还会对数组或对象的prototype中的属性进行遍历，所以，for in 更像是为对象遍历而设计的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrForIn(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      for (var k in arr) &#123;</span><br><span class="line">          ret += arr[k];</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array for in 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array for in报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>for of (ES6)</li></ol><p>ES6中引入了 for … of 循环，以替代 for…in 和 forEach() ，允许对 Array(数组)、String(字符串)、Maps(映射)、Sets(集合)等可迭代的数据结构进行遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrForOf(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      for(var k of arr) &#123;</span><br><span class="line">          ret += k;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array for of 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array for of报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for(var k of arr) 中的 k ，就是数组 arr 中的元素，而不是数组的下标。</li><li>IE 不支持，Edge支持。</li></ul><ol start="4"><li>forEach</li></ol><p>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrForEach(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      arr.forEach(function (v, k) &#123;</span><br><span class="line">          ret += v;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array forEach 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array forEach报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>forEach() 对于空数组是不会执行回调函数的。</p></li><li><p>回调函数 function (v, k) 中的 k 是数组的下标，v 是数组元素值。</p></li><li><p>IE9以下的版本不支持。</p><ol start="5"><li>map</li></ol><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrMap(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      arr.map(function (v, k) &#123;</span><br><span class="line">          ret += v;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array map 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array map报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map() 返回一个新数组。</li><li>map() 不会对空数组进行检测。</li><li>map() 不会改变原始数组。</li></ul><ol start="6"><li>filter</li></ol><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrFilter(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      arr.filter(function (v, k) &#123;</span><br><span class="line">          ret += v;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array filter 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array filter报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>filter() 不会对空数组进行检测。</li><li>filter() 不会改变原始数组。</li></ul><ol start="7"><li>every</li></ol><p>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供），返回 boolen。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function arrEvery(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var st = performance.now();</span><br><span class="line">      var ret = arr.every(function (v, k) &#123;</span><br><span class="line">          return v.length &gt; 1;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array every 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array every报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li><li>如果所有元素都满足条件，则返回 true。</li><li>every() 不会对空数组进行检测。</li><li>every() 不会改变原始数组。</li></ul><ol start="8"><li>some</li></ol><p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。只要有一个元素满足则返回true，并不再继续往下判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function arrSome(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var st = performance.now();</span><br><span class="line">      var ret = arr.some(function (v, k) &#123;</span><br><span class="line">          return v.length &gt; 1;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array some 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array some报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。</li><li>如果没有满足条件的元素，则返回false。</li><li>some() 不会对空数组进行检测。</li><li>some() 不会改变原始数组。</li></ul><ol start="9"><li>Object.keys.forEach</li></ol><p>Object.keys.forEach() 主要是用于遍历对象，获取对象的属性名，对于遍历数组意义不大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function objectKey(obj) &#123;</span><br><span class="line">  try&#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      Object.keys(obj).forEach(function(key, index, arr) &#123;</span><br><span class="line">          ret += obj[key];</span><br><span class="line">      &#125;);</span><br><span class="line">      //ES6写法</span><br><span class="line">      //Object.keys(obj).forEach(k =&gt; &#123;</span><br><span class="line">      //    ret += obj[k];</span><br><span class="line">      //&#125;);　</span><br><span class="line">      console.log(ret);</span><br><span class="line">      let diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;object key 总耗时：&quot; + diff);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (e)&#123;</span><br><span class="line">      console.log(&quot;object key 报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Object.keys.forEach 在遍历时，回调函数的参数 key是属性名（对于数组，属性名和索引一一对应)，index 是keys数组的索引，arr是keys数组；所以在取值的时候还是用 obj[key]</p></li><li><p>例题：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a =&apos;abc&apos;</span><br><span class="line">a.split().every(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;);</span><br><span class="line">a.split().map(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;)</span><br><span class="line">a.split().forEach(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;)</span><br><span class="line">a.split().filter(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Oct 02 2019 13:31:09 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;String-对象&quot;&gt;&lt;a href=&quot;#String-对象&quot; class=&quot;headerlink&quot; title=&quot;String 对象
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
