<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随笔</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liushuai97.github.io/"/>
  <updated>2019-09-30T08:17:15.728Z</updated>
  <id>https://liushuai97.github.io/</id>
  
  <author>
    <name>前端菜鸟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript Functions全局对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/30/JavaScript-Functions%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/30/JavaScript-Functions全局对象属性与方法/</id>
    <published>2019-09-30T08:00:21.000Z</published>
    <updated>2019-09-30T08:17:15.728Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><p>全局对象是预定义的对象，作为JavaScript的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。全局对象不是任何对象的属性，所以它没有名称。</p><p>在顶层JavaScript代码中，可以用关键字this引用全局对象。但通常不必用这种方式引用全局对象，因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p><p>全局对象是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象。</p><p>Function类型，说起来ECMAScript中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p><p>JavaScript 全局对象，全局属性和函数可用于所有内建的 JavaScript 对象。</p><h4 id="顶层属性（全局属性）"><a href="#顶层属性（全局属性）" class="headerlink" title="顶层属性（全局属性）"></a>顶层属性（全局属性）</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">Infinity</td><td>代表正的无穷大的数值。</td></tr><tr><td align="center">java</td><td>代表 java.* 包层级的一个 JavaPackage。</td></tr><tr><td align="center">NaN</td><td>指示某个值是不是数字值。</td></tr><tr><td align="center">Packages</td><td>根 JavaPackage 对象。</td></tr><tr><td align="center">undefined</td><td>指示未定义的值。</td></tr></tbody></table><h4 id="顶层函数（全局函数）"><a href="#顶层函数（全局函数）" class="headerlink" title="顶层函数（全局函数）"></a>顶层函数（全局函数）</h4><table><thead><tr><th align="center">函数</th><th>描述</th></tr></thead><tbody><tr><td align="center">decodeURI()</td><td>解码某个编码的 URI。</td></tr><tr><td align="center">decodeURIComponent()</td><td>解码一个编码的 URI 组件。</td></tr><tr><td align="center">encodeURI()</td><td>把字符串编码为 URI。</td></tr><tr><td align="center">encodeURIComponent()</td><td>把字符串编码为 URI 组件。</td></tr><tr><td align="center">escape()</td><td>对字符串进行编码。</td></tr><tr><td align="center">eval()</td><td>计算 JavaScript 字符串，并把它作为脚本代码来执行。</td></tr><tr><td align="center">getClass()</td><td>返回一个 JavaObject 的 JavaClass。</td></tr><tr><td align="center">isFinite()</td><td>检查某个值是否为有穷大的数。</td></tr><tr><td align="center">isNaN()</td><td>检查某个值是否是数字。</td></tr><tr><td align="center">Number()</td><td>把对象的值转换为数字。</td></tr><tr><td align="center">parseFloat()</td><td>解析一个字符串并返回一个浮点数。</td></tr><tr><td align="center">parseInt()</td><td>解析一个字符串并返回一个整数。</td></tr><tr><td align="center">String()</td><td>把对象的值转换为字符串。</td></tr><tr><td align="center">unescape()</td><td>对由 escape() 编码的字符串进行解码。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;全局对象是预定义的对象，作为JavaScript的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。全
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript RegExp对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/30/JavaScript-RegExp%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/30/JavaScript-RegExp对象属性与方法/</id>
    <published>2019-09-30T06:23:51.000Z</published>
    <updated>2019-09-30T06:40:39.069Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><p>ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。</p><p><code>var expression = /pattern/flags;</code></p><p>其中的模式（pattern）部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定类、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志（flags），用以标明正则表达式的行为。</p><p>g：表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；<br>i：表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；<br>m：表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</p><p>因此，一个正则表达式就是一个模式与上述3个标志的组合体。不同组合产生不同结果，如下面的例子所示。</p><p>RegExp 对象，正则表达式是描述字符模式的对象。</p><p>正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。</p><p>方括号，方括号用于查找某个范围内的字符：</p><table><thead><tr><th align="center">表达式</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>[abc]</code></td><td>查找方括号之间的任何字符。</td></tr><tr><td align="center"><code>[^abc]</code></td><td>查找任何不在方括号之间的字符。</td></tr><tr><td align="center"><code>[0-9]</code></td><td>查找任何从 0 至 9 的数字。</td></tr><tr><td align="center"><code>[a-z]</code></td><td>查找任何从小写 a 到小写 z 的字符。</td></tr><tr><td align="center"><code>[A-Z]</code></td><td>查找任何从大写 A 到大写 Z 的字符。</td></tr><tr><td align="center"><code>[A-z]</code></td><td>查找任何从大写 A 到小写 z 的字符。</td></tr><tr><td align="center"><code>[adgk]</code></td><td>查找给定集合内的任何字符。</td></tr><tr><td align="center"><code>[^adgk]</code></td><td>查找给定集合外的任何字符。</td></tr><tr><td align="center">`(red</td><td>blue</td></tr></tbody></table><p>元字符，元字符（Metacharacter）是拥有特殊含义的字符：</p><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>.</code></td><td>查找单个字符，除了换行和行结束符。</td></tr><tr><td align="center"><code>\w</code></td><td>查找单词字符。</td></tr><tr><td align="center"><code>\W</code></td><td>查找非单词字符。</td></tr><tr><td align="center"><code>\d</code></td><td>查找数字。</td></tr><tr><td align="center"><code>\D</code></td><td>查找非数字字符。</td></tr><tr><td align="center"><code>\s</code></td><td>查找空白字符。</td></tr><tr><td align="center"><code>\S</code></td><td>查找非空白字符。</td></tr><tr><td align="center"><code>\b</code></td><td>匹配单词边界。</td></tr><tr><td align="center"><code>\B</code></td><td>匹配非单词边界。</td></tr><tr><td align="center"><code>\0</code></td><td>查找 NUL 字符。</td></tr><tr><td align="center"><code>\n</code></td><td>查找换行符。</td></tr><tr><td align="center"><code>\f</code></td><td>查找换页符。</td></tr><tr><td align="center"><code>\r</code></td><td>查找回车符。</td></tr><tr><td align="center"><code>\t</code></td><td>查找制表符。</td></tr><tr><td align="center"><code>\v</code></td><td>查找垂直制表符。</td></tr><tr><td align="center"><code>\xxx</code></td><td>查找以八进制数 xxx 规定的字符。</td></tr><tr><td align="center"><code>\xdd</code></td><td>查找以十六进制数 dd 规定的字符。</td></tr><tr><td align="center"><code>\uxxxx</code></td><td>查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><p>量词</p><table><thead><tr><th align="center">量词</th><th>描述</th></tr></thead><tbody><tr><td align="center"><code>n+</code></td><td>匹配任何包含至少一个 n 的字符串。</td></tr><tr><td align="center"><code>n*</code></td><td>匹配任何包含零个或多个 n 的字符串。</td></tr><tr><td align="center"><code>n?</code></td><td>匹配任何包含零个或一个 n 的字符串。</td></tr><tr><td align="center"><code>n{X}</code></td><td>匹配包含 X 个 n 的序列的字符串。</td></tr><tr><td align="center"><code>n{X,Y}</code></td><td>匹配包含 X 至 Y 个 n 的序列的字符串。</td></tr><tr><td align="center"><code>n{X,}</code></td><td>匹配包含至少 X 个 n 的序列的字符串。</td></tr><tr><td align="center"><code>n$</code></td><td>匹配任何结尾为 n 的字符串。</td></tr><tr><td align="center"><code>^n</code></td><td>匹配任何开头为 n 的字符串。</td></tr><tr><td align="center"><code>?=n</code></td><td>匹配任何其后紧接指定字符串 n 的字符串。</td></tr><tr><td align="center"><code>?!n</code></td><td>匹配任何其后没有紧接指定字符串 n 的字符串。</td></tr></tbody></table><h4 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">compile</td><td>编译正则表达式。</td></tr><tr><td align="center">exec</td><td>检索字符串中指定的值。返回找到的值，并确定其位置。</td></tr><tr><td align="center">test</td><td>检索字符串中指定的值。返回 true 或 false。</td></tr></tbody></table><ul><li>支持正则表达式的 String 对象的方法</li></ul><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">search</td><td>检索与正则表达式相匹配的值。</td></tr><tr><td align="center">match</td><td>找到一个或多个正则表达式的匹配。</td></tr><tr><td align="center">replace</td><td>替换与正则表达式匹配的子串。</td></tr><tr><td align="center">split</td><td>把字符串分割为字符串数组。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;ECMAScript通过RegExp类型来支持正则表达式。使用下面类似Perl的语法，就可以创建一个正则表达式。&lt;/p&gt;&lt;p&gt;&lt;code&gt;var
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript String对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/30/JavaScript-String%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/30/JavaScript-String对象属性与方法/</id>
    <published>2019-09-30T01:13:25.000Z</published>
    <updated>2019-09-30T06:33:27.008Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><p>String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，因此下面两种字符串的写法都是有效的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var firstName = &quot;Nicholas&quot;;</span><br><span class="line">var lastName = &apos;Zakas&apos;;</span><br></pre></td></tr></table></figure><p>字符字面量，String数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。</p><table><thead><tr><th align="center">字面量</th><th>含义</th></tr></thead><tbody><tr><td align="center"><code>\n</code></td><td>换行</td></tr><tr><td align="center"><code>\t</code></td><td>制表</td></tr><tr><td align="center"><code>\b</code></td><td>空格</td></tr><tr><td align="center"><code>\r</code></td><td>回车</td></tr><tr><td align="center"><code>\f</code></td><td>换页符</td></tr><tr><td align="center"><code>\\</code></td><td>斜杆</td></tr><tr><td align="center"><code>\&#39;</code></td><td>单引号（’）,在用单引号表示的字符串中使用。</td></tr><tr><td align="center"><code>\&quot;</code></td><td>双引号（”）,在用双引号表示的字符串中使用。</td></tr><tr><td align="center"><code>\xnn</code></td><td>以十六进制代码nn表示的一个字符（其中n为0~F）。例如，\x41表示”A”</td></tr><tr><td align="center"><code>\unnnn</code></td><td>以十六进制代码nnnn表示的一个Unicode字符（其中n为0~F）。例如，\u03a3表示希腊字符Σ</td></tr></tbody></table><p>String 对象<br>String 对象用于处理文本（字符串）。</p><p>String 对象创建方法： new String().</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var txt = new String(&quot;string&quot;);</span><br><span class="line">或者更简单方式：</span><br><span class="line">var txt = &quot;string&quot;;</span><br></pre></td></tr></table></figure><h4 id="String-对象属性"><a href="#String-对象属性" class="headerlink" title="String 对象属性"></a>String 对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">constructor</td><td>对创建该对象的函数的引用</td></tr><tr><td align="center">length</td><td>字符串的长度</td></tr><tr><td align="center">prototype</td><td>允许您向对象添加属性和方法</td></tr></tbody></table><h4 id="String-对象方法"><a href="#String-对象方法" class="headerlink" title="String 对象方法"></a>String 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">charAt()</td><td>返回在指定位置的字符。</td></tr><tr><td align="center">charCodeAt()</td><td>返回在指定的位置的字符的 Unicode 编码。</td></tr><tr><td align="center">concat()</td><td>连接两个或更多字符串，并返回新的字符串。</td></tr><tr><td align="center">fromCharCode()</td><td>将 Unicode 编码转为字符。</td></tr><tr><td align="center">indexOf()</td><td>返回某个指定的字符串值在字符串中首次出现的位置。</td></tr><tr><td align="center">lastIndexOf()</td><td>从后向前搜索字符串。</td></tr><tr><td align="center">match()</td><td>查找找到一个或多个正则表达式的匹配。</td></tr><tr><td align="center">replace()</td><td>在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串。</td></tr><tr><td align="center">search()</td><td>查找与正则表达式相匹配的值。</td></tr><tr><td align="center">slice()</td><td>提取字符串的片断，并在新的字符串中返回被提取的部分。</td></tr><tr><td align="center">split()</td><td>把字符串分割为字符串数组。</td></tr><tr><td align="center">substr()</td><td>从起始索引号提取字符串中指定数目的字符。</td></tr><tr><td align="center">substring()</td><td>提取字符串中两个指定的索引号之间的字符。</td></tr><tr><td align="center">toLowerCase()</td><td>把字符串转换为小写。</td></tr><tr><td align="center">toUpperCase()</td><td>把字符串转换为大写。</td></tr><tr><td align="center">trim()</td><td>去除字符串两边的空白</td></tr><tr><td align="center">valueOf()</td><td>返回某个字符串对象的原始值。</td></tr></tbody></table><h4 id="String-HTML-包装方法"><a href="#String-HTML-包装方法" class="headerlink" title="String HTML 包装方法"></a>String HTML 包装方法</h4><p>HTML 包装方法返回加入了适当HTML标签的字符串。</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">anchor()</td><td>创建 HTML 锚。</td></tr><tr><td align="center">big()</td><td>用大号字体显示字符串。</td></tr><tr><td align="center">blink()</td><td>显示闪动字符串。</td></tr><tr><td align="center">bold()</td><td>使用粗体显示字符串。</td></tr><tr><td align="center">fixed()</td><td>以打字机文本显示字符串。</td></tr><tr><td align="center">fontcolor()</td><td>使用指定的颜色来显示字符串。</td></tr><tr><td align="center">fontsize()</td><td>使用指定的尺寸来显示字符串。</td></tr><tr><td align="center">italics()</td><td>使用斜体显示字符串。</td></tr><tr><td align="center">link()</td><td>将字符串显示为链接。</td></tr><tr><td align="center">small()</td><td>使用小字号来显示字符串。</td></tr><tr><td align="center">strike()</td><td>用于显示加删除线的字符串。</td></tr><tr><td align="center">sub()</td><td>把字符串显示为下标。</td></tr><tr><td align="center">sup()</td><td>把字符串显示为上标。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，因此下面两种字符
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Number对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/28/JavaScript-Number%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/28/JavaScript-Number对象属性与方法/</id>
    <published>2019-09-28T01:32:02.000Z</published>
    <updated>2019-09-28T01:55:56.788Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><p>Number是数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递响应的数值。</p><p><code>var numberObject = new Number(value);</code></p><p>注意：如果一个采纳数值不能转换为一个数字将返回NaN（非数字值）。</p><p>Number对象，Number对象是原始数值的包装对象。</p><h4 id="Number对象属性"><a href="#Number对象属性" class="headerlink" title="Number对象属性"></a>Number对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">constructor</td><td>返回对创建此对象的 Number 函数的引用。</td></tr><tr><td align="center">MAX_VALUE</td><td>可表示的最大的数。</td></tr><tr><td align="center">MIN_VALUE</td><td>可表示的最小的数。</td></tr><tr><td align="center">NEGATIVE_INFINITY</td><td>负无穷大，溢出时返回该值。</td></tr><tr><td align="center">NaN</td><td>非数字值。</td></tr><tr><td align="center">POSITIVE_INFINITY</td><td>正无穷大，溢出时返回该值。</td></tr><tr><td align="center">prototype</td><td>允许您有能力向对象添加属性和方法。</td></tr></tbody></table><h4 id="Number对象方法"><a href="#Number对象方法" class="headerlink" title="Number对象方法"></a>Number对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">toExponential(x)</td><td>把对象的值转换为指数计数法。</td></tr><tr><td align="center">toFixed(x)</td><td>把数字转换为字符串，结果的小数点后有指定位数的数字。</td></tr><tr><td align="center">toPrecision(x)</td><td>把数字格式化为指定的长度。</td></tr><tr><td align="center">toString()</td><td>把数字转换为字符串，使用指定的基数。</td></tr><tr><td align="center">valueOf()</td><td>返回一个 Number 对象的基本数字值。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var numberObject = new Number(10)</span><br><span class="line"></span><br><span class="line">console.log(&quot;toExponential(x) Number对象方法：&quot; + numberObject.toExponential(1));</span><br><span class="line"></span><br><span class="line">numberObject = 12.54</span><br><span class="line"></span><br><span class="line">console.log(&quot;toFixed() Number对象方法：&quot; + numberObject.toFixed(0));</span><br><span class="line"></span><br><span class="line">console.log(&quot;toPrecision() Number对象方法：&quot; + numberObject.toPrecision(3));</span><br><span class="line"></span><br><span class="line">console.log(&quot;toString() Number对象方法：&quot; + numberObject.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;valueOf() Number对象方法：&quot; + numberObject.valueOf());</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Number是数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递响应的数值。&lt;/p&gt;&lt;p&gt;&lt;code&gt;va
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Math对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/28/JavaScript-Math%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/28/JavaScript-Math对象属性与方法/</id>
    <published>2019-09-27T23:58:00.000Z</published>
    <updated>2019-09-28T01:26:30.781Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><p>ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。与我们再JavaScript直接编写的计算功能相比，Math对象提供的计算功能执行起来要快很多。Math对象还提供了辅助完成这些计算的属性和方法。</p><p>Math 对象</p><p>Math对象用于执行数学任务。<br>Math对象并不像Date和String那样是对象的类，因此没有构造函数Math()。</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x = Math.PI; // 返回圆周率</span><br><span class="line">var y = Math.sprt(16); //返回16的平方根</span><br></pre></td></tr></table></figure><h4 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h4><p>Math对象包含的属性大都是数学计算中可能会用到的一些特殊值。</p><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">E</td><td>返回算术常量 e，即自然对数的底数（约等于2.718）。</td></tr><tr><td align="center">LN2</td><td>返回 2 的自然对数（约等于0.693）。</td></tr><tr><td align="center">LN10</td><td>返回 10 的自然对数（约等于2.302）。</td></tr><tr><td align="center">LOG2E</td><td>返回以 2 为底的 e 的对数（约等于 1.414）。</td></tr><tr><td align="center">LOG10E</td><td>返回以 10 为底的 e 的对数（约等于0.434）。</td></tr><tr><td align="center">PI</td><td>返回圆周率（约等于3.14159）。</td></tr><tr><td align="center">SQRT1_2</td><td>返回返回 2 的平方根的倒数（约等于 0.707）。</td></tr><tr><td align="center">SQRT2</td><td>返回 2 的平方根（约等于 1.414）。</td></tr></tbody></table><h4 id="Math-对象方法"><a href="#Math-对象方法" class="headerlink" title="Math 对象方法"></a>Math 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">abs(x)</td><td>返回 x 的绝对值。</td></tr><tr><td align="center">acos(x)</td><td>返回 x 的反余弦值。</td></tr><tr><td align="center">asin(x)</td><td>返回 x 的反正弦值。</td></tr><tr><td align="center">atan(x)</td><td>以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td></tr><tr><td align="center">atan2(y,x)</td><td>返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。</td></tr><tr><td align="center">ceil(x)</td><td>对数进行上舍入。</td></tr><tr><td align="center">cos(x)</td><td>返回数的余弦。</td></tr><tr><td align="center">exp(x)</td><td>返回 Ex 的指数。</td></tr><tr><td align="center">floor(x)</td><td>对 x 进行下舍入。</td></tr><tr><td align="center">log(x)</td><td>返回数的自然对数（底为e）。</td></tr><tr><td align="center">max(x,y,z,…,n)</td><td>返回 x,y,z,…,n 中的最高值。</td></tr><tr><td align="center">min(x,y,z,…,n)</td><td>返回 x,y,z,…,n中的最低值。</td></tr><tr><td align="center">pow(x,y)</td><td>返回 x 的 y 次幂。</td></tr><tr><td align="center">random()</td><td>返回 0 ~ 1 之间的随机数。</td></tr><tr><td align="center">round(x)</td><td>把数四舍五入为最接近的整数。</td></tr><tr><td align="center">sin(x)</td><td>返回数的正弦。</td></tr><tr><td align="center">sqrt(x)</td><td>返回数的平方根。</td></tr><tr><td align="center">tan(x)</td><td>返回角的正切。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;abs() Math对象方法：&quot; + Math.abs(-444));</span><br><span class="line"></span><br><span class="line">console.log(&quot;acos() Math对象方法：&quot; + Math.acos(0.5));</span><br><span class="line"></span><br><span class="line">console.log(&quot;asin() Math对象方法：&quot; + Math.asin(0.5));</span><br><span class="line"></span><br><span class="line">console.log(&quot;atan() Math对象方法：&quot; + Math.atan(1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;atan2() Math对象方法：&quot; + Math.atan2(1, 1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;cos() Math对象方法：&quot; + Math.cos(0.5));</span><br><span class="line"></span><br><span class="line">console.log(&quot;sin() Math对象方法：&quot; + Math.sin(0.5));</span><br><span class="line"></span><br><span class="line">console.log(&quot;tan() Math对象方法：&quot; + Math.tan(2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;ceil() Math对象方法：&quot; + Math.ceil(1.1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;floor() Math对象方法：&quot; + Math.floor(2.1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;round(x) Math对象方法：&quot; + Math.round(6.5));</span><br><span class="line"></span><br><span class="line">console.log(&quot;exp(x) Math对象方法：&quot; + Math.exp(2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;log(x) Math对象方法：&quot; + Math.log(2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;sqrt(x) Math对象方法：&quot; + Math.sqrt(4));</span><br><span class="line"></span><br><span class="line">console.log(&quot;pow(x,y) Math对象方法：&quot; + Math.pow(1,2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;max(x,y) Math对象方法：&quot; + Math.max(1,2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;min(x,y) Math对象方法：&quot; + Math.min(1,2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;random() Math对象方法：&quot; + Math.random());</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。与我们再JavaScript直接编写的计算功能相比，Math对象提
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Date对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/27/JavaScript-Date%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/27/JavaScript-Date对象属性与方法/</id>
    <published>2019-09-27T07:12:06.000Z</published>
    <updated>2019-09-27T08:22:10.316Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><p>ECMAScript在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC时间1970年1月1日午夜起至该日期止的毫秒数）。</p><p>Date 对象，Date 对象用于处理日期和时间。</p><p>创建 Date 对象的语法：</p><p><code>var myDate=new Date()</code></p><p>注释：Date 对象会自动把当前日期和时间保存为其初始值。</p><h4 id="Date-对象属性"><a href="#Date-对象属性" class="headerlink" title="Date 对象属性"></a>Date 对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">constructor</td><td>返回对创建此对象的 Date 函数的引用。</td></tr><tr><td align="center">prototype</td><td>使您有能力向对象添加属性和方法。</td></tr></tbody></table><h4 id="Date-对象方法"><a href="#Date-对象方法" class="headerlink" title="Date 对象方法"></a>Date 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">Date()</td><td>返回当日的日期和时间。</td></tr><tr><td align="center">getDate()</td><td>从 Date 对象返回一个月中的某一天 (1 ~ 31)。</td></tr><tr><td align="center">getDay()</td><td>从 Date 对象返回一周中的某一天 (0 ~ 6)。</td></tr><tr><td align="center">getMonth()</td><td>从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td align="center">getFullYear()</td><td>从 Date 对象以四位数字返回年份。</td></tr><tr><td align="center">getYear()</td><td>请使用 getFullYear() 方法代替。</td></tr><tr><td align="center">getHours()</td><td>返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td align="center">getMinutes()</td><td>返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td align="center">getSeconds()</td><td>返回 Date 对象的秒数 (0 ~ 59)。</td></tr><tr><td align="center">getMilliseconds()</td><td>返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td align="center">getTime()</td><td>返回 1970 年 1 月 1 日至今的毫秒数。</td></tr><tr><td align="center">getTimezoneOffset()</td><td>返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td></tr><tr><td align="center">getUTCDate()</td><td>根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td></tr><tr><td align="center">getUTCDay()</td><td>根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td></tr><tr><td align="center">getUTCMonth()</td><td>根据世界时从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td align="center">getUTCFullYear()</td><td>根据世界时从 Date 对象返回四位数的年份。</td></tr><tr><td align="center">getUTCHours()</td><td>根据世界时返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td align="center">getUTCMinutes()</td><td>根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td align="center">getUTCSeconds()</td><td>根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td></tr><tr><td align="center">getUTCMilliseconds()</td><td>根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td align="center">parse()</td><td>返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td></tr><tr><td align="center">setDate()</td><td>设置 Date 对象中月的某一天 (1 ~ 31)。</td></tr><tr><td align="center">setMonth()</td><td>设置 Date 对象中月份 (0 ~ 11)。</td></tr><tr><td align="center">setFullYear()</td><td>设置 Date 对象中的年份（四位数字）。</td></tr><tr><td align="center">setYear()</td><td>请使用 setFullYear() 方法代替。</td></tr><tr><td align="center">setHours()</td><td>设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td align="center">setMinutes()</td><td>设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td align="center">setSeconds()</td><td>设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td align="center">setMilliseconds()</td><td>设置 Date 对象中的毫秒 (0 ~ 999)。</td></tr><tr><td align="center">setTime()</td><td>以毫秒设置 Date 对象。</td></tr><tr><td align="center">setUTCDate()</td><td>根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td></tr><tr><td align="center">setUTCMonth()</td><td>根据世界时设置 Date 对象中的月份 (0 ~ 11)。</td></tr><tr><td align="center">setUTCFullYear()</td><td>根据世界时设置 Date 对象中的年份（四位数字）。</td></tr><tr><td align="center">setUTCHours()</td><td>根据世界时设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td align="center">setUTCMinutes()</td><td>根据世界时设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td align="center">setUTCSeconds()</td><td>根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td align="center">setUTCMilliseconds()</td><td>根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。</td></tr><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">toString()</td><td>把 Date 对象转换为字符串。</td></tr><tr><td align="center">toTimeString()</td><td>把 Date 对象的时间部分转换为字符串。</td></tr><tr><td align="center">toDateString()</td><td>把 Date 对象的日期部分转换为字符串。</td></tr><tr><td align="center">toGMTString()</td><td>请使用 toUTCString() 方法代替。</td></tr><tr><td align="center">toUTCString()</td><td>根据世界时，把 Date 对象转换为字符串。</td></tr><tr><td align="center">toLocaleString()</td><td>根据本地时间格式，把 Date 对象转换为字符串。</td></tr><tr><td align="center">toLocaleTimeString()</td><td>根据本地时间格式，把 Date 对象的时间部分转换为字符串。</td></tr><tr><td align="center">toLocaleDateString()</td><td>根据本地时间格式，把 Date 对象的日期部分转换为字符串。</td></tr><tr><td align="center">UTC()</td><td>根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。</td></tr><tr><td align="center">valueOf()</td><td>返回 Date 对象的原始值。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date();</span><br><span class="line"></span><br><span class="line">console.log(&quot;Date() Date对象方法：&quot; + date);</span><br><span class="line"></span><br><span class="line">console.log(&quot;getDate() Date对象方法：&quot; + date.getDate());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getDay() Date对象方法：&quot; + date.getDay());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getMonth() Date对象方法：&quot; + (date.getMonth() + 1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;getFullYear() Date对象方法：&quot; + date.getFullYear());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getHours() Date对象方法：&quot; + date.getHours());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getMinutes() Date对象方法：&quot; + date.getMinutes());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getSeconds() Date对象方法：&quot; + date.getSeconds());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getMilliseconds() Date对象方法：&quot; + date.getMilliseconds());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getTimezoneOffset() Date对象方法：&quot; + date.getTimezoneOffset());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCDate() Date对象方法：&quot; + date.getUTCDate());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCDay() Date对象方法：&quot; + date.getUTCDay());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCMonth() Date对象方法：&quot; + (date.getUTCMonth() + 1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCFullYear() Date对象方法：&quot; + date.getUTCFullYear());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCHours() Date对象方法：&quot; + date.getUTCHours());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCMinutes() Date对象方法：&quot; + date.getUTCMinutes());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCSeconds() Date对象方法：&quot; + date.getUTCSeconds());</span><br><span class="line"></span><br><span class="line">console.log(&quot;getUTCMilliseconds() Date对象方法：&quot; + date.getUTCMilliseconds());</span><br><span class="line"></span><br><span class="line">console.log(&quot;setDate() Date对象方法：&quot; + date.setDate(15));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setMonth() Date对象方法：&quot; + date.setMonth(2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setFullYear() Date对象方法：&quot; + date.setFullYear(2017));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setHours() Date对象方法：&quot; + date.setHours(12));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setMinutes() Date对象方法：&quot; + date.setMinutes(45));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setSeconds() Date对象方法：&quot; + date.setSeconds(50));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setMilliseconds() Date对象方法：&quot; + date.setMilliseconds(999));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCDate() Date对象方法：&quot; + date.setUTCDate(22));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCMonth() Date对象方法：&quot; + date.setUTCMonth(3));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCFullYear() Date对象方法：&quot; + date.setUTCFullYear(2015));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCHours() Date对象方法：&quot; + date.setUTCHours(0));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCMinutes() Date对象方法：&quot; + date.setUTCMinutes(59));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCSeconds() Date对象方法：&quot; + date.setUTCSeconds(59));</span><br><span class="line"></span><br><span class="line">console.log(&quot;setUTCMilliseconds() Date对象方法：&quot; + date.setUTCMilliseconds(999));</span><br><span class="line"></span><br><span class="line">console.log(date)</span><br><span class="line"></span><br><span class="line">// console.log(&quot;toSource() Date对象方法：&quot; + date.toSource());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toString() Date对象方法：&quot; + typeof(date.toString()) + &quot; &quot; + date.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toTimeString() Date对象方法：&quot; + date.toTimeString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toDateString() Date对象方法：&quot; + date.toDateString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toGMTString() Date对象方法：&quot; + date.toGMTString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toUTCString() Date对象方法：&quot; + date.toUTCString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toLocaleString() Date对象方法：&quot; + date.toLocaleString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toLocaleTimeString() Date对象方法：&quot; + date.toLocaleTimeString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toLocaleDateString() Date对象方法：&quot; + date.toLocaleDateString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;UTC() Date对象方法：&quot; + Date.UTC(2014,12,1));</span><br><span class="line"></span><br><span class="line">console.log(&quot;valueOf() Date对象方法：&quot; + date.valueOf());</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;ECMAScript在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Boolean对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/27/JavaScript-Boolean%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/27/JavaScript-Boolean对象属性与方法/</id>
    <published>2019-09-27T07:08:21.000Z</published>
    <updated>2019-09-27T07:10:23.173Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><p>Boolean 对象，Boolean 对象表示两个值：”true” 或 “false”。</p><p>创建 Boolean 对象的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Boolean(value);//构造函数</span><br><span class="line">Boolean(value);//转换函数</span><br></pre></td></tr></table></figure><p>参数</p><p>参数 value 由布尔对象存放的值或者要转换成布尔值的值。</p><p>返回值</p><p>当作为一个构造函数（带有运算符 new）调用时，Boolean() 将把它的参数转换成一个布尔值，并且返回一个包含该值的 Boolean 对象。</p><p>如果作为一个函数（不带有运算符 new）调用时，Boolean() 只将把它的参数转换成一个原始的布尔值，并且返回这个值。</p><p>注释：如果省略 value 参数，或者设置为 0、-0、null、””、false、undefined 或 NaN，则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 “false”）。</p><h4 id="Boolean-对象属性"><a href="#Boolean-对象属性" class="headerlink" title="Boolean 对象属性"></a>Boolean 对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">constructor</td><td>返回对创建此对象的 Boolean 函数的引用</td></tr><tr><td align="center">prototype</td><td>使您有能力向对象添加属性和方法。</td></tr></tbody></table><h4 id="Boolean-对象方法"><a href="#Boolean-对象方法" class="headerlink" title="Boolean 对象方法"></a>Boolean 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">toString()</td><td>把逻辑值转换为字符串，并返回结果。</td></tr><tr><td align="center">valueOf()</td><td>返回 Boolean 对象的原始值。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;Boolean 对象，Boolean 对象表示两个值：”true” 或 “false”。&lt;/p&gt;&lt;p&gt;创建 Boolean 对象的语法：&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Array对象属性与方法</title>
    <link href="https://liushuai97.github.io/2019/09/27/JavaScript-Array%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95/"/>
    <id>https://liushuai97.github.io/2019/09/27/JavaScript-Array对象属性与方法/</id>
    <published>2019-09-27T06:40:43.000Z</published>
    <updated>2019-09-27T06:40:52.861Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><p>除了Object之外，Array类型恐怕是ECMAScrip中最常用的类型了。而且，ECMAScript中的数组与其他多数语言中的数组有着很大的区别。虽然ECMAScript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，EMCAScript数组的每一项可以保存任何类型的数据。也就是说，可以用数组的第一个位置来保存字符串，用第二位置来保存数值，用第三个位置来保存对象，以此类推。而且，ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。</p><p>JavaScript 本地对象和内置对象。</p><p>Array 对象，Array 对象用于在单个的变量中存储多个值。</p><p>创建Array对象的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Array();</span><br><span class="line">new Array(size);</span><br><span class="line">new Array(element0,element1m,...,elementn);</span><br></pre></td></tr></table></figure><p>参数</p><p>参数size是期望数组元素个数。返回的数组，length字段将被设为size的值。<br>参数element…,elementn是参数列表。当使用这些参数来调用构造函数Array()时，新创建的数组的元素就会被初始化为这些值。它的length字段也会被设置为参数的个数。</p><p>返回值</p><p>返回新创建并被初始化了的数组。<br>如果调用构造函数Array()时没有使用参数，那么返回的数组为空，length字段未0。<br>当调用构造函数时只传递给它一个数字参数，该构造函数将返回具有指定个数、元素为undefined的数组。<br>当其他参数调用Array()时，该构造函数将用参数指定的值初始化数组。<br>当把构造函数作为函数调用，不使用 new 运算符时，它的行为与使用 new 运算符调用它时的行为完全一样。</p><h4 id="Array-对象属性"><a href="#Array-对象属性" class="headerlink" title="Array 对象属性"></a>Array 对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">constructor</td><td>返回对创建此对象的数组函数的引用。</td></tr><tr><td align="center">length</td><td>设置或返回数组中元素的数目。</td></tr><tr><td align="center">prototype</td><td>使您有能力向对象添加属性和方法。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var obj = new Array();</span><br><span class="line"></span><br><span class="line">obj = [&quot;ab&quot;,2,3,5,6,7,8,9,10];</span><br><span class="line"></span><br><span class="line">console.log(&quot;new Array() 创建数组：&quot;+obj);</span><br><span class="line"></span><br><span class="line">var type = Array.isArray(obj);</span><br><span class="line"></span><br><span class="line">console.log(&quot;Array.isArray(obj) 检测数组类型：&quot; + type);</span><br><span class="line"></span><br><span class="line">console.log(&quot;constructor 数组属性：&quot;+obj.constructor);</span><br><span class="line"></span><br><span class="line">console.log(&quot;length 数组属性：&quot; + obj.length);</span><br><span class="line"></span><br><span class="line">Array.prototype.name = 10</span><br><span class="line"></span><br><span class="line">Array.prototype.changed = function () &#123;</span><br><span class="line">    for(var i = 0; i &lt; this.length; i++ )&#123;</span><br><span class="line">        var tp = typeof(this[i]);</span><br><span class="line">        if(tp === &quot;string&quot;)&#123;</span><br><span class="line">            this[i] = this[i].toUpperCase();</span><br><span class="line">        &#125;</span><br><span class="line">        if(tp === &quot;number&quot;)&#123;</span><br><span class="line">            this[i] = this[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            this[i] = this[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.changed();</span><br><span class="line">console.log(&quot;prototype 数组属性：&quot; + obj.name + &quot;|&quot; + obj);</span><br></pre></td></tr></table></figure><h3 id="Array对象方法"><a href="#Array对象方法" class="headerlink" title="Array对象方法"></a>Array对象方法</h3><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">concat()</td><td>连接两个或更多的数组，不会改变现有的数组，而仅仅会返回被连接数组的一个副本。</td></tr><tr><td align="center">join()</td><td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td></tr><tr><td align="center">pop()</td><td>删除并返回数组的最后一个元素。</td></tr><tr><td align="center">push()</td><td>向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="center">reverse()</td><td>颠倒数组中元素的顺序。</td></tr><tr><td align="center">shift()</td><td>删除并返回数组的第一个元素。</td></tr><tr><td align="center">slice()</td><td>从某个已有的数组返回选定的元素。</td></tr><tr><td align="center">sort()</td><td>对数组的元素进行排序。</td></tr><tr><td align="center">splice()</td><td>删除元素，并向数组添加新元素。</td></tr><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">toString()</td><td>把数组转换为字符串，并返回结果。</td></tr><tr><td align="center">toLocaleString()</td><td>把数组转换为本地数组，并返回结果。</td></tr><tr><td align="center">unshift()</td><td>向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="center">valueOf()</td><td>返回数组对象的原始值。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var a = Array(&quot;张三&quot;, &quot;李四&quot;);</span><br><span class="line"></span><br><span class="line">var b = new Array(&quot;王五&quot;, &quot;陈六&quot;);</span><br><span class="line"></span><br><span class="line">var c = a.concat(b)</span><br><span class="line"></span><br><span class="line">console.log(&quot;concat() 数组方法：原始值——&quot; + a + &quot;|返回值——&quot; + c);</span><br><span class="line"></span><br><span class="line">console.log(&quot;join() 数组方法：&quot; + c.join(&apos;|&apos;));</span><br><span class="line"></span><br><span class="line">console.log(&quot;pop() 数组方法：&quot; + c.pop() + &quot;|删除后的值——&quot; + c);</span><br><span class="line"></span><br><span class="line">console.log(&quot;push() 数组方法：&quot; + c.push(&quot;赵七&quot;) + &quot;|追加后的值——&quot; + c);</span><br><span class="line"></span><br><span class="line">console.log(&quot;reverse() 数组方法：&quot; + c.reverse());</span><br><span class="line"></span><br><span class="line">console.log(&quot;shift() 数组方法：&quot; + c.shift() + &quot;|删除后的值——&quot; + c);</span><br><span class="line"></span><br><span class="line">console.log(&quot;slice() 数组方法：&quot; + c.slice(-2));</span><br><span class="line"></span><br><span class="line">console.log(&quot;sort() 数组方法：&quot; + c.sort());</span><br><span class="line"></span><br><span class="line">console.log(&quot;splice() 数组方法：&quot; + c.splice(2,1,&quot;替换&quot;) + &quot;|删除后的值——&quot; + c);</span><br><span class="line"></span><br><span class="line">// 只有 Gecko 核心的浏览器（比如 Firefox）支持该方法，也就是说 IE、Safari、Chrome、Opera 等浏览器均不支持该方法。</span><br><span class="line">// console.log(&quot;toSource() 数组方法：&quot; + c.toSource());</span><br><span class="line"></span><br><span class="line">console.log(&quot;toString() 数组方法：&quot; + typeof(c.toString()) + &quot; | &quot; + typeof(c));</span><br><span class="line"></span><br><span class="line">console.log(&quot;toLocaleString() 数组方法：&quot; + typeof(c.toLocaleString()) + &quot; | &quot; + typeof(c));</span><br><span class="line"></span><br><span class="line">console.log(&quot;unshift() 数组方法：&quot; + c.unshift(&quot;开头&quot;,&quot;添加&quot;) + &quot;添加后的值——&quot; + c);</span><br><span class="line"></span><br><span class="line">console.log(&quot;valueOf() 数组方法：&quot; + c.valueOf());</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;除了Object之外，Array类型恐怕是ECMAScrip中最常用的类型了。而且，ECMAScript中的数组与其他多数语言中的数组有着很大的
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 继承</title>
    <link href="https://liushuai97.github.io/2019/09/25/JavaScript-%E7%BB%A7%E6%89%BF/"/>
    <id>https://liushuai97.github.io/2019/09/25/JavaScript-继承/</id>
    <published>2019-09-25T02:18:24.000Z</published>
    <updated>2019-09-25T02:53:36.911Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>在 js 中, 方法定义在原型对象中, 而属性定义在实例对象中,调用方法的时候, 实例对象本身是没有该成员的, 但是依旧可以调用该方法, 好像这个方法就是该实例对象的一样. 因此, 我们称该实例对象继承自原型对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var Person=&#123;</span><br><span class="line">  sayHello:function()&#123;</span><br><span class="line">    console.log(&apos;我是&apos;+this.name+&apos;今年&apos;+this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//student构造函数</span><br><span class="line">function Student(name,age)&#123;</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这里把Person对象赋值到Student构造函数的原型对象上，这样Student构造函数的实例就可以运用Person对象的方法</span><br><span class="line">Student.prototype=Person;</span><br><span class="line"></span><br><span class="line">//根据Student构造函数创建一个实例对象s1.</span><br><span class="line">var s1=new Student(&apos;lilei&apos;,18);</span><br><span class="line"></span><br><span class="line">s1.sayHello();</span><br></pre></td></tr></table></figure><h4 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h4><p>就是将一个对象中的成员加到另一个对象中（通过自定义 extend 方法完成继承）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var obj2= &#123;</span><br><span class="line">  name:&apos;lilei&apos;,</span><br><span class="line">  sayHello:function()&#123;</span><br><span class="line">      console.log(&apos;我是&apos;+this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj3= &#123;</span><br><span class="line">  age:18,</span><br><span class="line">  sayHello1:function()&#123;</span><br><span class="line">    console.log(&apos;我是&apos;+this.name+&apos;今年&apos;+this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1=&#123;</span><br><span class="line">  extend:function(obj)&#123;</span><br><span class="line"></span><br><span class="line">    //arguments为函数中默认的对象，里面存储着所有的函数传入参数。</span><br><span class="line">    for(var i=0; i&lt; arguments.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">      for(var k in arguments[i])&#123;</span><br><span class="line">          this[k]=arguments[i][k];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//将obj2和obj3混入到obj1中</span><br><span class="line">obj1.extend(obj2,obj3);</span><br><span class="line"></span><br><span class="line">obj1.sayHello();</span><br><span class="line"></span><br><span class="line">obj1.sayHello1();</span><br></pre></td></tr></table></figure><h4 id="混合式继承"><a href="#混合式继承" class="headerlink" title="混合式继承"></a>混合式继承</h4><p>将多个对象的各个功能混合在一起，就是通过混入的方式，加到构造函数的原型（prototype）上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var Person=&#123;</span><br><span class="line">    sayHello:function()&#123;</span><br><span class="line">      console.log(&apos;我是&apos;+this.name+&apos;今年&apos;+this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function Student(name,age)&#123;//student构造函数</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype.extend=function(obj)&#123;</span><br><span class="line">  for(var k in obj)&#123;</span><br><span class="line">    this[k]=obj[k];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据Student构造函数创建一个实例对象s1.</span><br><span class="line">var s1=new Student(&apos;lilei&apos;,18);</span><br><span class="line"></span><br><span class="line">// 根据Student构造函数创建一个实例对象s2.</span><br><span class="line">var s2=new Student(&apos;lllli&apos;,18);</span><br><span class="line"></span><br><span class="line">// 这样就是Student构造函数继承了Person对象。所有Student构造函数创建的实例都要Pserson对象的方法</span><br><span class="line">Student.prototype.extend(Person);</span><br><span class="line"></span><br><span class="line">// 这样就是Student构造函数的实例s1继承了Person对象。其他Student构造函数创建的实例都没有Pserson对象的方法</span><br><span class="line">// s1.extend(Person);</span><br><span class="line"></span><br><span class="line">s1.sayHello();</span><br><span class="line">s2.sayHello();</span><br></pre></td></tr></table></figure><ul><li>关于继承 ES5 中给我们内置了一个快速的方法：Object.create(对象)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">  name:&apos;lilei&apos;,</span><br><span class="line">  age:16,</span><br><span class="line">  sayHello:function()&#123;</span><br><span class="line">    console.log(&apos;我是&apos;+this.name+&apos;今年&apos;+this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//ES5中内置的Object.create()方法可以让我们快速的继承</span><br><span class="line">var obj=Object.create(o);</span><br><span class="line"></span><br><span class="line">obj.sayHello();</span><br></pre></td></tr></table></figure><h4 id="上下文调用实现继承"><a href="#上下文调用实现继承" class="headerlink" title="上下文调用实现继承"></a>上下文调用实现继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var Person=&#123;</span><br><span class="line">  sayHello:function()&#123;</span><br><span class="line">    console.log(&apos;我是&apos;+this.name+&apos;今年&apos;+this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Student(name,age)&#123;//student构造函数</span><br><span class="line">  this.name=name;</span><br><span class="line">  this.age=age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//根据Student构造函数创建一个实例对象s1.</span><br><span class="line">var s1=new Student(&apos;lilei&apos;,18);</span><br><span class="line"></span><br><span class="line">//根据Student构造函数创建一个实例对象s2.</span><br><span class="line">var s2=new Student(&apos;lllli&apos;,18);</span><br><span class="line"></span><br><span class="line">Person.sayHello.call(s2)；</span><br></pre></td></tr></table></figure><h4 id="ES6-的继承"><a href="#ES6-的继承" class="headerlink" title="ES6 的继承"></a>ES6 的继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// es6继承</span><br><span class="line">class Animal &#123;</span><br><span class="line"></span><br><span class="line">  //构造函数，里面写上对象的属性</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    this.name = props.name || &apos;Unknown&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //方法写在后面</span><br><span class="line">  eat() &#123;</span><br><span class="line">    //父类共有的方法</span><br><span class="line">    console.log(this.name + &quot; will eat pests.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//class继承</span><br><span class="line">class Bird extends Animal &#123;</span><br><span class="line"></span><br><span class="line">  //构造函数</span><br><span class="line">  //props是继承过来的属性，myAttribute是自己的属性</span><br><span class="line">  constructor(props,myAttribute) &#123;</span><br><span class="line">    //调用实现父类的构造函数</span><br><span class="line">    //相当于获得父类的this指向</span><br><span class="line">    super(props)</span><br><span class="line"></span><br><span class="line">    //父类的属性，也可写在父类中</span><br><span class="line">    this.type = props.type || &quot;Unknown&quot;;</span><br><span class="line"></span><br><span class="line">    //自己的私有属性</span><br><span class="line">    this.attr = myAttribute;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //自己私有的方法</span><br><span class="line">  fly() &#123;</span><br><span class="line">    console.log(this.name + &quot; are friendly to people.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //自己私有的方法</span><br><span class="line">  myattr() &#123;</span><br><span class="line">    console.log(this.type+&apos;---&apos;+this.attr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过new实例化</span><br><span class="line">var myBird = new Bird(&#123;</span><br><span class="line">  name: &apos;小燕子&apos;,</span><br><span class="line"></span><br><span class="line">  //卵生动物</span><br><span class="line">  type: &apos;Egg animal&apos;</span><br><span class="line">&#125;,&apos;Bird class&apos;)</span><br><span class="line"></span><br><span class="line">myBird.eat()</span><br><span class="line">myBird.fly()</span><br><span class="line">myBird.myattr()</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;原型式继承&quot;&gt;&lt;a href=&quot;#原型式继承&quot; class=&quot;headerlink&quot; title=&quot;原型式继承&quot;&gt;&lt;/a&gt;原型式继承&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript异步代码优化</title>
    <link href="https://liushuai97.github.io/2019/09/25/JavaScript%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    <id>https://liushuai97.github.io/2019/09/25/JavaScript异步代码优化/</id>
    <published>2019-09-25T01:19:27.000Z</published>
    <updated>2019-09-25T02:49:27.386Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="callback"><a href="#callback" class="headerlink" title="callback"></a>callback</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">传递函数作为回调</span><br><span class="line">function(ag1,ag2...,callback) &#123;</span><br><span class="line">　 // 业务逻辑代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callback 顾名思义便是回调，但并不是将回调内容放在异步方法里，而是放到外部的回调函数中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window.mytest = function(str, callback) &#123;</span><br><span class="line">    printStr(str) ;</span><br><span class="line">    var res = test_callback();</span><br><span class="line">    callback(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function printStr(str) &#123;</span><br><span class="line">    alert(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test_callback() &#123;</span><br><span class="line">    return &quot;回调测试&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此我们看似异步的代码变成了同步的写法，避免了层层嵌套的写法，看上去也流畅了很多。同时使用 callback 也是异步编程最基础和核心的一种解决思路。</p><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>基于 callback，Promise 目前也被广泛运用，其是异步编程的一种解决方案，比传统的回调函数解决方案更合理和强大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise(test).then(function (result) &#123;</span><br><span class="line">  console.log(&apos;成功：&apos; + result);</span><br><span class="line">&#125;).catch(function (reason) &#123;</span><br><span class="line">  console.log(&apos;失败：&apos; + reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然如果要等待多个异步请求完成执行某些操作，可以使用 Promise.all 方法，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let p = Promise.all([p1, p2, p3]); // 其中p1、p2、p3都是Promise实例</span><br><span class="line">p.then(result =&gt; console.log(result));</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">p1.then(p2).then(p3).catch(handleError); // 其中p1、p2、p3都是Promise实例</span><br></pre></td></tr></table></figure><p>当然 Promise 也有其相应的缺点，比如下一个 then 回调只能获取上一个 then 返回的数据，不能跨层获取，同时大量的 then 回调也会使代码不容易维护。</p><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><p>generator 跟函数很像，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* foo(x) &#123;</span><br><span class="line">    yield x + 1;</span><br><span class="line">    yield x + 2;</span><br><span class="line">    return x + 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// generator和函数不同的是，generator由function*定义（注意多出的*号），并且，除了return语句，还可以用yield返回多次。</span><br></pre></td></tr></table></figure><p>要编写一个产生斐波那契数列的函数，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function* fib(max) &#123;</span><br><span class="line">  var</span><br><span class="line">    t,</span><br><span class="line">    a = 0,</span><br><span class="line">    b = 1,</span><br><span class="line">    n = 0;</span><br><span class="line">  while (n &lt; max) &#123;</span><br><span class="line">    yield a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">    n ++;</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用 generator 对象有两个方法</li></ul><ol><li>不断地调用 generator 对象的 next()方法：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var f = fib(5);</span><br><span class="line">f.next(); // &#123;value: 0, done: false&#125;</span><br><span class="line">f.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">f.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">f.next(); // &#123;value: 2, done: false&#125;</span><br><span class="line">f.next(); // &#123;value: 3, done: false&#125;</span><br><span class="line">f.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p>next()方法会执行 generator 的代码，然后，每次遇到 yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的 value 就是 yield 的返回值，done 表示这个 generator 是否已经执行结束了。如果 done 为 true，则 value 就是 return 的返回值。</p><ol start="2"><li>直接用 for … of 循环迭代 generator 对象，这种方式不需要我们自己判断 done：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var x of fib(10)) &#123;</span><br><span class="line">  console.log(x); // 依次输出0, 1, 1, 2, 3, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>缺点：Generator 函数的缺点在于，我们每一次执行 yield 语句都需要手动进行 next，不是很方便。</li><li>优点：把异步回调代码变成“同步”代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  r1 = yield ajax(&apos;http://url-1&apos;, data1);</span><br><span class="line">  r2 = yield ajax(&apos;http://url-2&apos;, data2);</span><br><span class="line">  r3 = yield ajax(&apos;http://url-3&apos;, data3);</span><br><span class="line">  success(r3);</span><br><span class="line">&#125;</span><br><span class="line">catch (err) &#123;</span><br><span class="line">  handle(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="async-and-await"><a href="#async-and-await" class="headerlink" title="async and await"></a>async and await</h4><p>ES7 还提供了更加方便的 async 函数和 await 命令，其实 async 是 Generator 函数的语法糖，不同点在于其内置了执行器，也就是说 async 函数自带执行器。</p><ul><li>async 的用法</li></ul><p>它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为 async 就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function timeout() &#123;</span><br><span class="line">　return &apos;hello world&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// async 函数返回的是一个promise 对象，如果要获取到promise 返回值，我们应该用then 方法。</span><br><span class="line"></span><br><span class="line">timeout().then(result =&gt; &#123;</span><br><span class="line">    console.log(result);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;虽然在后面，但是我先执行&apos;);</span><br></pre></td></tr></table></figure><ul><li>await 关键字</li></ul><p>顾名思义， await 就是异步等待，它等待的是一个 Promise，因此 await 后面应该写一个 Promise 对象，如果不是 Promise 对象，那么会被转成一个立即 resolve 的 Promise。注意 await 关键字只能放到 async 函数里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">async function sayHi_async(name) &#123;</span><br><span class="line">  try&#123;</span><br><span class="line"></span><br><span class="line">    const sayHi_1 = await sayHi(name)</span><br><span class="line">    console.log(`你好， $&#123;sayHi_1&#125;`)</span><br><span class="line"></span><br><span class="line">    const sayHi_2 = await sayHi(&apos;李四&apos;)</span><br><span class="line">    console.log(`你好， $&#123;sayHi_2&#125;`)</span><br><span class="line"></span><br><span class="line">    const sayHi_3 = await sayHi(&apos;王二麻子&apos;)</span><br><span class="line">    console.log(`你好， $&#123;sayHi_3&#125;`)</span><br><span class="line"></span><br><span class="line">  &#125; catch (err)&#123;</span><br><span class="line">    </span><br><span class="line">    console.log(err)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 执行</span><br><span class="line">sayHi_async(&apos;张三&apos;)</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">console.log(&quot;你好， 张三&quot;)</span><br><span class="line">console.log(&quot;你好， 李四&quot;)</span><br><span class="line">console.log(&quot;你好， 王二麻子&quot;)</span><br></pre></td></tr></table></figure><p>async函数调用不会造成代码的阻塞，但是await会引起async函数内部代码的阻塞。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;callback&quot;&gt;&lt;a href=&quot;#callback&quot; class=&quot;headerlink&quot; title=&quot;callback&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题10</title>
    <link href="https://liushuai97.github.io/2019/09/25/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%9810/"/>
    <id>https://liushuai97.github.io/2019/09/25/JavaScript-自测题10/</id>
    <published>2019-09-25T00:59:55.000Z</published>
    <updated>2019-09-25T02:48:55.457Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><ol><li><p>arguments对象和Function是分不开的。</p></li><li><p>因为arguments这个对象不能显式创建。</p></li><li><p>arguments对象只有函数开始时才可用。</p></li></ol><p>arguments<a href>0</a>的意思，和arguments.0()的意思差不多（当然这么写是不允许的），你更可以这么理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arguments = &#123;</span><br><span class="line">    0: fn, //也就是 functon() &#123;alert(this.length)&#125; </span><br><span class="line">    1: 第二个参数, //没有 </span><br><span class="line">    2: 第三个参数, //没有</span><br><span class="line">    ..., </span><br><span class="line">    length: 1 //只有一个参数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var length = 10;</span><br><span class="line"></span><br><span class="line">function fn()&#123;</span><br><span class="line">  console.log(this.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  length:5,</span><br><span class="line">  method:function(fn)&#123;</span><br><span class="line">      fn();</span><br><span class="line">      arguments[0]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.method(fn,1);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">第一个 fn  this指向window   输出10</span><br><span class="line">第二个 arguments[0]() 可以理解为arguments.0() [只是方便理解] ，</span><br><span class="line">            即argument对象调用fn函数，所以this指向arguments对象</span><br><span class="line">arguments = &#123;</span><br><span class="line">  0:fn,    //function fn()&#123;console.log(this.length);&#125;</span><br><span class="line">  1:第二个参数 1，</span><br><span class="line">  length:2</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><ul><li>延伸</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var len = 10;</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  len:6,</span><br><span class="line">  method:function()&#123;</span><br><span class="line">      console.log(this.len);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  len:5,</span><br><span class="line">  method:function(fn)&#123;</span><br><span class="line">      fn();</span><br><span class="line">      arguments[0](); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj2.method(obj1.method,obj2.method);  // 10 undefined</span><br><span class="line">/*</span><br><span class="line">第一个 fn  this指向window   输出10</span><br><span class="line">第二个 arguments[0]()    this指向arguments</span><br><span class="line">arguments = &#123;</span><br><span class="line">  0:obj1.method,   //function()&#123;console.log(this.len);&#125;</span><br><span class="line">  1:obj2.method,</span><br><span class="line">  length:2</span><br><span class="line">&#125;</span><br><span class="line">arguments没有len属性，所以为undefined</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;arguments&quot;&gt;&lt;a href=&quot;#arguments&quot; class=&quot;headerlink&quot; title=&quot;arguments
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题9</title>
    <link href="https://liushuai97.github.io/2019/09/25/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%989/"/>
    <id>https://liushuai97.github.io/2019/09/25/JavaScript-自测题9/</id>
    <published>2019-09-25T00:10:28.000Z</published>
    <updated>2019-09-25T02:48:51.762Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="typeof返回值范围："><a href="#typeof返回值范围：" class="headerlink" title="typeof返回值范围："></a>typeof返回值范围：</h4><p>typeof返回值对应</p><table><thead><tr><th align="center">类型</th><th>结果</th></tr></thead><tbody><tr><td align="center">String</td><td>“string”</td></tr><tr><td align="center">Number</td><td>“number”</td></tr><tr><td align="center">Boolean</td><td>“boolean”</td></tr><tr><td align="center">Undefined</td><td>“undefined”</td></tr><tr><td align="center">Null</td><td>“object”</td></tr><tr><td align="center">Object</td><td>“object”</td></tr><tr><td align="center">function函数对象</td><td>“function”</td></tr><tr><td align="center">Symbol(ES6新增)</td><td>“symbol”</td></tr><tr><td align="center">宿主对象(由JS环境提供)</td><td>Implementation-dependent</td></tr></tbody></table><h4 id="typeof的不足之处"><a href="#typeof的不足之处" class="headerlink" title="typeof的不足之处"></a>typeof的不足之处</h4><ol><li>不能区分对象、数组、正则，对它们操作都返回”object”；（正则特殊一点后面说）</li><li>Safar5,Chrome7之前的版本对正则对象返回 ‘function’</li><li>在IE6,7和8中，大多数的宿主对象是对象，而不是函数；如：typeof alert; //object</li><li>而在非ID浏览器或则IE9以上（包含IE9），typeof alert; //function</li></ol><h4 id="特殊中的特殊"><a href="#特殊中的特殊" class="headerlink" title="特殊中的特殊"></a>特殊中的特殊</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typeof 1/0; //NaN（这个NaN不是字符串类型，是数值类型）</span><br><span class="line">typeof typeof 1/0; //NaN（这个NaN不是字符串类型，是数值类型）</span><br><span class="line">typeof(1/0); //&quot;number&quot;</span><br><span class="line">typeof typeof(1/0); //&quot;string&quot;</span><br><span class="line">typeof(typeof 1/0); //&quot;number&quot;</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// Numbers</span><br><span class="line">typeof 37 === &apos;number&apos;;</span><br><span class="line">typeof 3.14 === &apos;number&apos;;</span><br><span class="line">typeof Math.LN2 === &apos;number&apos;;</span><br><span class="line">typeof Infinity === &apos;number&apos;;</span><br><span class="line">typeof NaN === &apos;number&apos;; // 尽管NaN是&quot;Not-A-Number&quot;的缩写</span><br><span class="line">typeof Number(1) === &apos;number&apos;; // 但不要使用这种形式!</span><br><span class="line"></span><br><span class="line">// Strings</span><br><span class="line">typeof &quot;&quot; === &apos;string&apos;;</span><br><span class="line">typeof &quot;bla&quot; === &apos;string&apos;;</span><br><span class="line">typeof (typeof 1) === &apos;string&apos;; // typeof总是返回一个字符串</span><br><span class="line">typeof String(&quot;abc&quot;) === &apos;string&apos;; // 但不要使用这种形式!</span><br><span class="line"></span><br><span class="line">// Booleans</span><br><span class="line">typeof true === &apos;boolean&apos;;</span><br><span class="line">typeof false === &apos;boolean&apos;;</span><br><span class="line">typeof Boolean(true) === &apos;boolean&apos;; // 但不要使用这种形式!</span><br><span class="line"></span><br><span class="line">// Symbols</span><br><span class="line">typeof Symbol() === &apos;symbol&apos;;</span><br><span class="line">typeof Symbol(&apos;foo&apos;) === &apos;symbol&apos;;</span><br><span class="line">typeof Symbol.iterator === &apos;symbol&apos;;</span><br><span class="line"></span><br><span class="line">// Undefined</span><br><span class="line">typeof undefined === &apos;undefined&apos;;</span><br><span class="line">typeof declaredButUndefinedVariable === &apos;undefined&apos;;</span><br><span class="line">typeof undeclaredVariable === &apos;undefined&apos;; </span><br><span class="line"></span><br><span class="line">// Objects</span><br><span class="line">typeof &#123;a:1&#125; === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">// 使用Array.isArray 或者 Object.prototype.toString.call</span><br><span class="line">// 区分数组,普通对象</span><br><span class="line">typeof [1, 2, 4] === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">typeof new Date() === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">// 下面的容易令人迷惑，不要使用！</span><br><span class="line">typeof new Boolean(true) === &apos;object&apos;;</span><br><span class="line">typeof new Number(1) ==== &apos;object&apos;;</span><br><span class="line">typeof new String(&quot;abc&quot;) === &apos;object&apos;;</span><br><span class="line"></span><br><span class="line">// 函数</span><br><span class="line">typeof function()&#123;&#125; === &apos;function&apos;;</span><br><span class="line">typeof Math.sin === &apos;function&apos;;</span><br><span class="line"></span><br><span class="line">//NaN</span><br><span class="line">typeof 1/0 === &apos;NaN&apos;;</span><br></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ol><li>this的值通常是由当前函数的执行环境所决定；</li><li>在全局作用域，this指向全局对象 (window对象)；</li><li>当使用new关键字声明，this指向新建对象；</li><li>我们可以使用call(), bind(), apply()来设置this；</li><li>箭头函数不会绑定this。</li></ol><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var test = function test() &#123;</span><br><span class="line">    /* body... */</span><br><span class="line">    test = 1;</span><br><span class="line">    console.log(typeof test)   //function</span><br><span class="line">&#125;;</span><br><span class="line">test();</span><br><span class="line">test = 1;</span><br><span class="line">console.log(typeof test);  // number</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;typeof返回值范围：&quot;&gt;&lt;a href=&quot;#typeof返回值范围：&quot; class=&quot;headerlink&quot; title=&quot;typ
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题8</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%988/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题8/</id>
    <published>2019-09-23T09:30:52.000Z</published>
    <updated>2019-09-25T02:48:48.027Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="JavaScript-正则表达式"><a href="#JavaScript-正则表达式" class="headerlink" title="JavaScript 正则表达式"></a>JavaScript 正则表达式</h4><ul><li>语法</li></ul><p>/正则表达式主体/修饰符(可选)</p><ul><li>使用字符串方法</li></ul><p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p><ol><li><p>search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p></li><li><p>replace() 方法 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p></li></ol><h4 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h4><ul><li>修饰符可以在全局搜索中不区分大小写:</li></ul><table><thead><tr><th align="center">修饰符</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>执行对大小写不敏感的匹配。</td></tr><tr><td align="center">g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td align="center">m</td><td>执行多行匹配。</td></tr></tbody></table><h4 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h4><ul><li>方括号用于查找某个范围内的字符：</li></ul><table><thead><tr><th align="center">表达式</th><th>描述</th></tr></thead><tbody><tr><td align="center">[abc]</td><td>查找方括号之间的任何字符。</td></tr><tr><td align="center">[0-9]</td><td>查找任何从 0 至 9 的数字。</td></tr><tr><td align="center">(x</td><td>y)</td></tr></tbody></table><ul><li>元字符是拥有特殊含义的字符：</li></ul><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center">\d</td><td>查找数字。</td></tr><tr><td align="center">\s</td><td>查找空白字符。</td></tr><tr><td align="center">\b</td><td>匹配单词边界。</td></tr><tr><td align="center">\uxxxx</td><td>查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><ul><li>量词:</li></ul><table><thead><tr><th align="center">量词</th><th>描述</th></tr></thead><tbody><tr><td align="center">n+</td><td>匹配任何包含至少一个 n 的字符串。</td></tr><tr><td align="center">n*</td><td>匹配任何包含零个或多个 n 的字符串。</td></tr><tr><td align="center">n?</td><td>匹配任何包含零个或一个 n 的字符串。</td></tr></tbody></table><h4 id="使用-RegExp-对象"><a href="#使用-RegExp-对象" class="headerlink" title="使用 RegExp 对象"></a>使用 RegExp 对象</h4><p>在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。</p><h4 id="使用-test"><a href="#使用-test" class="headerlink" title="使用 test()"></a>使用 test()</h4><p>test() 方法是一个正则表达式方法。</p><p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p><h4 id="使用-exec"><a href="#使用-exec" class="headerlink" title="使用 exec()"></a>使用 exec()</h4><p>exec() 方法是一个正则表达式方法。</p><p>exec() 方法用于检索字符串中的正则表达式的匹配。</p><p>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p><ul><li><p>RegExp.prototype.exec()和RegExp.prototype.test一样，在设置了g修饰符之后，每次执行都会设置lastIndex，从而影响下一次匹配的结果。</p></li><li><p>在一个包含g修饰符的正则上使用RegExp.prototype.test()函数</p></li></ul><p>如果正则表达式被设置了g修饰符，RegExp.prototype.test()函数会在每一次调用后设置正则表达式的lastIndex值。在其后调用的test()会从这个lastIndex索引位置开始匹配（RegExp.prototype.exec()函数也遵循同样的规则）。如果前后传入不同的字符串作为参数，RegExp.prototype.test()的结果就是没有意义的。</p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var regex = /foo/g;</span><br><span class="line"></span><br><span class="line">// regex.lastIndex = 0</span><br><span class="line">regex.test(&apos;foo&apos;); // true</span><br><span class="line"></span><br><span class="line">// regex.lastIndex = 3</span><br><span class="line">regex.test(&apos;foo&apos;); // false</span><br><span class="line"></span><br><span class="line">// regex.lastIndex = 0</span><br><span class="line">regex.test(&apos;barfoo&apos;) // true</span><br><span class="line"></span><br><span class="line">// regex.lastIndex = 6</span><br><span class="line">regex.test(&apos;foobar&apos;) //false</span><br></pre></td></tr></table></figure><p>利用这种机制，下面的代码建立了一个函数，用来查找在一个字符串中一共有多少单词：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function countWords (sText) &#123;</span><br><span class="line">  for (var rWord = /\w+/g, nCount = 0; rWord.test(sText); nCount++);</span><br><span class="line">  return nCount;</span><br><span class="line">&#125;</span><br><span class="line">console.log(countWords(&quot;What a beautiful day!&quot;)); // 4</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;JavaScript-正则表达式&quot;&gt;&lt;a href=&quot;#JavaScript-正则表达式&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题7</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%987/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题7/</id>
    <published>2019-09-23T08:56:17.000Z</published>
    <updated>2019-09-25T02:48:42.546Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h4><p>String 对象方法</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">anchor()</td><td>创建 HTML 锚。</td></tr><tr><td align="center">big()</td><td>用大号字体显示字符串。</td></tr><tr><td align="center">blink()</td><td>显示闪动字符串。</td></tr><tr><td align="center">bold()</td><td>使用粗体显示字符串。</td></tr><tr><td align="center">charAt()</td><td>返回在指定位置的字符。</td></tr><tr><td align="center">charCodeAt()</td><td>返回在指定的位置的字符的 Unicode 编码。</td></tr><tr><td align="center">concat()</td><td>连接字符串。</td></tr><tr><td align="center">fixed()</td><td>以打字机文本显示字符串。</td></tr><tr><td align="center">fontcolor()</td><td>使用指定的颜色来显示字符串。</td></tr><tr><td align="center">fontsize()</td><td>使用指定的尺寸来显示字符串。</td></tr><tr><td align="center">fromCharCode()</td><td>从字符编码创建一个字符串。</td></tr><tr><td align="center">indexOf()</td><td>检索字符串。</td></tr><tr><td align="center">italics()</td><td>使用斜体显示字符串。</td></tr><tr><td align="center">lastIndexOf()</td><td>从后向前搜索字符串。</td></tr><tr><td align="center">link()</td><td>将字符串显示为链接。</td></tr><tr><td align="center">localeCompare()</td><td>用本地特定的顺序来比较两个字符串。</td></tr><tr><td align="center">match()</td><td>找到一个或多个正则表达式的匹配。</td></tr><tr><td align="center">replace()</td><td>替换与正则表达式匹配的子串。</td></tr><tr><td align="center">search()</td><td>检索与正则表达式相匹配的值。</td></tr><tr><td align="center">slice()</td><td>提取字符串的片断，并在新的字符串中返回被提取的部分。</td></tr><tr><td align="center">small()</td><td>使用小字号来显示字符串。</td></tr><tr><td align="center">split()</td><td>把字符串分割为字符串数组。</td></tr><tr><td align="center">strike()</td><td>使用删除线来显示字符串。</td></tr><tr><td align="center">sub()</td><td>把字符串显示为下标。</td></tr><tr><td align="center">substr()</td><td>从起始索引号提取字符串中指定数目的字符。</td></tr><tr><td align="center">substring()</td><td>提取字符串中两个指定的索引号之间的字符。</td></tr><tr><td align="center">sup()</td><td>把字符串显示为上标。</td></tr><tr><td align="center">toLocaleLowerCase()</td><td>把字符串转换为小写。</td></tr><tr><td align="center">toLocaleUpperCase()</td><td>把字符串转换为大写。</td></tr><tr><td align="center">toLowerCase()</td><td>把字符串转换为小写。</td></tr><tr><td align="center">toUpperCase()</td><td>把字符串转换为大写。</td></tr><tr><td align="center">toSource()</td><td>代表对象的源代码。</td></tr><tr><td align="center">toString()</td><td>返回字符串。</td></tr><tr><td align="center">valueOf()</td><td>返回某个字符串对象的原始值。</td></tr></tbody></table><h4 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h4><p>Array 对象方法</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">concat()</td><td>连接两个或更多的数组，并返回结果。</td></tr><tr><td align="center">join()</td><td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td></tr><tr><td align="center">pop()</td><td>删除并返回数组的最后一个元素</td></tr><tr><td align="center">push()</td><td>向数组的末尾添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="center">reverse()</td><td>颠倒数组中元素的顺序。</td></tr><tr><td align="center">shift()</td><td>删除并返回数组的第一个元素</td></tr><tr><td align="center">slice()</td><td>从某个已有的数组返回选定的元素</td></tr><tr><td align="center">sort()</td><td>对数组的元素进行排序</td></tr><tr><td align="center">splice()</td><td>删除元素，并向数组添加新元素。</td></tr><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">toString()</td><td>把数组转换为字符串，并返回结果。</td></tr><tr><td align="center">toLocaleString()</td><td>把数组转换为本地数组，并返回结果。</td></tr><tr><td align="center">unshift()</td><td>向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td align="center">valueOf()</td><td>返回数组对象的原始值</td></tr></tbody></table><h4 id="常用数组-字符串方法与遍历"><a href="#常用数组-字符串方法与遍历" class="headerlink" title="常用数组/字符串方法与遍历"></a>常用数组/字符串方法与遍历</h4><p>javascript有很多遍历的方法，for、for in、for of（ES6）、forEach、map、filter、every、some、Jquery的each等等。</p><ol><li>for 循环</li></ol><p>for循环语句，最基础的遍历，以数组的下标为索引，对数组元素进行遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrFor(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      for (var k = 0; k &lt; arr.length; k++) &#123;</span><br><span class="line">          ret += arr[k];</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array for 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array for 报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for 循环不是函数，不存在返回值。</li></ul><ol start="2"><li>for in</li></ol><p>for in循环不仅可以遍历数组，还可以遍历对象，但for in存在一些陷阱，比如它会在遍历完元素之后，还会对数组或对象的prototype中的属性进行遍历，所以，for in 更像是为对象遍历而设计的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrForIn(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      for (var k in arr) &#123;</span><br><span class="line">          ret += arr[k];</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array for in 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array for in报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>for of (ES6)</li></ol><p>ES6中引入了 for … of 循环，以替代 for…in 和 forEach() ，允许对 Array(数组)、String(字符串)、Maps(映射)、Sets(集合)等可迭代的数据结构进行遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrForOf(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      for(var k of arr) &#123;</span><br><span class="line">          ret += k;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array for of 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array for of报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for(var k of arr) 中的 k ，就是数组 arr 中的元素，而不是数组的下标。</li><li>IE 不支持，Edge支持。</li></ul><ol start="4"><li>forEach</li></ol><p>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrForEach(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      arr.forEach(function (v, k) &#123;</span><br><span class="line">          ret += v;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array forEach 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array forEach报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>forEach() 对于空数组是不会执行回调函数的。</p></li><li><p>回调函数 function (v, k) 中的 k 是数组的下标，v 是数组元素值。</p></li><li><p>IE9以下的版本不支持。</p><ol start="5"><li>map</li></ol><p>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrMap(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      arr.map(function (v, k) &#123;</span><br><span class="line">          ret += v;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array map 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array map报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map() 返回一个新数组。</li><li>map() 不会对空数组进行检测。</li><li>map() 不会改变原始数组。</li></ul><ol start="6"><li>filter</li></ol><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function arrFilter(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      arr.filter(function (v, k) &#123;</span><br><span class="line">          ret += v;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array filter 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array filter报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>filter() 不会对空数组进行检测。</li><li>filter() 不会改变原始数组。</li></ul><ol start="7"><li>every</li></ol><p>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供），返回 boolen。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function arrEvery(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var st = performance.now();</span><br><span class="line">      var ret = arr.every(function (v, k) &#123;</span><br><span class="line">          return v.length &gt; 1;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array every 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array every报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li><li>如果所有元素都满足条件，则返回 true。</li><li>every() 不会对空数组进行检测。</li><li>every() 不会改变原始数组。</li></ul><ol start="8"><li>some</li></ol><p>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。只要有一个元素满足则返回true，并不再继续往下判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function arrSome(arr) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">      var st = performance.now();</span><br><span class="line">      var ret = arr.some(function (v, k) &#123;</span><br><span class="line">          return v.length &gt; 1;</span><br><span class="line">      &#125;);</span><br><span class="line">      console.log(ret);</span><br><span class="line">      var diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;array some 总耗时：&quot; + diff);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">      console.log(&quot;array some报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。</li><li>如果没有满足条件的元素，则返回false。</li><li>some() 不会对空数组进行检测。</li><li>some() 不会改变原始数组。</li></ul><ol start="9"><li>Object.keys.forEach</li></ol><p>Object.keys.forEach() 主要是用于遍历对象，获取对象的属性名，对于遍历数组意义不大。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function objectKey(obj) &#123;</span><br><span class="line">  try&#123;</span><br><span class="line">      var ret = &apos;&apos;,</span><br><span class="line">          st = performance.now();</span><br><span class="line">      Object.keys(obj).forEach(function(key, index, arr) &#123;</span><br><span class="line">          ret += obj[key];</span><br><span class="line">      &#125;);</span><br><span class="line">      //ES6写法</span><br><span class="line">      //Object.keys(obj).forEach(k =&gt; &#123;</span><br><span class="line">      //    ret += obj[k];</span><br><span class="line">      //&#125;);　</span><br><span class="line">      console.log(ret);</span><br><span class="line">      let diff = performance.now() - st;</span><br><span class="line">      console.log(&quot;object key 总耗时：&quot; + diff);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (e)&#123;</span><br><span class="line">      console.log(&quot;object key 报错了：&quot; + e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Object.keys.forEach 在遍历时，回调函数的参数 key是属性名（对于数组，属性名和索引一一对应)，index 是keys数组的索引，arr是keys数组；所以在取值的时候还是用 obj[key]</p></li><li><p>例题：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a =&apos;abc&apos;</span><br><span class="line">a.split().every(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;);</span><br><span class="line">a.split().map(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;)</span><br><span class="line">a.split().forEach(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;)</span><br><span class="line">a.split().filter(function  (v, k) &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;String-对象&quot;&gt;&lt;a href=&quot;#String-对象&quot; class=&quot;headerlink&quot; title=&quot;String 对象
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题6</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%986/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题6/</id>
    <published>2019-09-23T08:52:11.000Z</published>
    <updated>2019-09-25T02:48:37.905Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h4><p>Math 对象用于执行数学任务。</p><p>使用 Math 的属性和方法的语法：<br>var pi_value=Math.PI;<br>var sqrt_value=Math.sqrt(15);<br>注释：Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。</p><h4 id="Math-对象属性"><a href="#Math-对象属性" class="headerlink" title="Math 对象属性"></a>Math 对象属性</h4><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">E</td><td>返回算术常量 e，即自然对数的底数（约等于2.718）。</td></tr><tr><td align="center">LN2</td><td>返回 2 的自然对数（约等于0.693）。</td></tr><tr><td align="center">LN10</td><td>返回 10 的自然对数（约等于2.302）。</td></tr><tr><td align="center">LOG2E</td><td>返回以 2 为底的 e 的对数（约等于 1.414）。</td></tr><tr><td align="center">LOG10E</td><td>返回以 10 为底的 e 的对数（约等于0.434）。</td></tr><tr><td align="center">PI</td><td>返回圆周率（约等于3.14159）。</td></tr><tr><td align="center">SQRT1_2</td><td>返回返回 2 的平方根的倒数（约等于 0.707）。</td></tr><tr><td align="center">SQRT2</td><td>返回 2 的平方根（约等于 1.414）。</td></tr></tbody></table><h4 id="Math-对象方法"><a href="#Math-对象方法" class="headerlink" title="Math 对象方法"></a>Math 对象方法</h4><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">abs(x)</td><td>返回数的绝对值。</td></tr><tr><td align="center">acos(x)</td><td>返回数的反余弦值。</td></tr><tr><td align="center">asin(x)</td><td>返回数的反正弦值。</td></tr><tr><td align="center">atan(x)</td><td>以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td></tr><tr><td align="center">atan2(y,x)</td><td>返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。</td></tr><tr><td align="center">ceil(x)</td><td>对数进行上舍入。</td></tr><tr><td align="center">cos(x)</td><td>返回数的余弦。</td></tr><tr><td align="center">exp(x)</td><td>返回 e 的指数。</td></tr><tr><td align="center">floor(x)</td><td>对数进行下舍入。</td></tr><tr><td align="center">log(x)</td><td>返回数的自然对数（底为e）。</td></tr><tr><td align="center">max(x,y)</td><td>返回 x 和 y 中的最高值。</td></tr><tr><td align="center">min(x,y)</td><td>返回 x 和 y 中的最低值。</td></tr><tr><td align="center">pow(x,y)</td><td>返回 x 的 y 次幂。</td></tr><tr><td align="center">random()</td><td>返回 0 ~ 1 之间的随机数。</td></tr><tr><td align="center">round(x)</td><td>把数四舍五入为最接近的整数。</td></tr><tr><td align="center">sin(x)</td><td>返回数的正弦。</td></tr><tr><td align="center">sqrt(x)</td><td>返回数的平方根。</td></tr><tr><td align="center">tan(x)</td><td>返回角的正切。</td></tr><tr><td align="center">toSource()</td><td>返回该对象的源代码。</td></tr><tr><td align="center">valueOf()</td><td>返回 Math 对象的原始值。</td></tr></tbody></table><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function lv (num) &#123;</span><br><span class="line">  var lv = 11 - Math.ceil(num/10);</span><br><span class="line">  console.log(lv + &apos;等生&apos;);</span><br><span class="line">&#125;</span><br><span class="line">lv(91)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;Math-对象&quot;&gt;&lt;a href=&quot;#Math-对象&quot; class=&quot;headerlink&quot; title=&quot;Math 对象&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题5</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%985/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题5/</id>
    <published>2019-09-23T08:12:09.000Z</published>
    <updated>2019-09-25T02:48:33.530Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h4><ul><li><p>栈：栈，只允许在一段进行插入或者删除操作的线性表，是一种先进后出的数据结构。</p></li><li><p>堆：堆是基于散列算法的数据结构。</p></li><li><p>队列：队列是一种先进先出（FIFO）的数据结构。</p></li></ul><h4 id="JavaScript中数据类型的存储"><a href="#JavaScript中数据类型的存储" class="headerlink" title="JavaScript中数据类型的存储"></a>JavaScript中数据类型的存储</h4><p>JavaScript中将数据类型分为基本数据类型和引用数据类型，它们其中有一个区别就是存储的位置不同。</p><ul><li>基本数据类型</li></ul><p>我们都知道JavaScript中的基本数据类型有：</p><p>String<br>Number<br>Boolean<br>Undefined<br>Null<br>Symbol（暂时不管）<br>基本数据类型都是一些简单的数据段，它们是存储在栈内存中。</p><ul><li>引用数据类型</li></ul><p>JavaScript中的引用数据类型有：</p><p>Array<br>Object<br>引用数据类型是保存在堆内存中的，然后再栈内存中保存一个对堆内存中实际对象的引用。所以，JavaScript中对引用数据类型的操作都是操作对象的引用而不是实际的对象。</p><p>可以理解为，栈内存中保存了一个地址，这个地址和堆内存中的实际值是相关的。</p><p><img src="ti6.png" alt="kyrie irving"></p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><ul><li>基本数据类型</li></ul><p>对于基本数据类型，如果进行复制，系统会自动为新的变量在栈内存中分配一个新值，很容易理解。</p><ul><li>引用数据类型</li></ul><p>如果对于数组、对象这样的引用数据类型而言，复制的时候就会有所区别了：</p><p>系统也会自动为新的变量在栈内存中分配一个值，但这个值仅仅是一个地址。也就是说，复制出来的变量和原有的变量具有相同的地址值，指向堆内存中的同一个对象。</p><p><img src="ti7.png" alt="kyrie irving"></p><ul><li>为什么基础数据类型存在栈中，而引用数据类型存在堆中呢？</li></ul><ol><li>堆比栈大，栈比对速度快。</li><li>基础数据类型比较稳定，而且相对来说占用的内存小。</li><li>引用数据类型大小是动态的，而且是无限的。</li><li>堆内存是无序存储，可以根据引用直接获取。</li></ol><ul><li>例题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test (m) &#123;</span><br><span class="line">  m = &#123; v: 5 &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var m = &#123; k: 30 &#125;;</span><br><span class="line">test(m);</span><br><span class="line">alert(m.v);</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti8.png" alt="kyrie irving"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;基本数据结构&quot;&gt;&lt;a href=&quot;#基本数据结构&quot; class=&quot;headerlink&quot; title=&quot;基本数据结构&quot;&gt;&lt;/a&gt;基本数
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题4</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%984/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题4/</id>
    <published>2019-09-23T07:18:49.000Z</published>
    <updated>2019-09-25T02:48:28.179Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h4><ul><li>Document 对象集合</li></ul><table><thead><tr><th align="center">集合</th><th>描述</th></tr></thead><tbody><tr><td align="center">all[]</td><td>提供对文档中所有 HTML 元素的访问。</td></tr><tr><td align="center">anchors[]</td><td>返回对文档中所有 Anchor 对象的引用。</td></tr><tr><td align="center">applets</td><td>返回对文档中所有 Applet 对象的引用。</td></tr><tr><td align="center">forms[]</td><td>返回对文档中所有 Form 对象引用。</td></tr><tr><td align="center">images[]</td><td>返回对文档中所有 Image 对象引用。</td></tr><tr><td align="center">links[]</td><td>返回对文档中所有 Area 和 Link 对象引用。</td></tr></tbody></table><ul><li>Document 对象属性</li></ul><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">body</td><td>提供对<body>元素的直接访问。对于定义了框架集的文档，该属性引用最外层的<frameset>。</frameset></body></td></tr><tr><td align="center">cookie</td><td>设置或返回与当前文档有关的所有 cookie。</td></tr><tr><td align="center">domain</td><td>返回当前文档的域名。</td></tr><tr><td align="center">lastModified</td><td>返回文档被最后修改的日期和时间。</td></tr><tr><td align="center">referrer</td><td>返回载入当前文档的文档的 URL。</td></tr><tr><td align="center">title</td><td>返回当前文档的标题。</td></tr><tr><td align="center">URL</td><td>返回当前文档的 URL。</td></tr></tbody></table><ul><li>Document 对象方法</li></ul><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">close()</td><td>关闭用 document.open() 方法打开的输出流，并显示选定的数据。</td></tr><tr><td align="center">getElementById()</td><td>返回对拥有指定 id 的第一个对象的引用。</td></tr><tr><td align="center">getElementsByName()</td><td>返回带有指定名称的对象集合。</td></tr><tr><td align="center">getElementsByTagName()</td><td>返回带有指定标签名的对象集合。</td></tr><tr><td align="center">open()</td><td>打开一个流，以收集来自任何 document.write() 或 document.writeln() 方法的输出。</td></tr><tr><td align="center">write()</td><td>向文档写 HTML 表达式 或 JavaScript 代码。</td></tr><tr><td align="center">writeln()</td><td>等同于 write() 方法，不同的是在每个表达式之后写一个换行符。</td></tr></tbody></table><h4 id="Element-对象"><a href="#Element-对象" class="headerlink" title="Element 对象"></a>Element 对象</h4><table><thead><tr><th align="center">属性 / 方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">element.accessKey</td><td>设置或返回元素的快捷键。</td></tr><tr><td align="center">element.appendChild()</td><td>向元素添加新的子节点，作为最后一个子节点。</td></tr><tr><td align="center">element.attributes</td><td>返回元素属性的 NamedNodeMap。</td></tr><tr><td align="center">element.childNodes</td><td>返回元素子节点的 NodeList。</td></tr><tr><td align="center">element.className</td><td>设置或返回元素的 class 属性。</td></tr><tr><td align="center">element.clientHeight</td><td>返回元素的可见高度。</td></tr><tr><td align="center">element.clientWidth</td><td>返回元素的可见宽度。</td></tr><tr><td align="center">element.cloneNode()</td><td>克隆元素。</td></tr><tr><td align="center">element.compareDocumentPosition()</td><td>比较两个元素的文档位置。</td></tr><tr><td align="center">element.contentEditable</td><td>设置或返回元素的文本方向。</td></tr><tr><td align="center">element.dir</td><td>设置或返回元素的内容是否可编辑。</td></tr><tr><td align="center">element.firstChild</td><td>返回元素的首个子。</td></tr><tr><td align="center">element.getAttribute()</td><td>返回元素节点的指定属性值。</td></tr><tr><td align="center">element.getAttributeNode()</td><td>返回指定的属性节点。</td></tr><tr><td align="center">element.getElementsByTagName()</td><td>返回拥有指定标签名的所有子元素的集合。</td></tr><tr><td align="center">element.getFeature()</td><td>返回实现了指定特性的 API 的某个对象。</td></tr><tr><td align="center">element.getUserData()</td><td>返回关联元素上键的对象。</td></tr><tr><td align="center">element.hasAttribute()</td><td>如果元素拥有指定属性，则返回true，否则返回 false。</td></tr><tr><td align="center">element.hasAttributes()</td><td>如果元素拥有属性，则返回 true，否则返回 false。</td></tr><tr><td align="center">element.hasChildNodes()</td><td>如果元素拥有子节点，则返回 true，否则 false。</td></tr><tr><td align="center">element.id</td><td>设置或返回元素的 id。</td></tr><tr><td align="center">element.innerHTML</td><td>设置或返回元素的内容。</td></tr><tr><td align="center">element.insertBefore()</td><td>在指定的已有的子节点之前插入新节点。</td></tr><tr><td align="center">element.isContentEditable</td><td>设置或返回元素的内容。</td></tr><tr><td align="center">element.isDefaultNamespace()</td><td>如果指定的 namespaceURI 是默认的，则返回 true，否则返回 false。</td></tr><tr><td align="center">element.isEqualNode()</td><td>检查两个元素是否相等。</td></tr><tr><td align="center">element.isSameNode()</td><td>检查两个元素是否是相同的节点。</td></tr><tr><td align="center">element.isSupported()</td><td>如果元素支持指定特性，则返回 true。</td></tr><tr><td align="center">element.lang</td><td>设置或返回元素的语言代码。</td></tr><tr><td align="center">element.lastChild</td><td>返回元素的最后一个子元素。</td></tr><tr><td align="center">element.namespaceURI</td><td>返回元素的 namespace URI。</td></tr><tr><td align="center">element.nextSibling</td><td>返回位于相同节点树层级的下一个节点。</td></tr><tr><td align="center">element.nodeName</td><td>返回元素的名称。</td></tr><tr><td align="center">element.nodeType</td><td>返回元素的节点类型。</td></tr><tr><td align="center">element.nodeValue</td><td>设置或返回元素值。</td></tr><tr><td align="center">element.normalize()</td><td>合并元素中相邻的文本节点，并移除空的文本节点。</td></tr><tr><td align="center">element.offsetHeight</td><td>返回元素的高度。</td></tr><tr><td align="center">element.offsetWidth</td><td>返回元素的宽度。</td></tr><tr><td align="center">element.offsetLeft</td><td>返回元素的水平偏移位置。</td></tr><tr><td align="center">element.offsetParent</td><td>返回元素的偏移容器。</td></tr><tr><td align="center">element.offsetTop</td><td>返回元素的垂直偏移位置。</td></tr><tr><td align="center">element.ownerDocument</td><td>返回元素的根元素（文档对象）。</td></tr><tr><td align="center">element.parentNode</td><td>返回元素的父节点。</td></tr><tr><td align="center">element.previousSibling</td><td>返回位于相同节点树层级的前一个元素。</td></tr><tr><td align="center">element.removeAttribute()</td><td>从元素中移除指定属性。</td></tr><tr><td align="center">element.removeAttributeNode()</td><td>移除指定的属性节点，并返回被移除的节点。</td></tr><tr><td align="center">element.removeChild()</td><td>从元素中移除子节点。</td></tr><tr><td align="center">element.replaceChild()</td><td>替换元素中的子节点。</td></tr><tr><td align="center">element.scrollHeight</td><td>返回元素的整体高度。</td></tr><tr><td align="center">element.scrollLeft</td><td>返回元素左边缘与视图之间的距离。</td></tr><tr><td align="center">element.scrollTop</td><td>返回元素上边缘与视图之间的距离。</td></tr><tr><td align="center">element.scrollWidth</td><td>返回元素的整体宽度。</td></tr><tr><td align="center">element.setAttribute()</td><td>把指定属性设置或更改为指定值。</td></tr><tr><td align="center">element.setAttributeNode()</td><td>设置或更改指定属性节点。</td></tr><tr><td align="center">element.setIdAttribute()</td><td>预留</td></tr><tr><td align="center">element.setIdAttributeNode()</td><td>预留</td></tr><tr><td align="center">element.setUserData()</td><td>把对象关联到元素上的键。</td></tr><tr><td align="center">element.style</td><td>设置或返回元素的 style 属性。</td></tr><tr><td align="center">element.tabIndex</td><td>设置或返回元素的 tab 键控制次序。</td></tr><tr><td align="center">element.tagName</td><td>返回元素的标签名。</td></tr><tr><td align="center">element.textContent</td><td>设置或返回节点及其后代的文本内容。</td></tr><tr><td align="center">element.title</td><td>设置或返回元素的 title 属性。</td></tr><tr><td align="center">element.toString()</td><td>把元素转换为字符串。</td></tr><tr><td align="center">nodelist.item()</td><td>返回 NodeList 中位于指定下标的节点。</td></tr><tr><td align="center">nodelist.length</td><td>返回 NodeList 中的节点数。</td></tr></tbody></table><h4 id="Attr-对象"><a href="#Attr-对象" class="headerlink" title="Attr 对象"></a>Attr 对象</h4><table><thead><tr><th align="center">属性 / 方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">attr.isId</td><td>如果属性是 id 类型，则返回 true，否则返回 false。</td></tr><tr><td align="center">attr.name</td><td>返回属性的名称。</td></tr><tr><td align="center">attr.value</td><td>设置或返回属性的值。</td></tr><tr><td align="center">attr.specified</td><td>如果已指定属性，则返回 true，否则返回 false。</td></tr><tr><td align="center">nodemap.getNamedItem()</td><td>从 NamedNodeMap 返回指定的属性节点。</td></tr><tr><td align="center">nodemap.item()</td><td>返回 NamedNodeMap 中位于指定下标的节点。</td></tr><tr><td align="center">nodemap.length</td><td>返回 NamedNodeMap 中的节点数。</td></tr><tr><td align="center">nodemap.removeNamedItem()</td><td>移除指定的属性节点。</td></tr><tr><td align="center">nodemap.setNamedItem()</td><td>设置指定的属性节点（通过名称）。</td></tr></tbody></table><ul><li>DOM 4 警告！</li></ul><p>在 W3C DOM Core 中，Attr (attribute) 对象从 Node 对象继承所有属性和方法。</p><p>在 DOM 4 中，Attr 对象不再从 Node 继承。</p><p>为了保证未来的代码安全，您应该避免在属性对象上使用节点对象的属性和方法：</p><table><thead><tr><th align="center">属性 / 方法</th><th>避免的理由</th></tr></thead><tbody><tr><td align="center">attr.appendChild()</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.attributes</td><td>属性没有属性。</td></tr><tr><td align="center">attr.baseURI</td><td>使用 document.baseURI 代替。</td></tr><tr><td align="center">attr.childNodes</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.cloneNode()</td><td>使用 attr.value 代替。</td></tr><tr><td align="center">attr.firstChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.hasAttributes()</td><td>属性没有属性。</td></tr><tr><td align="center">attr.hasChildNodes</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.insertBefore()</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.isEqualNode()</td><td>没有意义。</td></tr><tr><td align="center">attr.isSameNode()</td><td>没有意义。</td></tr><tr><td align="center">attr.isSupported()</td><td>始终为 true。</td></tr><tr><td align="center">attr.lastChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.nextSibling</td><td>属性没有同级节点。</td></tr><tr><td align="center">attr.nodeName</td><td>使用 attr.name 代替。</td></tr><tr><td align="center">attr.nodeType</td><td>始终为 2 (ATTRIBUTE_NODE)。</td></tr><tr><td align="center">attr.nodeValue</td><td>使用 attr.value 代替。</td></tr><tr><td align="center">attr.normalize()</td><td>属性无法被正常化。</td></tr><tr><td align="center">attr.ownerDocument</td><td>始终是您的 HTML 文档。</td></tr><tr><td align="center">attr.ownerElement</td><td>这是您用来访问该属性的 HTML 元素。</td></tr><tr><td align="center">attr.parentNode</td><td>这是您用来访问该属性的 HTML 元素。</td></tr><tr><td align="center">attr.previousSibling</td><td>属性没有同级节点。</td></tr><tr><td align="center">attr.removeChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.replaceChild</td><td>属性没有子节点。</td></tr><tr><td align="center">attr.textContent</td><td>使用 attr.value 代替。</td></tr></tbody></table><h4 id="Event-对象"><a href="#Event-对象" class="headerlink" title="Event 对象"></a>Event 对象</h4><p>Event 对象代表事件的状态，比如事件在其中发生的元素、键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p><p>事件通常与函数结合使用，函数不会在事件发生前被执行！</p><ul><li>事件句柄　(Event Handlers)</li></ul><p>HTML 4.0 的新特性之一是能够使 HTML 事件触发浏览器中的行为，比如当用户点击某个 HTML 元素时启动一段 JavaScript。下面是一个属性列表，可将之插入 HTML 标签以定义事件的行为。</p><table><thead><tr><th align="center">属性</th><th>此事件发生在何时…</th></tr></thead><tbody><tr><td align="center">onabort</td><td>图像的加载被中断。</td></tr><tr><td align="center">onblur</td><td>元素失去焦点。</td></tr><tr><td align="center">onchange</td><td>域的内容被改变。</td></tr><tr><td align="center">onclick</td><td>当用户点击某个对象时调用的事件句柄。</td></tr><tr><td align="center">ondblclick</td><td>当用户双击某个对象时调用的事件句柄。</td></tr><tr><td align="center">onerror</td><td>在加载文档或图像时发生错误。</td></tr><tr><td align="center">onfocus</td><td>元素获得焦点。</td></tr><tr><td align="center">onkeydown</td><td>某个键盘按键被按下。</td></tr><tr><td align="center">onkeypress</td><td>某个键盘按键被按下并松开。</td></tr><tr><td align="center">onkeyup</td><td>某个键盘按键被松开。</td></tr><tr><td align="center">onload</td><td>一张页面或一幅图像完成加载。</td></tr><tr><td align="center">onmousedown</td><td>鼠标按钮被按下。</td></tr><tr><td align="center">onmousemove</td><td>鼠标被移动。</td></tr><tr><td align="center">onmouseout</td><td>鼠标从某元素移开。</td></tr><tr><td align="center">onmouseover</td><td>鼠标移到某元素之上。</td></tr><tr><td align="center">onmouseup</td><td>鼠标按键被松开。</td></tr><tr><td align="center">onreset</td><td>重置按钮被点击。</td></tr><tr><td align="center">onresize</td><td>窗口或框架被重新调整大小。</td></tr><tr><td align="center">onselect</td><td>文本被选中。</td></tr><tr><td align="center">onsubmit</td><td>确认按钮被点击。</td></tr><tr><td align="center">onunload</td><td>用户退出页面。</td></tr></tbody></table><ul><li>鼠标 / 键盘属性</li></ul><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">altKey</td><td>返回当事件被触发时，”ALT” 是否被按下。</td></tr><tr><td align="center">button</td><td>返回当事件被触发时，哪个鼠标按钮被点击。</td></tr><tr><td align="center">clientX</td><td>返回当事件被触发时，鼠标指针的水平坐标。</td></tr><tr><td align="center">clientY</td><td>返回当事件被触发时，鼠标指针的垂直坐标。</td></tr><tr><td align="center">ctrlKey</td><td>返回当事件被触发时，”CTRL” 键是否被按下。</td></tr><tr><td align="center">metaKey</td><td>返回当事件被触发时，”meta” 键是否被按下。</td></tr><tr><td align="center">relatedTarget</td><td>返回与事件的目标节点相关的节点。</td></tr><tr><td align="center">screenX</td><td>返回当某个事件被触发时，鼠标指针的水平坐标。</td></tr><tr><td align="center">screenY</td><td>返回当某个事件被触发时，鼠标指针的垂直坐标。</td></tr><tr><td align="center">shiftKey</td><td>返回当事件被触发时，”SHIFT” 键是否被按下。</td></tr></tbody></table><ul><li>IE 属性<br>除了上面的鼠标/事件属性，IE 浏览器还支持下面的属性：</li></ul><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">cancelBubble</td><td>如果事件句柄想阻止事件传播到包容对象，必须把该属性设为 true。</td></tr><tr><td align="center">fromElement</td><td>对于 mouseover 和 mouseout 事件，fromElement 引用移出鼠标的元素。</td></tr><tr><td align="center">keyCode</td><td>对于 keypress 事件，该属性声明了被敲击的键生成的 Unicode 字符码。对于 keydown 和 keyup 事件，它指定了被敲击的键的虚拟键盘码。虚拟键盘码可能和使用的键盘的布局相关。</td></tr><tr><td align="center">offsetX,offsetY</td><td>发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。</td></tr><tr><td align="center">returnValue</td><td>如果设置了该属性，它的值比事件句柄的返回值优先级高。把这个属性设置为 fasle，可以取消发生事件的源元素的默认动作。</td></tr><tr><td align="center">srcElement</td><td>对于生成事件的 Window 对象、Document 对象或 Element 对象的引用。</td></tr><tr><td align="center">toElement</td><td>对于 mouseover 和 mouseout 事件，该属性引用移入鼠标的元素。</td></tr><tr><td align="center">x,y</td><td>事件发生的位置的 x 坐标和 y 坐标，它们相对于用CSS动态定位的最内层包容元素。</td></tr></tbody></table><ul><li>标准 Event 属性<br>下面列出了 2 级 DOM 事件标准定义的属性。</li></ul><table><thead><tr><th align="center">属性</th><th>描述</th></tr></thead><tbody><tr><td align="center">bubbles</td><td>返回布尔值，指示事件是否是起泡事件类型。</td></tr><tr><td align="center">cancelable</td><td>返回布尔值，指示事件是否可拥可取消的默认动作。</td></tr><tr><td align="center">currentTarget</td><td>返回其事件监听器触发该事件的元素。</td></tr><tr><td align="center">eventPhase</td><td>返回事件传播的当前阶段。</td></tr><tr><td align="center">target</td><td>返回触发此事件的元素（事件的目标节点）。</td></tr><tr><td align="center">timeStamp</td><td>返回事件生成的日期和时间。</td></tr><tr><td align="center">type</td><td>返回当前 Event 对象表示的事件的名称。</td></tr></tbody></table><ul><li>标准 Event 方法<br>下面列出了 2 级 DOM 事件标准定义的方法。IE 的事件模型不支持这些方法：</li></ul><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">initEvent()</td><td>初始化新创建的 Event 对象的属性。</td></tr><tr><td align="center">preventDefault()</td><td>通知浏览器不要执行与事件关联的默认动作。</td></tr><tr><td align="center">stopPropagation()</td><td>不再派发事件。</td></tr></tbody></table><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &lt;ul&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;6&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var list_li = document.getElementsByTagName(&quot;li&quot;);</span><br><span class="line">  for(let i = 0; i &lt; list_li.length; i++) &#123;</span><br><span class="line">    list_li[i].onclick = function () &#123;</span><br><span class="line">      console.log(i + 1);</span><br><span class="line">      console.log(this.innerText);</span><br><span class="line">      console.log(this.innerHTML);</span><br><span class="line">      console.log(list_li[i].childNodes[0].nodeValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;Document对象&quot;&gt;&lt;a href=&quot;#Document对象&quot; class=&quot;headerlink&quot; title=&quot;Documen
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-自测题3</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%983/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题3/</id>
    <published>2019-09-23T05:50:51.000Z</published>
    <updated>2019-09-25T02:48:17.922Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h4><ol><li><p>不允许使用未声明的变量</p></li><li><p>不允许删除变量或对象。</p></li><li><p>不允许删除函数。</p></li><li><p>不允许变量重名。</p></li><li><p>不允许使用八进制。</p></li><li><p>不允许使用转义字符。</p></li><li><p>不允许对只读属性赋值。</p></li><li><p>不允许对一个使用getter方法读取的属性进行赋值。</p></li><li><p>不允许删除一个不允许删除的属性。</p></li><li><p>变量名不能使用 “eval” 字符串。</p></li><li><p>变量名不能使用 “arguments” 字符串。</p></li><li><p>不允许使用以下这种语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">with (Math)&#123;x = cos(2)&#125;; // 报错</span><br></pre></td></tr></table></figure></li><li><p>由于一些安全原因，在作用域 eval() 创建的变量不能被调用</p></li><li><p>禁止this关键字指向全局对象。</p></li><li><p>禁止使用保留关键字or关键词。</p></li></ol><h4 id="立即执行函数（IIFE）"><a href="#立即执行函数（IIFE）" class="headerlink" title="立即执行函数（IIFE）"></a>立即执行函数（IIFE）</h4><p>在第一部分中提到IIFE实际是为了解决作用域缺陷而诞生的，那么它的诞生给我们带来了哪些好处呢？</p><ul><li><p>不必为函数命名，避免了污染全局变量；</p></li><li><p>IIFE内部形成了单独的作用域，可以封住一些外部无法读取的私有变量。</p></li></ul><h4 id="i和i-区别在于运算顺序和结合方向。"><a href="#i和i-区别在于运算顺序和结合方向。" class="headerlink" title="++i和i++区别在于运算顺序和结合方向。"></a>++i和i++区别在于运算顺序和结合方向。</h4><p>js中有两种自加运算，其运算符均为++，功能为将运算符自加1.<br>其中：<br>++VAR被称为前自加，其后面的变量执行自加操作，其运算为，先执行自加操作，再引用VAR值。<br>VAR++被称为后自加，其前面的变量执行自加操作，其运算为，先引用VAR值，再进行自加操作。</p><p>如果自加语句独立成为一个单独的语句，那么前后自加是完全相同的。<br>比如单独的一行<br>a++;和++a;是一样的。<br>再比如，常见的for循环:<br>for(i = 0; i &lt; 100; i ++)<br>for(i = 0; i &lt; 100; ++i)<br>这里用到的++i和i++是完全相同的，没有区别。</p><p>当运算变量本身值会在自加语句中，同时执行其它操作，二者就有区别了。<br>比如<br>var i =0;<br>while(i++&lt;10);<br>i会先和10比较大小，然后执行自加。这样当i=10时，退出循环，再执行一次自加，退出后i值为11。<br>而如果写成<br>while(++i&lt;10);<br>是先执行自加，然后再与10比较。这样在i=9时，先自加，得到i=10,然后比较就会退出循环了。这种情况下，退出后i值为10。</p><p>再举一个例子。<br>var a, i = 10;<br>a = i ++; //这里i要先赋值，再自加。语句执行后a=10, i = 11;<br>而如果写成：<br>var a, i = 10;<br>a = ++i; //这里i要先自加，再赋值。语句执行后a=11, i = 11;</p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var num = 1;</span><br><span class="line">function test() &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  console.log(this.num++);</span><br><span class="line">&#125;</span><br><span class="line">function test2() &#123;</span><br><span class="line">  console.log(++this.num);</span><br><span class="line">&#125;</span><br><span class="line">(function()&#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  test2();</span><br><span class="line">&#125;)();</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti4.png" alt="kyrie irving"></p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function C1(name) &#123;</span><br><span class="line">  if(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function C2(name)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">function C3(name) &#123;</span><br><span class="line">  this.name = name || &apos;fe&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">C1.prototype.name = &quot;zhang&quot;;</span><br><span class="line">C2.prototype.name = &quot;wang&quot;;</span><br><span class="line">C3.prototype.name = &quot;li&quot;;</span><br><span class="line">console.log((new C1().name) + (new C2().name) + (new C3().name))</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti5.png" alt="kyrie irving"></p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function test () &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;;</span><br><span class="line">(function()&#123;</span><br><span class="line">if(false)&#123;</span><br><span class="line">  function test()&#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">&#125;)();</span><br><span class="line">// 立即执行函数   函数作用域</span><br><span class="line">// test is not a function</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;严格模式的限制&quot;&gt;&lt;a href=&quot;#严格模式的限制&quot; class=&quot;headerlink&quot; title=&quot;严格模式的限制&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 自测题2</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%982/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题2/</id>
    <published>2019-09-23T02:10:26.000Z</published>
    <updated>2019-09-25T02:48:13.018Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="this的取值"><a href="#this的取值" class="headerlink" title="this的取值"></a>this的取值</h4><p>在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。</p><h4 id="this的4种绑定规则"><a href="#this的4种绑定规则" class="headerlink" title="this的4种绑定规则"></a>this的4种绑定规则</h4><ul><li>全局环境中，this默认绑定到window</li><li>函数独立调用时，this默认绑定到window</li><li>被嵌套的函数独立调用时，this默认绑定到window</li><li>IIFE立即执行函数实际上是函数声明后直接调用执行</li><li>闭包（类似地，test()函数是独立调用，而不是方法调用，所以this默认绑定到window）</li></ul><h4 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h4><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。</p><h4 id="“构造函数“"><a href="#“构造函数“" class="headerlink" title="“构造函数“"></a>“构造函数“</h4><p>在 JavaScript 中对于“构造函数”最准确的解释是，所有带 new 的函数调用。函数不是构造函数，但是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">this.a = 20;              </span><br><span class="line">function go() &#123;           </span><br><span class="line">  /* body... */</span><br><span class="line">  console.log(this.a);    </span><br><span class="line">  this.a = 30;            </span><br><span class="line">&#125;;</span><br><span class="line">go.prototype.a = 40;       </span><br><span class="line">var test = &#123;              </span><br><span class="line">  a: 50,</span><br><span class="line">  init: function(fn) &#123;    </span><br><span class="line">    fn();</span><br><span class="line">    console.log(this.a);  </span><br><span class="line">    return fn;            </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log((new go()).a);  </span><br><span class="line">test.init(go);              </span><br><span class="line">var p = test.init(go);      </span><br><span class="line">p();</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti3.png" alt="kyrie irving"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;this的取值&quot;&gt;&lt;a href=&quot;#this的取值&quot; class=&quot;headerlink&quot; title=&quot;this的取值&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 自测题1</title>
    <link href="https://liushuai97.github.io/2019/09/23/JavaScript-%E8%87%AA%E6%B5%8B%E9%A2%981/"/>
    <id>https://liushuai97.github.io/2019/09/23/JavaScript-自测题1/</id>
    <published>2019-09-23T00:46:20.000Z</published>
    <updated>2019-09-25T02:48:08.266Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --><h4 id="什么是作用域："><a href="#什么是作用域：" class="headerlink" title="什么是作用域："></a>什么是作用域：</h4><p>浏览器给js的生存环境叫作用域。</p><h4 id="什么是变量提升："><a href="#什么是变量提升：" class="headerlink" title="什么是变量提升："></a>什么是变量提升：</h4><ol><li><p>Js代码执行前，浏览器会给一个全局作用域window</p></li><li><p>Window分两个模块一个是存储模块一个是执行模块</p></li><li><p>存储模块找到所有的var和function 关键字给这些变量添加内存地址</p></li><li><p>执行模块，代码从上到下执行，遇到变量就会去存储模块查找，有和没有</p></li><li><p>有就看你赋值没有，赋值了就是后面的值没有赋值就是undefined。</p></li><li><p>没有结果就是xxx is not defined</p></li></ol><h4 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h4><p>函数内部的变量被使用时，首先会在自己的私有作用域下查找是否有这个变量，有就直接使用，没有就向他的上一级查找，父级有就使用父级的，父级没有就以此继续向上查找直到查找带window有就使用没有就是is not defined。这种查找机制我们叫原型链。</p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alert(a);</span><br><span class="line">a();</span><br><span class="line">var a = 3;</span><br><span class="line">function a() &#123;</span><br><span class="line">  /* body... */</span><br><span class="line">  alert(10);</span><br><span class="line">&#125;           </span><br><span class="line">alert(a);</span><br><span class="line">a = 6;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti1.png" alt="kyrie irving"></p><ul><li>例题：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var x = 1,</span><br><span class="line">    y = 0,</span><br><span class="line">    z = 0;</span><br><span class="line">function add(x) &#123;</span><br><span class="line">  /* body... */</span><br><span class="line">  return (x = x + 1);</span><br><span class="line">&#125;;</span><br><span class="line">y = add (x);</span><br><span class="line">console.log(y);</span><br><span class="line">function add(x) &#123;</span><br><span class="line">  return (x = x + 3);</span><br><span class="line">&#125;;</span><br><span class="line">z = add(x);</span><br><span class="line">console.log(z);</span><br></pre></td></tr></table></figure><ul><li>分析图：</li></ul><p><img src="ti2.png" alt="kyrie irving"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Sep 30 2019 16:17:24 GMT+0800 (GMT+08:00) --&gt;&lt;h4 id=&quot;什么是作用域：&quot;&gt;&lt;a href=&quot;#什么是作用域：&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域：&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://liushuai97.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
